diff -Naur --exclude=.svn src/org/spoofax/JsglrGWT.gwt.xml ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/JsglrGWT.gwt.xml
--- src/org/spoofax/JsglrGWT.gwt.xml	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/JsglrGWT.gwt.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module rename-to='jsglrgwt'>
-
-  <inherits name='com.google.gwt.user.User'/>
-  <inherits name="com.google.gwt.http.HTTP"/>
-  <inherits name="org.spoofax.termsGWT"/>
-
-  <source path=''>
-    <exclude name="**/io/**"/>
-    <exclude name="**/jsglr/server/**"/>
-	<exclude name="**/Main.java"/>
-  </source>
-  <source path='jsglr/client'/>
-  <source path='jsglr/shared'/>
-  <source path='client'/>
-  <source path='jsglr/tests'/>
-<!-- 
-  <entry-point class='org.spoofax.client.JSGLREntryPoint'/>
- -->
-</module>
diff -Naur --exclude=.svn src/org/spoofax/client/JSGLREntryPoint.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/client/JSGLREntryPoint.java
--- src/org/spoofax/client/JSGLREntryPoint.java	2012-09-28 00:52:38.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/client/JSGLREntryPoint.java	2012-09-28 00:32:13.000000000 +0200
@@ -83,7 +83,9 @@
 			wrap(e);
 		} catch (final SGLRException e) {
 			wrap(e);
-		}
+		} catch (InterruptedException e) {
+      wrap(e);
+    }
 
 	}
 	private static void wrap(Exception e) {
diff -Naur --exclude=.svn src/org/spoofax/jsglr/Main.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/Main.java
--- src/org/spoofax/jsglr/Main.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/Main.java	2012-09-28 00:32:14.000000000 +0200
@@ -18,11 +18,9 @@
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.Asfix2TreeBuilder;
-import org.spoofax.jsglr.client.ITreeBuilder;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.NullTreeBuilder;
 import org.spoofax.jsglr.client.ParseTable;
-import org.spoofax.jsglr.client.imploder.MemoryRecordingTreeBuilder;
 import org.spoofax.jsglr.client.imploder.TermTreeFactory;
 import org.spoofax.jsglr.client.imploder.TreeBuilder;
 import org.spoofax.jsglr.io.FileTools;
@@ -37,7 +35,7 @@
 	
 	private static final String NO_OUTPUT = "-";
 
-	public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException {
+	public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException {
 
 		if(args.length < 2) {
 			usage();
@@ -57,7 +55,6 @@
 		boolean buildParseTree = true;
 		boolean implode = false;
 		boolean ambiguityIsError = false;
-		boolean measureMemory = false;
 		int profilingRuns = 1;
 		
 		int warmup = 0;
@@ -89,8 +86,6 @@
 				profilingRuns = Integer.parseInt(args[++i]);
 			} else if(args[i].equals("--timing")) {
 				timing = true;
-			} else if(args[i].equals("--measure-memory")) {
-				measureMemory = true;
 			} else if(args[i].equals("--warmup")) {
 				warmup = Integer.parseInt(args[++i]);
 			} else if(args[i].equals("--no-tree-build")) {
@@ -109,12 +104,11 @@
 			usage();
 		}
 
-		ITreeBuilder treeBuilder = new Asfix2TreeBuilder(); 
 		final TermFactory factory = new TermFactory();
 		long tableLoadingTime = System.currentTimeMillis();
 		final IStrategoTerm tableTerm = new TermReader(factory).parseFromFile(parseTableFile);
 		final ParseTable pt = new ParseTable(tableTerm, factory);
-		final SGLR sglr = new SGLR(treeBuilder, pt);
+		final SGLR sglr = new SGLR(new Asfix2TreeBuilder(), pt);
 		sglr.setUseStructureRecovery(recover);
 
 		tableLoadingTime = System.currentTimeMillis() - tableLoadingTime;
@@ -126,17 +120,9 @@
 		sglr.getDisambiguator().setHeuristicFilters(heuristicFilters);
 		sglr.getDisambiguator().setAmbiguityIsError(ambiguityIsError);
 		if (!buildParseTree)
-			treeBuilder = new NullTreeBuilder();
+			sglr.setTreeBuilder(new NullTreeBuilder());
 		else if (implode)
-			treeBuilder = new TreeBuilder(new TermTreeFactory(new TermFactory()), true);
-		
-		MemoryRecordingTreeBuilder memory = null;
-		if(measureMemory) {
-			memory = new MemoryRecordingTreeBuilder(treeBuilder);
-			sglr.setTreeBuilder(memory);
-		} else {
-			sglr.setTreeBuilder(treeBuilder);
-		}
+			sglr.setTreeBuilder(new TreeBuilder(new TermTreeFactory(new TermFactory()), true));
 		
 		String input = FileTools.loadFileAsString(new BufferedReader(new FileReader(inputFile)));
 		
@@ -162,17 +148,11 @@
 			System.err.println("Parse table loading time : " + tableLoadingTime + "ms");
 			System.err.println("Parsing time             : " + (parsingTime / profilingRuns) + "ms");
 		}
-		
-		if(measureMemory) {
-			System.err.println("Total memory (min/max)   : " + memory.getMinTotal() + " / " + memory.getMaxTotal());
-			System.err.println("Used memory (min/max)    : " + memory.getMinUsed() + " / " + memory.getMaxUsed());
-			System.err.println("# of memory measurements : " + memory.getMeasureCount());
-		}
 	}
 
 	private static void warmup(final SGLR sglr, String inputFile, String input,
 			String startSymbol, int warmup) throws FileNotFoundException,
-			IOException {
+			IOException, InterruptedException {
 		long time = System.currentTimeMillis();
 		while (System.currentTimeMillis() < time + warmup * 1000) {
 			parseFile(input, inputFile, NO_OUTPUT, sglr, startSymbol);
@@ -181,7 +161,7 @@
 	}
 
 	public static long parseFile(String input, String inputFile, String output, SGLR sglr, String startSymbol)
-	throws FileNotFoundException, IOException {
+	throws FileNotFoundException, IOException, InterruptedException {
 		/* TODO: support stdin input
 		InputStream fis = null;
 		if(input == null) {
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/AbstractParseNode.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AbstractParseNode.java
--- src/org/spoofax/jsglr/client/AbstractParseNode.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AbstractParseNode.java	2012-09-28 00:32:16.000000000 +0200
@@ -7,80 +7,238 @@
  */
 package org.spoofax.jsglr.client;
 
-import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Stack;
 
+import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
 
 public abstract class AbstractParseNode {
 
-    public static final int PARSE_PRODUCTION_NODE = 1;
-    public static final int PARSENODE = 2;
-    public static final int AMBIGUITY = 3;
-    public static final int PREFER = 4;
-    public static final int AVOID = 5;
-    public static final int REJECT = 6;
-    public static final int CYCLE = 7;
-    
-    public final boolean isAmbNode(){
-    	return getNodeType()==AbstractParseNode.AMBIGUITY;
+  public static final int PARSE_PRODUCTION_NODE = 1;
+  public static final int PARSENODE = 2;
+  public static final int AMBIGUITY = 3;
+  public static final int PREFER = 4;
+  public static final int AVOID = 5;
+  public static final int REJECT = 6;
+  public static final int CYCLE = 7;
+
+  private final int line;
+  private final int column;
+  
+  private Map<String, Object> properties;
+
+  public AbstractParseNode(int line, int column) {
+    this.line = line;
+    this.column = column;
+  }
+
+  public final boolean isAmbNode() {
+    return getNodeType() == AbstractParseNode.AMBIGUITY;
+  }
+
+  public final boolean isParseNode() {
+    switch (getNodeType()) {
+    case AbstractParseNode.PARSENODE:
+    case AbstractParseNode.REJECT:
+    case AbstractParseNode.PREFER:
+    case AbstractParseNode.AVOID:
+      return true;
+    default:
+      return false;
     }
+  }
 
-    public final boolean isParseNode(){
-    	switch(getNodeType()) {
-    		case AbstractParseNode.PARSENODE:
-    		case AbstractParseNode.REJECT:
-    		case AbstractParseNode.PREFER:
-    		case AbstractParseNode.AVOID: return true;
-    	default:
-    		return false;
-    	}
-    }
+  public final boolean isParseRejectNode() {
+    return getNodeType() == AbstractParseNode.REJECT;
+  }
 
-    public final boolean isParseRejectNode(){
-    	return getNodeType()==AbstractParseNode.REJECT;
-    }
+  public final boolean isParseProductionNode() {
+    return getNodeType() == AbstractParseNode.PARSE_PRODUCTION_NODE;
+  }
 
-    public final boolean isParseProductionNode(){
-    	return getNodeType()==AbstractParseNode.PARSE_PRODUCTION_NODE;
-    }
-    
-    public final boolean isCycle() {
-    	return getNodeType() == CYCLE;
-    }
-    
-    public abstract void reject();
+  public final boolean isCycle() {
+    return getNodeType() == CYCLE;
+  }
+
+  public int getColumn() {
+    return column;
+  }
+
+  public int getLine() {
+    return line;
+  }
+
+  public abstract void reject();
+
+  abstract public int getLabel();
+
+  abstract public int getNodeType();
+
+  abstract public AbstractParseNode[] getChildren();
+
+  protected static final int NO_HASH_CODE = 0;
+
+  public abstract Object toTreeBottomup(BottomupTreeBuilder builder);
 
-    abstract public int getNodeType();
-    abstract public AbstractParseNode[] getChildren();
-    abstract public int getLabel();
+  public abstract Object toTreeTopdown(TopdownTreeBuilder builder);
+
+  @Override
+  public boolean equals(Object obj) {
+    if (!(obj instanceof AbstractParseNode))
+      return false;
     
-    protected static final int NO_HASH_CODE = 0;
+    return ((AbstractParseNode) obj).line == line && ((AbstractParseNode) obj).column == column;
+  }
+
+  @Override
+  public int hashCode() {
+    return line * 9197 + column;
+  }
+
+  abstract public String toStringShallow();
+
+  @Override
+  abstract public String toString();
+
+  /**
+   * Returns true if this node is in a parse production chain, i.e. it is
+   * either: - a {@link ParseProductionNode}. - a ParseNode with a
+   * {@link ParseProductionNode} child and an {@link #isParseProductionChain()}
+   * child. - a ParseNode with a single {@link #isParseProductionChain()} child.
+   * 
+   * Implementations may also return true only for the topmost node of a parse
+   * production chain.
+   */
+  public abstract boolean isParseProductionChain();
 
-    public abstract Object toTreeBottomup(BottomupTreeBuilder builder);
+  /**
+   * @return true iff this node does not contain any character data
+   */
+  public abstract boolean isEmpty();
+  
+  public abstract AbstractParseNode getLeft();
+  
+  public abstract boolean isLayout();
+  public abstract boolean isIgnoreLayout();
+
+  public int getAmbiguityCount() {
+    Stack<AbstractParseNode> nodes = new Stack<AbstractParseNode>();
+    nodes.push(this);
     
-    public abstract Object toTreeTopdown(TopdownTreeBuilder builder);
+    int amb = 0;
     
-    @Override
-	abstract public boolean equals(Object obj);
+    while (!nodes.isEmpty()) {
+      AbstractParseNode next = nodes.pop();
+      if (next.isAmbNode())
+        amb++;
+      
+      nodes.addAll(Arrays.asList(next.getChildren()));  
+    }
     
-    @Override
-	abstract public int hashCode();
+    return amb;
+  }
 
-    abstract public String toStringShallow();
+  public final static int NEWLINE_LAYOUT = 2;
+  public final static int NONEWLINE_LAYOUT = 1;
+  public final static int OTHER_LAYOUT = 0;
+  
+  /**
+   * @return NEWLINE_LAYOUT if node ends with layout that contains a newline
+   * @return NONEWLINE_LAYOUT if node only contains layout character data (also true if node is empty)
+   * @return OTHER_LAYOUT if node contains non-layout character data and does not end with layout that
+   *           contains a newline 
+   */
+  public int getLayoutStatus() {
+    if (isLayout() && hasNewline())
+        return NEWLINE_LAYOUT;
+    if (isLayout())
+      return NONEWLINE_LAYOUT;
     
-    @Override
-	abstract public String toString();
-    
-    /**
-     * Returns true if this node is in a parse production chain,
-     * i.e. it is either:
-     * - a {@link ParseProductionNode}.
-     * - a ParseNode with a {@link ParseProductionNode} child
-     *   and an {@link #isParseProductionChain()} child.
-     * - a ParseNode with a single {@link #isParseProductionChain()}
-     *   child.
-     *   
-     * Implementations may also return true only for the topmost
-     * node of a parse production chain.
+    /*
+     * Elements of `nodes` are never descendant of a `isLayout()` node. 
      */
-    public abstract boolean isParseProductionChain();
+    LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
+    nodes.addFirst(this);
+    
+    while (!nodes.isEmpty()) {
+      AbstractParseNode node = nodes.pollFirst();
+      
+      if (node.isLayout()) {
+        if (node.hasNewline())
+          return NEWLINE_LAYOUT;
+      }
+      else if (node.isParseProductionNode())
+        return OTHER_LAYOUT;
+      else 
+        for (int i = 0; i < node.getChildren().length; i++)
+          nodes.addFirst(node.getChildren()[i]);
+    }
+    
+    // this is not layout but also does not contain parse production nodes => treat like layout
+    return NONEWLINE_LAYOUT;
+  }
+  
+  private boolean hasNewline() {
+    LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
+    nodes.add(this);
+    
+    while (!nodes.isEmpty()) {
+      AbstractParseNode node = nodes.poll();
+      if (node.isParseProductionNode() && node.getLabel() == 10 || node.getLabel() == 13)
+        return true;
+
+      for (AbstractParseNode kid : node.getChildren())
+        nodes.add(kid);
+    }
+    
+    return false;
+  }
+
+  public AbstractParseNode getLast() {
+    AbstractParseNode n = this;
+    while (n.getChildren().length > 0)
+      for (int i = n.getChildren().length - 1; i >= 0; i--) {
+        AbstractParseNode kid = n.getChildren()[i];
+        if (kid.isEmpty() || kid.isLayout())
+          continue;
+        n = kid;
+        break;
+      }
+    return n;
+  }
+  
+  public AbstractParseNode getRight() {
+    AbstractParseNode last = getLast();
+    AbstractParseNode right = null;
+    
+    for (int i = getChildren().length - 1; i >= 0; i--) {
+      AbstractParseNode kid = getChildren()[i];
+      AbstractParseNode kidLast = kid.getLast();
+      if (!kid.isLayout() && !kid.isEmpty() && !kid.isIgnoreLayout()) {
+        if (kidLast.getLine() < last.getLine() && (right == null || kidLast.getColumn() > right.getColumn()))
+          right = kidLast;
+        AbstractParseNode kidRight = kid.getRight();
+        if (kidRight != null && 
+            kidRight.getLine() < last.getLine() &&
+            (right == null || kidRight.getColumn() > right.getColumn()))
+          right = kidRight;
+      }
+    }
+    return right;
+  }
+
+  public void setProperty(String key, Object val) {
+    if (properties == null)
+      properties = new HashMap<String, Object>();
+    properties.put(key, val);
+  }
+  
+  public Object getProperty(String key) {
+    if (properties == null)
+      return null;
+    return properties.get(key);
+  }
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Accept.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Accept.java
--- src/org/spoofax/jsglr/client/Accept.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Accept.java	2012-09-28 00:32:16.000000000 +0200
@@ -8,6 +8,7 @@
 package org.spoofax.jsglr.client;
 
 
+
 public class Accept extends ActionItem {
 
     private static final long serialVersionUID = -3768565929814294895L;
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/AmbKey.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AmbKey.java
--- src/org/spoofax/jsglr/client/AmbKey.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AmbKey.java	2012-09-28 00:32:15.000000000 +0200
@@ -8,6 +8,7 @@
 package org.spoofax.jsglr.client;
 
 
+
 public class AmbKey {
 
     private AbstractParseNode key;
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/AmbiguityManager.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AmbiguityManager.java
--- src/org/spoofax/jsglr/client/AmbiguityManager.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AmbiguityManager.java	2012-09-28 00:32:16.000000000 +0200
@@ -58,6 +58,14 @@
         ambiguitiesCount++;
     }
 
+    public void decreaseAmbiguityCount() {
+      ambiguitiesCount--;
+    }
+
+    public void decreaseAmbiguityCount(int c) {
+      ambiguitiesCount -= c;
+    }
+    
     public int getClusterIndex(AbstractParseNode t, int pos) {
         if(Tools.debugging) {
             Tools.debug("getClusterIndex()");
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/BacktrackPosition.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/BacktrackPosition.java
--- src/org/spoofax/jsglr/client/BacktrackPosition.java	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/BacktrackPosition.java	2012-09-28 00:32:15.000000000 +0200
@@ -0,0 +1,29 @@
+package org.spoofax.jsglr.client;
+
+import java.util.ArrayList;
+
+import org.spoofax.jsglr.shared.ArrayDeque;
+
+public class BacktrackPosition {
+    public final int tokensSeen;
+    public final ArrayDeque<Frame> recoverStacks;
+    public final ArrayList<RecoverNode> recoverNodes; 
+    public boolean isVisited;
+    private int indexHistory;    
+    
+    public int getIndexHistory() {
+        return indexHistory;
+    }
+    
+    public BacktrackPosition( ArrayDeque<Frame> activeStacks, int tokSeen)
+    {
+        tokensSeen=tokSeen;
+        recoverStacks = new ArrayDeque<Frame>(activeStacks);        
+        recoverNodes=new ArrayList<RecoverNode>();        
+    }
+
+    public void setIndexHistory(int i) {
+        indexHistory=i;
+    }
+
+}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/CycleParseNode.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/CycleParseNode.java
--- src/org/spoofax/jsglr/client/CycleParseNode.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/CycleParseNode.java	2012-09-28 00:32:16.000000000 +0200
@@ -2,6 +2,7 @@
 
 import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
 
+
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
  */
@@ -11,8 +12,10 @@
 		new AbstractParseNode[0];
 	
 	private ParseNode target;
+	private transient AbstractParseNode nonAmbiguousTarget = null;
 	
 	public CycleParseNode(ParseNode target) {
+	  super(target.getLine(), target.getColumn());
 		this.target = target;
 	}
 
@@ -30,23 +33,29 @@
 	public Object toTreeBottomup(BottomupTreeBuilder builder) {
 		return builder.buildCycle(getTargetLabel());
 	}
-
+	
+	 @Override
+	  public Object toTreeTopdown(TopdownTreeBuilder builder) {
+	    return builder.buildTreeCycle(this);
+	  }
+
+	private AbstractParseNode getNonAmbiguousTarget() {
+	  if (nonAmbiguousTarget != null)
+	    return nonAmbiguousTarget;
+	  
+	  nonAmbiguousTarget = this.target;
+    while (target.isAmbNode())
+      nonAmbiguousTarget = target.getChildren()[0];
+    return nonAmbiguousTarget;
+	}
+	
 	public int getTargetLabel() {
-		AbstractParseNode target = this.target;
-		while (target.isAmbNode()) {
-			target = target.getChildren()[0];
-		}
-		if (target.isParseNode())
-			return ((ParseNode) target).getLabel();
+		if (getNonAmbiguousTarget().isParseNode())
+			return ((ParseNode) getNonAmbiguousTarget()).getLabel();
 		return -1;
 	}
 
 	@Override
-	public Object toTreeTopdown(TopdownTreeBuilder builder) {
-		return builder.buildTreeCycle(this);
-	}
-	
-	@Override
 	public void reject() {
 		throw new UnsupportedOperationException();
 	}
@@ -90,11 +99,30 @@
 			return false;
 		return true;
 	}
-	
-	@Override
-    public int getLabel() {
-		return target.getLabel();
-	}
-
 
+  @Override
+  public int getLabel() {
+    // TODO Auto-generated method stub
+    return 0;
+  }
+
+  @Override
+  public boolean isEmpty() {
+    return getNonAmbiguousTarget().isEmpty();
+  }
+  
+  @Override
+  public AbstractParseNode getLeft() {
+    return target.getLeft();
+  }
+  
+  @Override
+  public boolean isLayout() {
+    return target.isLayout();
+  }
+
+  @Override
+  public boolean isIgnoreLayout() {
+    return target.isIgnoreLayout();
+  }
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Disambiguator.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Disambiguator.java
--- src/org/spoofax/jsglr/client/Disambiguator.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Disambiguator.java	2012-09-28 00:32:15.000000000 +0200
@@ -17,14 +17,16 @@
 import static org.spoofax.terms.Term.termAt;
 
 import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
-import java.util.Stack;
 
 import org.spoofax.NotImplementedException;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoList;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.imploder.ProductionAttributeReader;
+import org.spoofax.jsglr.client.indentation.LayoutFilter;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.Tools;
 
@@ -33,1298 +35,1454 @@
  * @author Lennart Kats <lennart add lclnet.nl>
  */
 public class Disambiguator {
+  private static final boolean LAYOUT_FITERING = true;
 
-	private static final int FILTER_DRAW = 1;
+  private static final int FILTER_DRAW = 1;
 
-	private static final int FILTER_LEFT_WINS = 2;
+  private static final int FILTER_LEFT_WINS = 2;
 
-	private static final int FILTER_RIGHT_WINS = 3;
+  private static final int FILTER_RIGHT_WINS = 3;
 
-	private boolean filterAny;
+  private boolean filterAny;
 
-	private boolean filterCycles;
-
-	private boolean filterDirectPreference;
-
-	private boolean filterPreferenceCount;
-
-	private boolean filterInjectionCount;
-
-	private boolean filterTopSort;
-
-	private boolean filterReject;
-
-	private boolean filterAssociativity;
-
-	private boolean filterPriorities;
-
-	private boolean filterStrict;
-
-	private boolean logStatistics;
-
-	private boolean ambiguityIsError;
-	
-	/**
-	 * A parse node that was rejected in the current subtree,
-	 * or null if no parse node was rejected.
-	 */
-	private AbstractParseNode rejectedBranch;
-
-	// Current parser state
-
-	private AmbiguityManager ambiguityManager;
-
-	private SGLR parser;
-
-	private ParseTable parseTable;
-
-	private ProductionAttributeReader prodReader;
-
-	// private Map<AmbKey, IParseNode> resolvedTable = new HashMap<AmbKey, IParseNode>();
-
-	/**
-	 * Sets whether any filter should be applied at all (excluding the top sort filter).
-	 */
-	public final void setFilterAny(boolean filterAny) {
-		this.filterAny = filterAny;
-	}
-
-	public final void setFilterDirectPreference(boolean filterDirectPreference) {
-		this.filterDirectPreference = filterDirectPreference;
-	}
-
-	public boolean getFilterDirectPreference() {
-		return filterDirectPreference;
-	}
-
-	/**
-	 * For preference count filtering, see {@link #setFilterPreferenceCount(boolean)}.
-	 */
-	@Deprecated
-	public final void setFilterIndirectPreference(boolean filterIndirectPreference) {
-		throw new UnsupportedOperationException();
-	}
-
-	/**
-	 * For preference count filtering, see {@link #getFilterPreferenceCount()}.
-	 */
-	@Deprecated
-	public boolean getFilterIndirectPreference() {
-		throw new UnsupportedOperationException();
-	}
-
-	public final void setFilterInjectionCount(boolean filterInjectionCount) {
-		this.filterInjectionCount = filterInjectionCount;
-	}
-
-	public boolean getFilterInjectionCount() {
-		return filterInjectionCount;
-	}
-
-	public final void setFilterPreferenceCount(boolean filterPreferenceCount) {
-		this.filterPreferenceCount = filterPreferenceCount;
-	}
-
-	public boolean getFilterPreferenceCount() {
-		return filterPreferenceCount;
-	}
-
-	public final void setFilterTopSort(boolean filterTopSort) {
-		this.filterTopSort = filterTopSort;
-	}
-
-	public boolean getFilterTopSort() {
-		return filterTopSort;
-	}
-
-	public void setFilterCycles(boolean filterCycles) {
-		this.filterCycles = filterCycles;
-	}
-
-	public boolean isFilterCycles() {
-		return filterCycles;
-	}
-
-	public void setFilterAssociativity(boolean filterAssociativity) {
-		this.filterAssociativity = filterAssociativity;
-	}
-
-	public boolean getFilterAssociativity() {
-		return filterAssociativity;
-	}
-
-	public void setFilterPriorities(boolean filterPriorities) {
-		this.filterPriorities = filterPriorities;
-	}
-
-	public boolean getFilterPriorities() {
-		return filterPriorities;
-	}
-
-	/**
-	 * Sets whether to enable strict filtering, triggering a
-	 * FilterException when the priorities filter encounters
-	 * an unfiltered ambiguity.
-	 */
-	public void setFilterStrict(boolean filterStrict) {
-		this.filterStrict = filterStrict;
-	}
-
-	public boolean getFilterStrict() {
-		return filterStrict;
-	}
-
-	public final void setHeuristicFilters(boolean heuristicFilters) {
-		setFilterPreferenceCount(heuristicFilters);
-		setFilterInjectionCount(heuristicFilters);
-	}
-
-	public void setFilterReject(boolean filterReject) {
-		this.filterReject = filterReject;
-	}
-
-	public boolean getFilterReject() {
-		return filterReject;
-	}
-
-	public void setLogStatistics(boolean logStatistics) {
-		this.logStatistics = logStatistics;
-	}
-
-	public boolean getLogStatistics() {
-		return logStatistics;
-	}
-
-	public void setAmbiguityIsError(boolean ambiguityIsError) {
-		this.ambiguityIsError = ambiguityIsError;
-	}
-
-	public boolean getAmbiguityIsError() {
-		return ambiguityIsError;
-	}
-
-	public final void setDefaultFilters() {
-		filterAny = true;
-		filterCycles = false; // TODO: filterCycles; enable by default
-		filterDirectPreference = true;
-		filterPreferenceCount = false;
-		filterInjectionCount = false;
-		filterTopSort = true;
-		filterReject = true;
-		filterAssociativity = true;
-		filterPriorities = true;
-		filterStrict = false; // TODO: disable filterStrict hack
-		logStatistics = true;
-		ambiguityIsError = false;
-	}
-
-	public Disambiguator() {
-		setDefaultFilters();
-	}
-
-    public Object applyFilters(SGLR parser, AbstractParseNode root, String sort, int inputLength) throws SGLRException, FilterException {
-    	AbstractParseNode t = root;
-		if(Tools.debugging) {
-			Tools.debug("applyFilters()");
-		}
-
-    	try {
-    		try {
-	            if(Tools.debugging) {
-	                Tools.debug("applyFilters()");
-	            }
-
-	            initializeFromParser(parser);
-	            t = applyTopSortFilter(sort, t);
-
-	            if (filterAny) {
-	                t = applyCycleDetectFilter(t);
-
-	                // SG_FilterTree
-	                ambiguityManager.resetClustersVisitedCount();
-	                t = filterTree(t, false);
-	            }
-
-				if (filterReject && rejectedBranch != null && !parser.useIntegratedRecovery)
-					throw new FilterException(parser, "Unexpected reject annotation in " + yieldTree(rejectedBranch));
-	        } catch (RuntimeException e) {
-	            throw new FilterException(parser, "Runtime exception when applying filters", e);
-	        } finally {
-	        	rejectedBranch = null;
-	        }
-
-	        return yieldTreeTop(t);
-
-        } finally {
-            initializeFromParser(null);
-        }
-    }
-
-	private void initializeFromParser(SGLR parser) {
-		if (parser == null) {
-			this.parser = null;
-			parseTable = null;
-			ambiguityManager = null;
-		} else {
-			this.parser = parser;
-			parseTable = parser.getParseTable();
-			prodReader = new ProductionAttributeReader(parseTable.getFactory());
-			ambiguityManager = parser.getAmbiguityManager();
-		}
-	}
-
-	private void logStatus() {
-		Tools.logger("Number of rejects: ", parser.getRejectCount());
-		Tools.logger("Number of reductions: ", parser.getReductionCount());
-		Tools.logger("Number of ambiguities: ", ambiguityManager.getMaxNumberOfAmbiguities());
-		Tools.logger("Number of calls to Amb: ", ambiguityManager.getAmbiguityCallsCount());
-		Tools.logger("Count Eagerness Comparisons: ", ambiguityManager.getEagernessComparisonCount(), " / ", ambiguityManager.getEagernessSucceededCount());
-		Tools.logger("Number of Injection Counts: ", ambiguityManager.getInjectionCount());
-	}
-
-    private Object yieldTree(AbstractParseNode t) {
-		parser.getTreeBuilder().reset(); // in case yieldTree is used for debugging
-		return parser.getTreeBuilder().buildTree(t);
-    }
-
-    private Object yieldTreeTop(AbstractParseNode t) throws SGLRException {
-        int ambCount = ambiguityManager.getAmbiguitiesCount();
-
-		if (Tools.debugging) {
-			Tools.debug("convertToATerm: ", t);
-		}
-
-		try {
-			ambiguityManager.resetAmbiguityCount();
-			final Object r = yieldTree(t);
-
-			if(logStatistics)
-				logStatus();
-
-	        if (Tools.debugging) {
-	            Tools.debug("yield: ", r);
-	        }
-
-	        if(ambiguityIsError && ambCount > 0) {
-	        	throw new SGLRException(parser, "Ambiguities found") ;
-	        }
-	        else {
-	        	return parser.getTreeBuilder().buildTreeTop(r, ambCount);
-	        }
-		} finally {
-			parser.getTreeBuilder().reset();
-		}
-    }
-
-	private AbstractParseNode applyCycleDetectFilter(AbstractParseNode t) throws FilterException {
-
-		if (Tools.debugging) {
-			Tools.debug("applyCycleDetectFilter() - ", t);
-		}
-
-		if (filterCycles) {
-			if (ambiguityManager.getMaxNumberOfAmbiguities() > 0) {
-				if (isCyclicTerm(t)) {
-					throw new FilterException(parser, "Term is cyclic");
-				}
-			}
-		}
-
-		return t;
-	}
-
-	private IStrategoTerm getProduction(AbstractParseNode t) {
-		if (t.isParseNode()) {
-			return parseTable.getProduction(((ParseNode) t).getLabel());
-		} else {
-			return parseTable.getProduction(((ParseProductionNode) t).getProduction());
-		}
-	}
-
-	private AbstractParseNode applyTopSortFilter(String sort, AbstractParseNode t) throws SGLRException {
-
-		if (Tools.debugging) {
-			Tools.debug("applyTopSortFilter() - ", t);
-		}
-
-		if (sort != null && filterTopSort) {
-			t = selectOnTopSort(t, sort);
-			if (t == null) {
-				throw new StartSymbolException(parser, "Desired start symbol not found: " + sort);
-			}
-		}
-
-		return t;
-	}
-
-	private boolean matchProdOnTopSort(IStrategoTerm prod, String sort) throws FilterException {
-		assert sort != null;
-		/*
-		sort = sort.replaceAll("\"", "");
-		return prod.match("prod([cf(opt(layout)),cf(sort(\"" + sort + "\")),cf(opt(layout))], sort(\"<START>\"),no-attrs)") != null
-		|| prod.match("prod([cf(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
-		|| prod.match("prod([lex(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
-		|| prod.match("prod([sort(\"" + sort + "\")], sort(\"<START>\"),no-attrs)") != null;
-		*/
-		IStrategoList lhs = termAt(prod, 0);
-		IStrategoAppl rhs = termAt(prod, 1);
-		String foundSort = prodReader.tryGetFirstSort(lhs);
-		assert foundSort != null;
-		assert "<START>".equals(prodReader.tryGetSort(rhs));
-		return sort.equals(foundSort);
-	}
-
-	private AbstractParseNode selectOnTopSort(AbstractParseNode t, String sort) throws FilterException {
-		final List<AbstractParseNode> results = new ArrayList<AbstractParseNode>();
-
-		if (t.isAmbNode()) {
-			addTopSortAlternatives(t, sort, results);
-
-			switch (results.size()) {
-			case 0: return null;
-			case 1: return results.get(0);
-			default:
-				ambiguityManager.increaseAmbiguityCount();
-				return ParseNode.createAmbNode(results.toArray(new AbstractParseNode[results.size()]));
-			}
-		} else {
-			final IStrategoTerm prod = getProduction(t);
-			return matchProdOnTopSort(prod, sort) ? t : null;
-		}
-	}
-
-	private void addTopSortAlternatives(AbstractParseNode t, String sort, List<AbstractParseNode> results) throws FilterException {
-		for(final AbstractParseNode amb : t.getChildren()) {
-			if (amb.isAmbNode()) {
-				addTopSortAlternatives(amb, sort, results);
-			} else {
-				final IStrategoTerm prod = getProduction(amb);
-				if (matchProdOnTopSort(prod, sort)) {
-					results.add(amb);
-				}
-			}
-		}
-	}
-
-	
-	/**
-	 * Performs a depth-first traversal of the parse tree to
-	 * filter ambiguities. 
-	 */
-	public AbstractParseNode filterTree(AbstractParseNode node,
-			boolean inAmbiguityCluster) throws FilterException {
-		// SG_FilterTreeRecursive
-		if (Tools.debugging) {
-			Tools.debug("filterTree(node)    - ", node);
-		}
-
-		// nodes to be processed
-		Stack<AbstractParseNode> input = new Stack<AbstractParseNode>();
-		// nodes already processed
-		Stack<AbstractParseNode> output = new Stack<AbstractParseNode>();
-		// already processed nodes that have not yet been reinitialized
-		// with their (possibly changed) children
-		Stack<AbstractParseNode> pending = new Stack<AbstractParseNode>();
-
-		input.add(node);
-
-		while (!input.isEmpty() || !pending.isEmpty()) {
-			int pendingPeekPos = pending.isEmpty() ? -1 : output.size()
-					- pending.peek().getChildren().length - 1;
-			
-			if (!pending.isEmpty() && pendingPeekPos >= 0
-					&& output.get(pendingPeekPos) == pending.peek()) {
-				// collapse pending.peek() with its possibly changed children
-				
-				AbstractParseNode t = pending.pop();
-
-				AbstractParseNode[] args = new AbstractParseNode[t
-						.getChildren().length];
-				boolean changed = false;
-
-				for (int i = t.getChildren().length - 1; i >= 0; i--) {
-					args[i] = output.pop();
-					changed = changed || args[i] != t.getChildren()[i];
-				}
-
-				output.pop();
-
-				if (changed)
-					t = new ParseNode(t.getLabel(), args, t.getNodeType());
-
-				if (filterAssociativity)
-					t = applyAssociativityPriorityFilter(t);
-
-				output.push(t);
-			} else {
-				// examine input.peek() and traverse its children
-				
-				AbstractParseNode t = input.pop();
-
-				switch (t.getNodeType()) {
-				case AMBIGUITY:
-					if (!(inAmbiguityCluster && output.isEmpty())) {
-						// (some cycle stuff should be done here)
-						final AbstractParseNode[] ambs = t.getChildren();
-						t = filterAmbiguities(ambs);
-						output.push(t);
-					} else {
-						// FIXME: hasRejectProd(Amb) can never succeed?
-						if (filterReject && parseTable.hasRejects()
-								&& hasRejectProd(t)) {
-							output.push(t);
-						} else {
-							final AbstractParseNode[] ambs = t.getChildren();
-							output.push(filterAmbiguities(ambs));
-						}
-
-					}
-					break;
-				case PARSENODE:
-				case AVOID:
-				case PREFER:
-				case REJECT:
-
-					if (filterReject && parseTable.hasRejects()
-							&& hasRejectProd(t)) {
-						output.push(t);
-						rejectedBranch = t;
-					} else if (t.getChildren().length > 0
-							&& !t.isParseProductionChain()) {
-						output.push(t);
-						pending.push(t);
-						for (int i = t.getChildren().length - 1; i >= 0; i--)
-							input.push(t.getChildren()[i]);
-					} else {
-						output.push(t);
-					}
-					break;
-				case PARSE_PRODUCTION_NODE:
-					// leaf node -- do thing (cannot be any ambiguities here)
-					output.push(t);
-					break;
-				case CYCLE:
-					output.push(t);
-					break;
-				default:
-					throw new IllegalStateException("Unknown node type: " + t);
-				}
-			}
-		}
-
-		assert output.size() == 1;
-		return output.peek();
-	}
-
-	private AbstractParseNode applyAssociativityPriorityFilter(AbstractParseNode t) throws FilterException {
-		// SG_Associativity_Priority_Filter(pt, t)
-		// - ok
-
-		if(Tools.debugging) {
-			Tools.debug("applyAssociativityPriorityFilter() - ", t);
-		}
-
-		AbstractParseNode r = t;
-
-		if (t.isParseNode()) {
-			final Label prodLabel = getProductionLabel(t);
-			final ParseNode n = (ParseNode) t;
-
-			if (filterAssociativity) {
-				if (prodLabel.isLeftAssociative()) {
-					r = applyLeftAssociativeFilter(n, prodLabel);
-				} else if (prodLabel.isRightAssociative()) {
-					r = applyRightAssociativeFilter(n, prodLabel);
-				}
-
-			}
-
-			if (filterPriorities && parseTable.hasPriorities()) {
-				if(Tools.debugging) {
-					Tools.debug(" - about to look up : ",  prodLabel.labelNumber);
-				}
-
-				if (!lookupGtrPriority(prodLabel).isEmpty()) {
-					if(Tools.debugging) {
-						Tools.debug(" - found");
-					}
-					if (r.isAmbNode()) {
-						return r;
-					}
-					return applyPriorityFilter((ParseNode) r, prodLabel);
-				}
-				if(Tools.debugging) {
-					Tools.debug(" - not found");
-				}
-			}
-		}
-
-		return r;
-	}
-
-	private AbstractParseNode applyRightAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
-		// SG_Right_Associativity_Filter(t, prodl)
-		// - almost ok
-
-		if(Tools.debugging) {
-			Tools.debug("applyRightAssociativeFilter() - ", t);
-		}
-
-		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-		final AbstractParseNode[] kids = t.getChildren();
-		final AbstractParseNode firstKid = kids[0];
-
-		if(firstKid.isAmbNode()) {
-
-			for (final AbstractParseNode amb : firstKid.getChildren()) {
-				if(amb.isAmbNode()
-						|| ((ParseNode)amb).getLabel() != prodLabel.labelNumber) {
-					newAmbiguities.add(amb);
-				}
-			}
-
-			// FIXME is this correct?
-					if(!newAmbiguities.isEmpty()) {
-
-						final AbstractParseNode[] restKids = new AbstractParseNode[kids.length];
-						for(int i = 1; i < restKids.length; i++) {
-							restKids[i] = kids[i];
-						}
-						
-						AbstractParseNode extraAmb;
-						if(newAmbiguities.size() > 1) {
-							extraAmb = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
-							ambiguityManager.increaseAmbiguityCount();
-						} else {
-							extraAmb = newAmbiguities.get(0);
-						}
-						restKids[0] = extraAmb;
-
-						return new ParseNode(t.getLabel(), restKids, AbstractParseNode.PARSENODE);
-					} else {
-						throw new FilterException(parser);
-					}
-
-		} else if(firstKid.isParseNode()) {
-			if(((ParseNode)firstKid).getLabel() == prodLabel.labelNumber) {
-				throw new FilterException(parser);
-			}
-		}
-		return t;
-	}
-
-	private AbstractParseNode applyPriorityFilter(ParseNode t, Label prodLabel) throws FilterException {
-		// SG_Priority_Filter
-
-		if(Tools.debugging) {
-			Tools.debug("applyPriorityFilter() - ", t);
-		}
-
-		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-		final List<AbstractParseNode> newKids = new ArrayList<AbstractParseNode>();
-
-		final int l0 = prodLabel.labelNumber;
-		int kidnumber = 0;
-
-		for (final AbstractParseNode kid : t.getChildren()) {
-			AbstractParseNode newKid = kid;
-			final AbstractParseNode injection = jumpOverInjections(kid);
-
-			if (injection.isAmbNode()) {
-				newAmbiguities.clear();
-				for (final AbstractParseNode amb : injection.getChildren()) {
-					final AbstractParseNode injAmb = jumpOverInjections(amb);
-
-					if (injAmb.isParseNode()) {
-						final Label label = getProductionLabel(t);
-						if(hasGreaterPriority(l0, label.labelNumber, kidnumber)) {
-							newAmbiguities.add(amb);
-						}
-					}
-				}
-
-				if(!newAmbiguities.isEmpty()) {
-					AbstractParseNode n = null;
-					if(newAmbiguities.size() > 1) {
-						n = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
-						ambiguityManager.increaseAmbiguityCount();
-					} else {
-						n = newAmbiguities.get(0);
-					}
-					newKid = replaceUnderInjections(kid, injection, n);
-				} else {
-					// fishy: another filter might be borked
-					if (filterStrict) {
-						throw new FilterException(parser);
-					} else {
-						// TODO: log or whatever?
-								return t;
-					}
-				}
-			} else if (injection.isParseNode()) {
-				final int l1 = ((ParseNode) injection).getLabel();
-				if (hasGreaterPriority(l0, l1, kidnumber)) {
-					throw new FilterException(parser);
-				}
-			}
-
-			newKids.add(newKid);
-			kidnumber++;
-		}
-
-		// FIXME (KTK) get rid of toArray by precomputing the necessary size of newKids earlier in the method
-		return new ParseNode(t.getLabel(), newKids.toArray(new AbstractParseNode[newKids.size()]), AbstractParseNode.PARSENODE);
-	}
-
-	private AbstractParseNode replaceUnderInjections(AbstractParseNode alt, AbstractParseNode injection, AbstractParseNode n)
-			throws FilterException {
-		// SG_Replace_Under_Injections
-		// - not ok
-
-		throw new FilterException(parser, "replaceUnderInjections is not implemented", new NotImplementedException());
-		/*
-        if (ATisEqual(t, injT)) {
-           return newTree;
-        } else {
-          IStrategoList sons = (IStrategoList)ATgetArgument((ATerm) t, 1);
-          tree newSon = SG_Replace_Under_Injections((tree)ATgetFirst(sons),
-                                                    injT, newTree);
-          return ATsetArgument((ATermAppl)t, (ATerm)ATmakeList1((ATerm)newSon), 1);
-        }
-		 */
-	}
-
-	private AbstractParseNode jumpOverInjections(AbstractParseNode t) {
-
-		if(Tools.debugging) {
-			Tools.debug("jumpOverInjections() - ", t);
-		}
-
-		if (t.isParseNode()) {
-			int prod = ((ParseNode) t).getLabel();
-			ParseNode n = (ParseNode)t;
-			while (isUserDefinedLabel(prod)) {
-				final AbstractParseNode x = n.kids[0];
-				if(x.isParseNode()) {
-					n = (ParseNode)x;
-					prod = n.getLabel();
-				} else {
-					return x;
-				}
-			}
-		}
-
-		return t;
-	}
-
-	// TODO: shouldn't this be called isInjection?
-
-	private boolean isUserDefinedLabel(int prod) {
-		final Label l = parseTable.lookupInjection(prod);
-		if(l == null) {
-			return false;
-		}
-		return l.isInjection();
-	}
-
-	private boolean hasGreaterPriority(int l0, int l1, int arg) {
-		final List<Priority> prios = lookupGtrPriority(parseTable.getLabel(l0));
-
-		for (int i = 0, size = prios.size(); i < size; i++) {
-			final Priority p = prios.get(i);
-			if (l1 == p.right) {
-				if (p.arg == -1 || p.arg == arg) {
-					return true;
-				}
-			}
-		}
-		return false;
-	}
-
-	private List<Priority> lookupGtrPriority(Label prodLabel) {
-		return parseTable.getPriorities(prodLabel);
-	}
-
-	private AbstractParseNode applyLeftAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
-		// SG_Right_Associativity_Filter()
-
-		if(Tools.debugging) {
-			Tools.debug("applyLeftAssociativeFilter() - ", t);
-		}
-
-		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-		final AbstractParseNode[] kids = t.kids;
-		AbstractParseNode last = kids[kids.length - 1];
-
-		if (last.isAmbNode()) {
-
-			for (final AbstractParseNode amb : last.getChildren()) {
-				if (amb.isAmbNode()
-						|| !parseTable.getLabel(((ParseNode) amb).getLabel()).equals(prodLabel)) {
-					newAmbiguities.add(amb);
-				}
-			}
-
-			if (!newAmbiguities.isEmpty()) {
-				final AbstractParseNode[] rest = new AbstractParseNode[kids.length];
-				for(int i = 0; i < kids.length - 1; i++) {
-					rest[i] = kids[i];
-				}
-
-				
-				if (newAmbiguities.size() > 1) {
-					last = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
-					ambiguityManager.increaseAmbiguityCount();
-				} else {
-					last = newAmbiguities.get(0);
-				}
-				rest[rest.length - 1] = last;
-				ambiguityManager.increaseAmbiguityCount();
-				return new ParseNode(t.getLabel(), rest, AbstractParseNode.PARSENODE);
-			} else {
-				throw new FilterException(parser);
-			}
-		} else if (last.isParseNode()) {
-			final Label other = parseTable.getLabel(((ParseNode) last).getLabel());
-			if (prodLabel.equals(other)) {
-				throw new FilterException(parser);
-			}
-		}
-
-		return t;
-	}
-
-	private Label getProductionLabel(AbstractParseNode t) {
-		if (t.isParseNode()) {
-			return parseTable.getLabel(((ParseNode) t).getLabel());
-		} else if (t instanceof ParseProductionNode) {
-			return parseTable.getLabel(((ParseProductionNode) t).getProduction());
-		}
-		return null;
-	}
-
-	private boolean hasRejectProd(AbstractParseNode t) {
-		return t.isParseRejectNode();
-	}
-
-	private AbstractParseNode filterAmbiguities(AbstractParseNode[] ambs) throws FilterException {
-		// SG_FilterAmb
-
-		if(Tools.debugging) {
-			Tools.debug("filterAmbiguities() - [", ambs.length, "]");
-		}
-
-		List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
-
-		for (final AbstractParseNode amb : ambs) {
-			final AbstractParseNode newAmb = filterTree(amb, true);
-			if (newAmb != null && rejectedBranch == null) {
-				newAmbiguities.add(newAmb);
-			}
-			rejectedBranch = null;
-		}
-
-		if (newAmbiguities.size() > 1) {
-			/* Handle ambiguities inside this ambiguity cluster */
-			final List<AbstractParseNode> oldAmbiguities = new ArrayList<AbstractParseNode>(newAmbiguities);
-			for (final AbstractParseNode amb : oldAmbiguities) {
-				if (newAmbiguities.remove(amb)) {
-					newAmbiguities = filterAmbiguityList(newAmbiguities, amb);
-				}
-			}
-		}
-
-		if (newAmbiguities.isEmpty()) {
-			// All alternatives were rejected;
-			// the outer context should be rejected as well
-			return rejectedBranch = ParseNode.createAmbNode(ambs);
-		}
-
-		if (newAmbiguities.size() == 1) {
-			return newAmbiguities.get(0);
-		}
-
-		ambiguityManager.increaseAmbiguityCount();
-		return ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
-	}
-
-	private List<AbstractParseNode> filterAmbiguityList(List<AbstractParseNode> ambs, AbstractParseNode t) {
-		// SG_FilterAmbList
-
-		boolean keepT = true;
-		final List<AbstractParseNode> r = new ArrayList<AbstractParseNode>();
-
-		if (ambs.isEmpty()) {
-			r.add(t);
-			return r;
-		}
-
-		for (int i = 0, max = ambs.size(); i < max; i++) {
-			final AbstractParseNode amb = ambs.get(i);
-			switch (filter(t, amb)) {
-			case FILTER_DRAW:
-				r.add(amb);
-				break;
-			case FILTER_RIGHT_WINS:
-				r.add(amb);
-				keepT = false;
-			}
-		}
-
-		if (keepT) {
-			r.add(t);
-		}
-
-		return r;
-	}
-
-	private int filter(AbstractParseNode left, AbstractParseNode right) {
-		// SG_Filter(t0, t1)
-
-		if(Tools.debugging) {
-			Tools.debug("filter()");
-		}
-
-		if (left.equals(right)) {
-			return FILTER_LEFT_WINS;
-		}
-
-		/* UNDONE: direct eagerness filter seems to be disabled in reference SGLR
-        if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
-            int r = filterOnDirectPrefers(left, right);
-            if (r != FILTER_DRAW)
-                return r;
-        }
-		 */
-
-		// like C-SGLR, we use indirect preference filtering if the direct one is enabled
-		if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
-			final int r = filterOnIndirectPrefers(left, right);
-			if (r != FILTER_DRAW) {
-				return r;
-			}
-		}
-
-		if (filterPreferenceCount && parseTable.hasPrefersOrAvoids()) {
-			final int r = filterOnPreferCount(left, right);
-			if (r != FILTER_DRAW) {
-				return r;
-			}
-		}
-
-		if (filterInjectionCount) {
-			final int r = filterOnInjectionCount(left, right);
-			if (r != FILTER_DRAW) {
-				return r;
-			}
-		}
-
-		return filterPermissiveLiterals(left, right);
-	}
-
-	private int filterPermissiveLiterals(AbstractParseNode left, AbstractParseNode right) {
-		// Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive grammars introduce ambiguities for literals)
-
-		if (left.isParseNode() && right.isParseNode()) {
-			final AbstractParseNode[] leftKids = ((ParseNode) left).kids;
-			final AbstractParseNode[] rightKids = ((ParseNode) right).kids;
-			if (leftKids.length > 0 && rightKids.length == 1) {
-				if (leftKids[0] instanceof ParseProductionNode && rightKids[0].equals(left)) {
-					return FILTER_LEFT_WINS;
-				}
-			}
-		}
-		return FILTER_DRAW;
-	}
-
-	private int filterOnInjectionCount(AbstractParseNode left, AbstractParseNode right) {
-
-		if(Tools.debugging) {
-			Tools.debug("filterOnInjectionCount()");
-		}
-
-		ambiguityManager.increaseInjectionCount();
-
-		final int leftInjectionCount = countAllInjections(left);
-		final int rightInjectionCount = countAllInjections(right);
-
-		if (leftInjectionCount != rightInjectionCount) {
-			ambiguityManager.increaseInjectionFilterSucceededCount();
-		}
-
-		if (leftInjectionCount > rightInjectionCount) {
-			return FILTER_RIGHT_WINS;
-		} else if (rightInjectionCount > leftInjectionCount) {
-			return FILTER_LEFT_WINS;
-		}
-
-		return FILTER_DRAW;
-	}
-
-	private int countAllInjections(AbstractParseNode t) {
-		// SG_CountAllInjectionsInTree
-		// - ok
-		if (t.isAmbNode()) {
-			// Trick from forest.c
-			return t.getChildren().length == 0 ? 0 : countAllInjections(t.getChildren()[0]);
-		} else if (t.isParseNode()) {
-			final int c = getProductionLabel(t).isInjection() ? 1 : 0;
-			return c + countAllInjections(((ParseNode) t).kids);
-		}
-		return 0;
-	}
-
-	private int countAllInjections(AbstractParseNode[] ls) {
-		// SG_CountAllInjectionsInTree
-		// - ok
-		int r = 0;
-		for (int i = 0, max = ls.length; i < max; i++) {
-			r += countAllInjections(ls[i]);
-		}
-		return r;
-	}
-
-	private int filterOnPreferCount(AbstractParseNode left, AbstractParseNode right) {
-
-		if(Tools.debugging) {
-			Tools.debug("filterOnPreferCount()");
-		}
-
-		ambiguityManager.increaseEagernessFilterCalledCount();
-
-		int r = FILTER_DRAW;
-		if (parseTable.hasPrefers() || parseTable.hasAvoids()) {
-			final int leftPreferCount = countPrefers(left);
-			final int rightPreferCount = countPrefers(right);
-			final int leftAvoidCount = countAvoids(left);
-			final int rightAvoidCount = countAvoids(right);
-
-			if ((leftPreferCount > rightPreferCount && leftAvoidCount <= rightAvoidCount)
-					|| (leftPreferCount == rightPreferCount && leftAvoidCount < rightAvoidCount)) {
-				Tools.logger("Eagerness priority: ", left, " > ", right);
-				r = FILTER_LEFT_WINS;
-			}
-
-			if ((rightPreferCount > leftPreferCount && rightAvoidCount <= leftAvoidCount)
-					|| (rightPreferCount == leftPreferCount && rightAvoidCount < leftAvoidCount)) {
-				if (r != FILTER_DRAW) {
-					Tools.logger("Symmetric eagerness priority: ", left, " == ", right);
-					r = FILTER_DRAW;
-				} else {
-					Tools.logger("Eagerness priority: ", right, " > ", left);
-					r = FILTER_RIGHT_WINS;
-				}
-			}
-		}
-
-		if (r != FILTER_DRAW) {
-			ambiguityManager.increaseEagernessFilterSucceededCount();
-		}
-
-		return r;
-	}
-
-	private int countPrefers(AbstractParseNode t) {
-		// SG_CountPrefersInTree
-		// - ok
-		if (t.isAmbNode()) {
-			return countPrefers(t.getChildren());
-		} else if (t.isParseNode()) {
-			final int type = getProductionType(t);
-			if (type == ProductionType.PREFER) {
-				return 1;
-			} else if (type == ProductionType.AVOID) {
-				return 0;
-			}
-			return countPrefers(((ParseNode) t).kids);
-		}
-		return 0;
-	}
-
-	private int countPrefers(AbstractParseNode[] ls) {
-		// SG_CountPrefersInTree
-		// - ok
-		int r = 0;
-		for (final AbstractParseNode n : ls) {
-			r += countPrefers(n);
-		}
-		return r;
-	}
-
-	private int countAvoids(AbstractParseNode t) {
-		// SG_CountAvoidsInTree
-		// - ok
-		if (t.isAmbNode()) {
-			return countAvoids(t.getChildren());
-		} else if (t.isParseNode()) {
-			final int type = getProductionType(t);
-			if (type == ProductionType.PREFER) {
-				return 0;
-			} else if (type == ProductionType.AVOID) {
-				return 1;
-			}
-			return countAvoids(((ParseNode) t).kids);
-		}
-		return 0;
-	}
-
-	private int countAvoids(AbstractParseNode[] ls) {
-		// SG_CountAvoidsInTree
-		// - ok
-		int r = 0;
-		for (final AbstractParseNode n : ls) {
-			r += countAvoids(n);
-		}
-		return r;
-	}
-
-	private int filterOnIndirectPrefers(AbstractParseNode left, AbstractParseNode right) {
-		// SG_Indirect_Eagerness_Filter
-
-		if(Tools.debugging) {
-			Tools.debug("filterOnIndirectPrefers()");
-		}
-
-		if (left.isAmbNode() || right.isAmbNode()) {
-			return FILTER_DRAW;
-		}
-
-		if (!getLabel(left).equals(getLabel(right))) {
-			return filterOnDirectPrefers(left, right);
-		}
-
-		final ParseNode l = (ParseNode) left;
-		final ParseNode r = (ParseNode) right;
-
-		final AbstractParseNode[] leftArgs = l.kids;
-		final AbstractParseNode[] rightArgs = r.kids;
-
-		final int diffs = computeDistinctArguments(leftArgs, rightArgs);
-
-		if (diffs == 1) {
-			for (int i = 0; i < leftArgs.length; i++) {
-				final AbstractParseNode leftArg = leftArgs[i];
-				final AbstractParseNode rightArg = rightArgs[i];
-
-				if (!leftArg.equals(rightArg)) {
-					return filterOnIndirectPrefers(leftArg, rightArg);
-				}
-			}
-
-		}
-		return FILTER_DRAW;
-	}
-
-	private int filterOnDirectPrefers(AbstractParseNode left, AbstractParseNode right) {
-		// SG_Direct_Eagerness_Filter
-
-		if(Tools.debugging) {
-			Tools.debug("filterOnDirectPrefers()");
-		}
-
-		// TODO: optimize - move up the jumpOverInjectionsModuloEagerness calls
-		if (isLeftMoreEager(left, right)) {
-			return FILTER_LEFT_WINS;
-		}
-		if (isLeftMoreEager(right, left)) {
-			return FILTER_RIGHT_WINS;
-		}
-
-		return FILTER_DRAW;
-	}
-
-	private boolean isLeftMoreEager(AbstractParseNode left, AbstractParseNode right) {
-		assert !(left.isAmbNode() || right.isAmbNode());
-		if (isMoreEager(left, right)) {
-			return true;
-		}
-
-		final AbstractParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
-		final AbstractParseNode newRight = jumpOverInjectionsModuloEagerness(right);
-
-		if (newLeft.isParseNode() && newRight.isParseNode()) {
-			return isMoreEager(newLeft, newRight);
-		}
-
-		return false;
-	}
-
-	private AbstractParseNode jumpOverInjectionsModuloEagerness(AbstractParseNode t) {
-
-		if(Tools.debugging) {
-			Tools.debug("jumpOverInjectionsModuloEagerness()");
-		}
-
-		final int prodType = getProductionType(t);
-
-		if (t.isParseNode() && prodType != ProductionType.PREFER
-				&& prodType != ProductionType.AVOID) {
-
-			Label prod = getLabel(t);
-
-			while (prod.isInjection()) {
-				t = ((ParseNode) t).kids[0];
-
-
-				if (t.isParseNode()) {
-					final int prodTypeX = getProductionType(t);
-
-					if (prodTypeX != ProductionType.PREFER
-							&& prodTypeX != ProductionType.AVOID) {
-						prod = getLabel(t);
-						continue;
-					}
-				}
-				return t;
-			}
-		}
-		return t;
-	}
-
-	private Label getLabel(AbstractParseNode t) {
-		if (t.isParseNode()) {
-			final ParseNode n = (ParseNode) t;
-			return parseTable.getLabel(n.getLabel());
-		} else if (t instanceof ParseProductionNode) {
-			final ParseProductionNode n = (ParseProductionNode) t;
-			return parseTable.getLabel(n.prod);
-		}
-		return null;
-	}
-
-	private int getProductionType(AbstractParseNode t) {
-		return getLabel(t).getAttributes().getType();
-	}
-
-	private boolean isMoreEager(AbstractParseNode left, AbstractParseNode right) {
-		final int leftLabel = ((ParseNode) left).getLabel();
-		final int rightLabel = ((ParseNode) right).getLabel();
-
-		final Label leftProd = parseTable.getLabel(leftLabel);
-		final Label rightProd = parseTable.getLabel(rightLabel);
-
-		if (leftProd.isMoreEager(rightProd)) {
-			return true;
-		}
-
-		return false;
-	}
-
-	private int computeDistinctArguments(AbstractParseNode[] leftArgs, AbstractParseNode[] rightArgs) {
-		// countDistinctArguments
-		int r = 0;
-		for (int i = 0; i < leftArgs.length; i++) {
-			if (!leftArgs[i].equals(rightArgs[i])) {
-				r++;
-			}
-		}
-		return r;
-	}
-
-	private boolean isCyclicTerm(AbstractParseNode t) {
-
-		ambiguityManager.dumpIndexTable();
-
-		final List<AbstractParseNode> cycles = computeCyclicTerm(t);
-
-		return cycles != null && cycles.size() > 0;
-	}
-
-	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t) {
-		// FIXME rewrite to use HashMap and object id
-		final PositionMap visited = new PositionMap(ambiguityManager.getMaxNumberOfAmbiguities());
-
-		ambiguityManager.resetAmbiguityCount();
-
-		return computeCyclicTerm(t, false, visited);
-	}
-
-	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t, boolean inAmbiguityCluster,
-			PositionMap visited) {
-
-		if (Tools.debugging) {
-			Tools.debug("computeCyclicTerm() - ", t);
-		}
-
-		if (t instanceof ParseProductionNode) {
-			if (Tools.debugging) {
-				Tools.debug(" bumping");
-			}
-			return null;
-		} else if (t.isParseNode()) {
-			//Amb ambiguities = null;
-			List<AbstractParseNode> cycle = null;
-			//int clusterIndex;
-			final ParseNode n = (ParseNode) t;
-
-			if (inAmbiguityCluster) {
-				cycle = computeCyclicTerm(n.kids, false, visited);
-			} else {
-				/*
-                if (ambiguityManager.isInputAmbiguousAt(parseTreePosition)) {
-                    ambiguityManager.increaseAmbiguityCount();
-                    clusterIndex = ambiguityManager.getClusterIndex(t, parseTreePosition);
-                    if (SGLR.isDebugging()) {
-                        Tools.debug(" - clusterIndex : ", clusterIndex);
-                    }
-                    if (markMap.isMarked(clusterIndex)) {
-                        return new ArrayList<IParseNode>();
-                    }
-                    ambiguities = ambiguityManager.getClusterOnIndex(clusterIndex);
-                } else {
-                    clusterIndex = -1;
-                }*/
-
-				throw new NotImplementedException();
-				/*
-                if (ambiguities == null) {
-                    cycle = computeCyclicTerm(((ParseNode) t).getKids(), false, visited);
-                } else {
-                    int length = visited.getValue(clusterIndex);
-                    int savePos = parseTreePosition;
-
-                    if (length == -1) {
-                        //markMap.mark(clusterIndex);
-                        cycle = computeCyclicTermInAmbiguityCluster(ambiguities, visited);
-                        visited.put(clusterIndex, parseTreePosition - savePos);
-                        //markMap.unmark(clusterIndex);
-                    } else {
-                        parseTreePosition += length;
-                    }
-                }
-				 */
-			}
-			return cycle;
-		} else {
-			throw new FatalException();
-		}
-	}
-
-	/*
-    private List<IParseNode> computeCyclicTermInAmbiguityCluster(Amb ambiguities,
-            PositionMap visited) {
-
-
-        List<IParseNode> ambs = ambiguities.getAlternatives();
-        for (int i = 0, max = ambs.size(); i < max; i++) {
-            IParseNode amb = ambs.get(i);
-            List<IParseNode> cycle = computeCyclicTerm(amb, true, visited);
-            if (cycle != null)
-                return cycle;
+  private boolean filterCycles;
+
+  private boolean filterDirectPreference;
+
+  private boolean filterPreferenceCount;
+
+  private boolean filterInjectionCount;
+
+  private boolean filterLongestMatch;
+
+  private boolean filterTopSort;
+
+  private boolean filterReject;
+
+  private boolean filterAssociativity;
+
+  private boolean filterPriorities;
+
+  private boolean filterStrict;
+
+  private boolean logStatistics;
+
+  private boolean ambiguityIsError;
+
+  private int ambiguityCount;
+  private int newAmbiguityCount;
+
+  // Current parser state
+
+  private AmbiguityManager ambiguityManager;
+
+  private SGLR parser;
+
+  private ParseTable parseTable;
+
+  private ProductionAttributeReader prodReader;
+
+  private LayoutFilter layoutFilter;
+  private int layoutFiltering;
+  
+  // private Map<AmbKey, IParseNode> resolvedTable = new HashMap<AmbKey,
+  // IParseNode>();
+
+  /**
+   * Sets whether any filter should be applied at all (excluding the top sort
+   * filter).
+   */
+  public final void setFilterAny(boolean filterAny) {
+    this.filterAny = filterAny;
+  }
+
+  public final void setFilterDirectPreference(boolean filterDirectPreference) {
+    this.filterDirectPreference = filterDirectPreference;
+  }
+
+  public boolean getFilterDirectPreference() {
+    return filterDirectPreference;
+  }
+
+  /**
+   * For preference count filtering, see
+   * {@link #setFilterPreferenceCount(boolean)}.
+   */
+  @Deprecated
+  public final void setFilterIndirectPreference(boolean filterIndirectPreference) {
+    throw new UnsupportedOperationException();
+  }
+
+  /**
+   * For preference count filtering, see {@link #getFilterPreferenceCount()}.
+   */
+  @Deprecated
+  public boolean getFilterIndirectPreference() {
+    throw new UnsupportedOperationException();
+  }
+
+  public final void setFilterInjectionCount(boolean filterInjectionCount) {
+    this.filterInjectionCount = filterInjectionCount;
+  }
+
+  public boolean getFilterInjectionCount() {
+    return filterInjectionCount;
+  }
+
+  public final void setFilterLongestMatch(boolean filterLongestMatch) {
+    this.filterLongestMatch = filterLongestMatch;
+  }
+
+  public boolean getLongestMatch() {
+    return filterLongestMatch;
+  }
+
+  public final void setFilterPreferenceCount(boolean filterPreferenceCount) {
+    this.filterPreferenceCount = filterPreferenceCount;
+  }
+
+  public boolean getFilterPreferenceCount() {
+    return filterPreferenceCount;
+  }
+
+  public final void setFilterTopSort(boolean filterTopSort) {
+    this.filterTopSort = filterTopSort;
+  }
+
+  public boolean getFilterTopSort() {
+    return filterTopSort;
+  }
+
+  public void setFilterCycles(boolean filterCycles) {
+    this.filterCycles = filterCycles;
+  }
+
+  public boolean isFilterCycles() {
+    return filterCycles;
+  }
+
+  public void setFilterAssociativity(boolean filterAssociativity) {
+    this.filterAssociativity = filterAssociativity;
+  }
+
+  public boolean getFilterAssociativity() {
+    return filterAssociativity;
+  }
+
+  public void setFilterPriorities(boolean filterPriorities) {
+    this.filterPriorities = filterPriorities;
+  }
+
+  public boolean getFilterPriorities() {
+    return filterPriorities;
+  }
+
+  /**
+   * Sets whether to enable strict filtering, triggering a FilterException when
+   * the priorities filter encounters an unfiltered ambiguity.
+   */
+  public void setFilterStrict(boolean filterStrict) {
+    this.filterStrict = filterStrict;
+  }
+
+  public boolean getFilterStrict() {
+    return filterStrict;
+  }
+
+  public final void setHeuristicFilters(boolean heuristicFilters) {
+    setFilterPreferenceCount(heuristicFilters);
+    setFilterInjectionCount(heuristicFilters);
+  }
+
+  public void setFilterReject(boolean filterReject) {
+    this.filterReject = filterReject;
+  }
+
+  public boolean getFilterReject() {
+    return filterReject;
+  }
+
+  public void setLogStatistics(boolean logStatistics) {
+    this.logStatistics = logStatistics;
+  }
+
+  public boolean getLogStatistics() {
+    return logStatistics;
+  }
+
+  public void setAmbiguityIsError(boolean ambiguityIsError) {
+    this.ambiguityIsError = ambiguityIsError;
+  }
+
+  public boolean getAmbiguityIsError() {
+    return ambiguityIsError;
+  }
+
+  public int getAmbiguityCount() {
+    return newAmbiguityCount;
+  }
+  
+  public int getLayoutFilteringCount() {
+    return layoutFiltering;
+  }
+
+  public int getLayoutFilterCallCount() {
+    return layoutFilter == null ? 0 : layoutFilter.getFilterCallCount();
+  }
+
+  public final void setDefaultFilters() {
+    filterAny = true;
+    filterCycles = false; // TODO: filterCycles; enable by default
+    filterDirectPreference = true;
+    filterPreferenceCount = false;
+    filterInjectionCount = false;
+    filterLongestMatch = true;
+    filterTopSort = true;
+    filterReject = true;
+    filterAssociativity = true;
+    filterPriorities = true;
+    filterStrict = false; // TODO: disable filterStrict hack
+    logStatistics = true;
+    ambiguityIsError = false;
+  }
+
+  public Disambiguator() {
+    setDefaultFilters();
+  }
+
+  public Object applyFilters(SGLR parser, AbstractParseNode root, String sort,
+      int inputLength) throws SGLRException, FilterException, InterruptedException {
+    AbstractParseNode t = root;
+    if (Tools.debugging) {
+      Tools.debug("applyFilters()");
+    }
+
+    try {
+      try {
+        if (Tools.debugging) {
+          Tools.debug("applyFilters()");
+        }
+
+        initializeFromParser(parser);
+        t = applyTopSortFilter(sort, t);
+
+        if (filterAny) {
+          t = applyCycleDetectFilter(t);
+
+          // SG_FilterTree
+          ambiguityManager.resetClustersVisitedCount();
+          t = filterTree(t);
         }
+
+        if (t == null)
+          return null;
+      } catch (RuntimeException e) {
+        throw new FilterException(parser,
+            "Runtime exception when applying filters", e);
+      }
+      
+      newAmbiguityCount = t.getAmbiguityCount();
+
+      return yieldTreeTop(t);
+
+    } finally {
+//      System.out.println("  layout filter calls at parse time: " + parser.getLayoutFilterCallCount());
+//      System.out.println("  illegal layout filtered at parse time: " + parser.getLayoutFilteringCount());
+//      System.out.println("  layout filter calls at disambiguation time: " + getLayoutFilterCallCount());
+//      System.out.println("  illegal layout filtered at disambiguation time: " + getLayoutFilteringCount());
+//      System.out.println("  enforced newline skips: " + parser.getEnforcedNewlineSkips());
+//      initializeFromParser(null);
+    }
+  }
+
+  public void initializeFromParser(SGLR parser) {
+    if (parser == null) {
+      this.parser = null;
+      parseTable = null;
+      ambiguityCount += ambiguityManager == null ? 0 : ambiguityManager.getAmbiguitiesCount();
+      ambiguityManager = null;
+      layoutFilter = null;
+    } else {
+      this.parser = parser;
+      parseTable = parser.getParseTable();
+      prodReader = new ProductionAttributeReader(parseTable.getFactory());
+      ambiguityManager = parser.getAmbiguityManager();
+      ambiguityCount = 0;
+      layoutFilter = new LayoutFilter(parseTable, false);
+      layoutFiltering = 0;
+    }
+  }
+
+  private void logStatus() {
+    Tools.logger("Number of rejects: ", parser.getRejectCount());
+    Tools.logger("Number of reductions: ", parser.getReductionCount());
+    Tools.logger("Number of ambiguities: ",
+        ambiguityManager.getMaxNumberOfAmbiguities());
+    Tools.logger("Number of calls to Amb: ",
+        ambiguityManager.getAmbiguityCallsCount());
+    Tools.logger("Count Eagerness Comparisons: ",
+        ambiguityManager.getEagernessComparisonCount(), " / ",
+        ambiguityManager.getEagernessSucceededCount());
+    Tools.logger("Number of Injection Counts: ",
+        ambiguityManager.getInjectionCount());
+  }
+
+  private Object yieldTree(AbstractParseNode t) {
+    parser.getTreeBuilder().reset(); // in case yieldTree is used for debugging
+    return parser.getTreeBuilder().buildTree(t);
+  }
+
+  private Object yieldTreeTop(AbstractParseNode t) throws SGLRException {
+    int ambCount = ambiguityManager.getAmbiguitiesCount();
+
+    if (Tools.debugging) {
+      Tools.debug("convertToATerm: ", t);
+    }
+
+    try {
+      ambiguityCount += ambiguityManager.getAmbiguitiesCount();
+      ambiguityManager.resetAmbiguityCount();
+      final Object r = yieldTree(t);
+
+      if (logStatistics)
+        logStatus();
+
+      if (Tools.debugging) {
+        Tools.debug("yield: ", r);
+      }
+
+      if (ambiguityIsError && ambCount > 0) {
+        throw new SGLRException(parser, "Ambiguities found");
+      } else {
+        return parser.getTreeBuilder().buildTreeTop(r, ambCount);
+      }
+    } finally {
+      parser.getTreeBuilder().reset();
+    }
+  }
+
+  private AbstractParseNode applyCycleDetectFilter(AbstractParseNode t)
+      throws FilterException {
+
+    if (Tools.debugging) {
+      Tools.debug("applyCycleDetectFilter() - ", t);
+    }
+
+    if (filterCycles) {
+      if (ambiguityManager.getMaxNumberOfAmbiguities() > 0) {
+        if (isCyclicTerm(t)) {
+          throw new FilterException(parser, "Term is cyclic");
+        }
+      }
+    }
+
+    return t;
+  }
+
+  private IStrategoTerm getProduction(AbstractParseNode t) {
+    if (t.isParseNode()) {
+      return parseTable.getProduction(((ParseNode) t).getLabel());
+    } else {
+      return parseTable.getProduction(((ParseProductionNode) t).getLabel());
+    }
+  }
+
+  private AbstractParseNode applyTopSortFilter(String sort, AbstractParseNode t)
+      throws SGLRException {
+
+    if (Tools.debugging) {
+      Tools.debug("applyTopSortFilter() - ", t);
+    }
+
+    if (sort != null && filterTopSort) {
+      t = selectOnTopSort(t, sort);
+      if (t == null) {
+        throw new StartSymbolException(parser,
+            "Desired start symbol not found: " + sort);
+      }
+    }
+
+    return t;
+  }
+
+  private boolean matchProdOnTopSort(IStrategoTerm prod, String sort)
+      throws FilterException {
+    assert sort != null;
+    /*
+     * sort = sort.replaceAll("\"", ""); return
+     * prod.match("prod([cf(opt(layout)),cf(sort(\"" + sort +
+     * "\")),cf(opt(layout))], sort(\"<START>\"),no-attrs)") != null ||
+     * prod.match("prod([cf(sort(\"" + sort +
+     * "\"))], sort(\"<START>\"),no-attrs)") != null ||
+     * prod.match("prod([lex(sort(\"" + sort +
+     * "\"))], sort(\"<START>\"),no-attrs)") != null ||
+     * prod.match("prod([sort(\"" + sort + "\")], sort(\"<START>\"),no-attrs)")
+     * != null;
+     */
+    IStrategoList lhs = termAt(prod, 0);
+    IStrategoAppl rhs = termAt(prod, 1);
+    String foundSort = prodReader.tryGetFirstSort(lhs);
+    assert foundSort != null;
+    assert "<START>".equals(prodReader.tryGetSort(rhs));
+    return sort.equals(foundSort);
+  }
+
+  private AbstractParseNode selectOnTopSort(AbstractParseNode t, String sort)
+      throws FilterException {
+    final List<AbstractParseNode> results = new ArrayList<AbstractParseNode>();
+
+    if (t.isAmbNode()) {
+      addTopSortAlternatives(t, sort, results);
+
+      switch (results.size()) {
+      case 0:
         return null;
+      case 1:
+        return results.get(0);
+      default:
+        ambiguityManager.increaseAmbiguityCount();
+        return ParseNode.createAmbNode(results.toArray(new AbstractParseNode[results.size()]));
+      }
+    } else {
+      final IStrategoTerm prod = getProduction(t);
+      return matchProdOnTopSort(prod, sort) ? t : null;
+    }
+  }
+
+  private void addTopSortAlternatives(AbstractParseNode t, String sort,
+      List<AbstractParseNode> results) throws FilterException {
+    for (final AbstractParseNode amb : t.getChildren()) {
+      if (amb.isAmbNode()) {
+        addTopSortAlternatives(amb, sort, results);
+      } else {
+        final IStrategoTerm prod = getProduction(amb);
+        if (matchProdOnTopSort(prod, sort)) {
+          results.add(amb);
+        }
+      }
+    }
+  }
+
+  /**
+   * @param inAmbiguityCluster
+   *          We're inside an amb and can return null to reject this branch.
+   * @throws InterruptedException 
+   */
+  public AbstractParseNode filterTree(AbstractParseNode node) throws FilterException, InterruptedException {
+    // SG_FilterTreeRecursive
+    if (Tools.debugging) {
+      Tools.debug("filterTree(node)    - ", node);
+    }
+    
+    LinkedList<AbstractParseNode> input= new LinkedList<AbstractParseNode>();
+    LinkedList<AbstractParseNode> output = new LinkedList<AbstractParseNode>();
+    LinkedList<AbstractParseNode> pending = new LinkedList<AbstractParseNode>();
+
+    input.push(node);
+
+    while (!input.isEmpty() || !pending.isEmpty()) {
+      if (Thread.currentThread().isInterrupted())
+        throw new InterruptedException();
+      
+      int pendingPeekPos = pending.isEmpty() ? -1 : output.size() - pending.peek().getChildren().length - 1;
+      if (!pending.isEmpty() && pendingPeekPos >= 0 && output.get(output.size() - pendingPeekPos - 1) == pending.peek()) {
+        AbstractParseNode t = pending.pop();
+        
+        AbstractParseNode[] args = new AbstractParseNode[t.getChildren().length];
+        boolean changed = false;
+        
+        boolean rejected = false;
+        for (int i = t.getChildren().length - 1; i >= 0; i--) {
+          args[i] = output.pop();
+          rejected = rejected || args[i] == null;
+          changed = changed || args[i] != t.getChildren()[i];
+        }
+        
+        output.pop();
+        
+        
+        if (!rejected && changed)
+          t = new ParseNode(t.getLabel(), 
+                            args, 
+                            t.getNodeType(),
+                            t.getLine(),
+                            t.getColumn(),
+                            t.isLayout(),
+                            t.isIgnoreLayout());
+        
+        if (!rejected) 
+          if (LAYOUT_FITERING) {
+            if (!layoutFilter.hasValidLayout((ParseNode) t)) {
+              layoutFiltering++;
+              rejected = true;
+            }
+            else
+              layoutFiltering += layoutFilter.getDisambiguationCount();
+  
+            ambiguityManager.decreaseAmbiguityCount(layoutFilter.getDisambiguationCount());
+          }
+        
+        if (rejected)
+          return null;
+        
+        output.push(t);
+      }
+      else {
+        AbstractParseNode t = input.pop();
+      
+        switch (t.getNodeType()) {
+        case AMBIGUITY:
+          if (!output.isEmpty()) {
+            // (some cycle stuff should be done here)
+            t = filterAmbiguities(t.getChildren());
+            if (t == null)
+              return null;
+            output.push(t);
+          } 
+          // FIXME: hasRejectProd(Amb) can never succeed?
+          else if (filterReject && t.isParseRejectNode())
+              output.push(t);
+          else
+            output.push(filterAmbiguities(t.getChildren()));
+        
+          break;
+
+        case PARSENODE:
+        case AVOID:
+        case PREFER:
+        case REJECT:
+
+          boolean rejected = false;
+          
+          if (!rejected && filterReject && t.isParseRejectNode()) {
+            rejected = true;
+          }
+          
+          if (LAYOUT_FITERING) {
+            if (!layoutFilter.hasValidLayout((ParseNode) t)) {
+              layoutFiltering++;
+              rejected = true;
+            }
+            else
+              layoutFiltering += layoutFilter.getDisambiguationCount();
+          }
+          
+          if (!rejected) {
+            t = applyAssociativityPriorityFilter(t);
+            rejected = t == null;
+          }
+          
+          if (rejected)
+            return null;
+          else {
+            output.push(t);
+            if (t.getChildren().length > 0 && !t.isParseProductionChain()) {
+              pending.push(t);
+              for (int i = t.getChildren().length - 1; i >= 0; i--)
+                input.push(t.getChildren()[i]);
+            }
+          }
+          break;
+        case PARSE_PRODUCTION_NODE:
+          // leaf node -- do nothing (cannot be any ambiguities here)
+          output.push(t);
+          break;
+        case CYCLE:
+          output.push(t);
+          break;
+        default:
+          throw new IllegalStateException("Unknown node type: " + t);
+        }
+      }
+    }
+    
+    assert output.size() == 1;
+    return output.peek();
+  }
+
+  private AbstractParseNode applyAssociativityPriorityFilter(AbstractParseNode t) {
+    // SG_Associativity_Priority_Filter(pt, t)
+    // - ok
+
+    if (Tools.debugging) {
+      Tools.debug("applyAssociativityPriorityFilter() - ", t);
+    }
+
+    if (t.isParseNode()) {
+      final ParseNode n = (ParseNode) t;
+      final Label prodLabel = parseTable.getLabel(n.getLabel());
+
+      if (filterAssociativity) {
+        if (prodLabel.isLeftAssociative()) {
+          t = applyLeftAssociativeFilter(n, prodLabel);
+        } else if (prodLabel.isRightAssociative()) {
+          t = applyRightAssociativeFilter(n, prodLabel);
+        }
+
+      }
+
+      if (filterPriorities && parseTable.hasPriorities()) {
+        if (Tools.debugging) {
+          Tools.debug(" - about to look up : ", prodLabel.labelNumber);
+        }
+
+        if (!lookupGtrPriority(prodLabel).isEmpty()) {
+          if (Tools.debugging) {
+            Tools.debug(" - found");
+          }
+          return applyPriorityFilter(n, prodLabel);
+        }
+        if (Tools.debugging) {
+          Tools.debug(" - not found");
+        }
+      }
+    }
+
+    return t;
+  }
+
+  private AbstractParseNode applyRightAssociativeFilter(ParseNode t,
+      Label prodLabel) {
+    // SG_Right_Associativity_Filter(t, prodl)
+    // - almost ok
+
+    if (Tools.debugging) {
+      Tools.debug("applyRightAssociativeFilter() - ", t);
+    }
+
+    final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+    final AbstractParseNode[] kids = t.getChildren();
+    final AbstractParseNode firstKid = kids[0];
+
+    if (firstKid.isAmbNode()) {
+
+      for (final AbstractParseNode amb : firstKid.getChildren()) {
+        if (((ParseNode) amb).getLabel() != prodLabel.labelNumber) {
+          newAmbiguities.add(amb);
+        }
+      }
+
+      final int additionalAmbNodes = newAmbiguities.isEmpty() ? 0 : 1;
+      final AbstractParseNode[] restKids = new AbstractParseNode[kids.length
+          - 1 + additionalAmbNodes];
+      System.arraycopy(kids, 1, restKids, 0, kids.length - 1);
+
+      // FIXME is this correct?
+      assert !newAmbiguities.isEmpty();
+      AbstractParseNode extraAmb;
+      if (newAmbiguities.size() > 1) {
+        extraAmb = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
+        ambiguityManager.increaseAmbiguityCount();
+      } else {
+        extraAmb = newAmbiguities.get(0);
+      }
+      restKids[restKids.length - 1] = extraAmb;
+    
+      // FIXME is this correct?
+      return new ParseNode(t.getLabel(), restKids, AbstractParseNode.PARSENODE, t.getLine(), t.getColumn(), t.isLayout(), t.isIgnoreLayout());
+
+    } else if (firstKid.isParseNode()) {
+      assert ((ParseNode) firstKid).getLabel() != prodLabel.labelNumber;
+    }
+    return t;
+  }
+
+  private AbstractParseNode applyPriorityFilter(ParseNode t, Label prodLabel) {
+    // SG_Priority_Filter
+
+    if (Tools.debugging) {
+      Tools.debug("applyPriorityFilter() - ", t);
+    }
+
+    final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+    final List<AbstractParseNode> newKids = new ArrayList<AbstractParseNode>();
+
+    final int l0 = prodLabel.labelNumber;
+    int kidnumber = 0;
+
+    for (final AbstractParseNode kid : t.getChildren()) {
+      AbstractParseNode newKid = kid;
+      final AbstractParseNode injection = jumpOverInjections(kid);
+
+      if (injection.isAmbNode()) {
+        newAmbiguities.clear();
+        for (final AbstractParseNode amb : injection.getChildren()) {
+          final AbstractParseNode injAmb = jumpOverInjections(amb);
+
+          if (injAmb.isParseNode()) {
+            final Label label = getProductionLabel(t);
+            if (hasGreaterPriority(l0, label.labelNumber, kidnumber)) {
+              newAmbiguities.add(amb);
+            }
+          }
+        }
+
+        if (!newAmbiguities.isEmpty()) {
+          AbstractParseNode n = null;
+          if (newAmbiguities.size() > 1) {
+            n = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
+            ambiguityManager.increaseAmbiguityCount();
+          } else {
+            n = newAmbiguities.get(0);
+          }
+          newKid = replaceUnderInjections(kid, injection, n);
+        } else {
+          // fishy: another filter might be borked
+          assert !filterStrict;
+          // TODO: log or whatever?
+          return t;
+        }
+      } else if (injection.isParseNode()) {
+        final int l1 = ((ParseNode) injection).getLabel();
+        assert !hasGreaterPriority(l0, l1, kidnumber);
+      }
+
+      newKids.add(newKid);
+      kidnumber++;
+    }
+
+    // FIXME (KTK) get rid of toArray by precomputing the necessary size of
+    // newKids earlier in the method
+    return new ParseNode(t.getLabel(),
+        newKids.toArray(new AbstractParseNode[newKids.size()]), AbstractParseNode.PARSENODE, t.getLine(), t.getColumn(), t.isLayout(), t.isIgnoreLayout());
+  }
+
+  private AbstractParseNode replaceUnderInjections(AbstractParseNode alt,
+      AbstractParseNode injection, AbstractParseNode n)  {
+    // SG_Replace_Under_Injections
+    // - not ok
+
+    assert false;
+    return null;
+    
+//    throw new FilterException(parser,
+//        "replaceUnderInjections is not implemented",
+//        new NotImplementedException());
+    /*
+     * if (ATisEqual(t, injT)) { return newTree; } else { IStrategoList sons =
+     * (IStrategoList)ATgetArgument((ATerm) t, 1); tree newSon =
+     * SG_Replace_Under_Injections((tree)ATgetFirst(sons), injT, newTree);
+     * return ATsetArgument((ATermAppl)t, (ATerm)ATmakeList1((ATerm)newSon), 1);
+     * }
+     */
+  }
+
+  private AbstractParseNode jumpOverInjections(AbstractParseNode t) {
+
+    if (Tools.debugging) {
+      Tools.debug("jumpOverInjections() - ", t);
+    }
+
+    if (t.isParseNode()) {
+      int prod = ((ParseNode) t).getLabel();
+      ParseNode n = (ParseNode) t;
+      while (isUserDefinedLabel(prod)) {
+        final AbstractParseNode x = n.kids[0];
+        if (x.isParseNode()) {
+          n = (ParseNode) x;
+          prod = n.getLabel();
+        } else {
+          return x;
+        }
+      }
+    }
+
+    return t;
+  }
+
+  // TODO: shouldn't this be called isInjection?
+
+  private boolean isUserDefinedLabel(int prod) {
+    final Label l = parseTable.lookupInjection(prod);
+    if (l == null) {
+      return false;
+    }
+    return l.isInjection();
+  }
+
+  private boolean hasGreaterPriority(int l0, int l1, int arg) {
+    final List<Priority> prios = lookupGtrPriority(parseTable.getLabel(l0));
+
+    for (int i = 0, size = prios.size(); i < size; i++) {
+      final Priority p = prios.get(i);
+      if (l1 == p.right) {
+        if (p.arg == -1 || p.arg == arg) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  private List<Priority> lookupGtrPriority(Label prodLabel) {
+    return parseTable.getPriorities(prodLabel);
+  }
+
+  private AbstractParseNode applyLeftAssociativeFilter(ParseNode t,
+      Label prodLabel) {
+    // SG_Right_Associativity_Filter()
+
+    if (Tools.debugging) {
+      Tools.debug("applyLeftAssociativeFilter() - ", t);
+    }
+
+    final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
+    final AbstractParseNode[] kids = t.kids;
+    AbstractParseNode last = kids[kids.length - 1];
+
+    if (last.isAmbNode()) {
+
+      for (final AbstractParseNode amb : last.getChildren()) {
+        if (amb.isAmbNode()
+            || !parseTable.getLabel(((ParseNode) amb).getLabel()).equals(
+                prodLabel)) {
+          newAmbiguities.add(amb);
+        }
+      }
+
+      assert !newAmbiguities.isEmpty();
+      final AbstractParseNode[] rest = new AbstractParseNode[kids.length];
+      for (int i = 0; i < kids.length - 1; i++) {
+        rest[i] = kids[i];
+      }
+
+      if (newAmbiguities.size() > 1) {
+        last = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
+        ambiguityManager.increaseAmbiguityCount();
+      } else {
+        last = newAmbiguities.get(0);
+      }
+      rest[rest.length - 1] = last;
+      ambiguityManager.increaseAmbiguityCount();
+      return new ParseNode(t.getLabel(), rest, AbstractParseNode.PARSENODE, t.getLine(), t.getColumn(), t.isLayout(), t.isIgnoreLayout());
+    } 
+    else if (last.isParseNode()) {
+      final Label other = parseTable.getLabel(((ParseNode) last).getLabel());
+      assert !prodLabel.equals(other);
+    }
+
+    return t;
+  }
+
+  private Label getProductionLabel(AbstractParseNode t) {
+    if (t.isParseNode()) {
+      return parseTable.getLabel(((ParseNode) t).getLabel());
+    } else if (t instanceof ParseProductionNode) {
+      return parseTable.getLabel(((ParseProductionNode) t).getLabel());
+    }
+    return null;
+  }
+
+  private AbstractParseNode filterAmbiguities(AbstractParseNode[] ambs) throws FilterException, InterruptedException {
+    if (ambs.length == 0)
+      return null;
+    AbstractParseNode current = ambs[0];
+    for (int i = 1; i < ambs.length; i++)
+      current = filterAmbiguities(current, ambs[i]);
+    
+    return current;
+  }
+  
+  private AbstractParseNode filterAmbiguities(AbstractParseNode amb1, AbstractParseNode amb2)
+      throws FilterException, InterruptedException {
+    // SG_FilterAmb
+
+    if (Tools.debugging) {
+      Tools.debug("filterAmbiguities() - [", 2, "]");
+    }
+
+    amb1 = filterTree(amb1);
+    amb2 = filterTree(amb2);
+    
+    if (amb1 == null)
+      return amb2;
+    if (amb2 == null)
+      return amb1;
+    
+    switch (filter(amb1, amb2)) {
+    case FILTER_DRAW:
+      ambiguityManager.increaseAmbiguityCount();
+      return ParseNode.createAmbNode(amb1, amb2);
+    case FILTER_LEFT_WINS:
+      return amb1;
+    case FILTER_RIGHT_WINS:
+      return amb2;
+    default:
+      return null;
+    }
+  }
+
+  private int filter(AbstractParseNode left, AbstractParseNode right) {
+    // SG_Filter(t0, t1)
+
+    if (Tools.debugging) {
+      Tools.debug("filter()");
+    }
+
+    if (left.equals(right)) {
+      return FILTER_LEFT_WINS;
+    }
+
+    /*
+     * UNDONE: direct eagerness filter seems to be disabled in reference SGLR if
+     * (filterDirectPreference && parseTable.hasPrefersOrAvoids()) { int r =
+     * filterOnDirectPrefers(left, right); if (r != FILTER_DRAW) return r; }
+     */
+
+    // like C-SGLR, we use indirect preference filtering if the direct one is
+    // enabled
+    if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
+      final int r = filterOnIndirectPrefers(left, right);
+      if (r != FILTER_DRAW) {
+        return r;
+      }
+    }
+
+    if (filterPreferenceCount && parseTable.hasPrefersOrAvoids()) {
+      final int r = filterOnPreferCount(left, right);
+      if (r != FILTER_DRAW) {
+        return r;
+      }
+    }
+
+    if (filterInjectionCount) {
+      final int r = filterOnInjectionCount(left, right);
+      if (r != FILTER_DRAW) {
+        return r;
+      }
+    }
+    
+    if (filterLongestMatch) {
+      final int r = filterLongestMatch(left, right);
+      if (r != FILTER_DRAW) {
+        return r;
+      }
+    }
+    
+    return filterPermissiveLiterals(left, right);
+  }
+
+  private int filterPermissiveLiterals(AbstractParseNode left,
+      AbstractParseNode right) {
+    // Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive
+    // grammars introduce ambiguities for literals)
+
+    if (left.isParseNode() && right.isParseNode()) {
+      final AbstractParseNode[] leftKids = ((ParseNode) left).kids;
+      final AbstractParseNode[] rightKids = ((ParseNode) right).kids;
+      if (leftKids.length > 0 && rightKids.length == 1) {
+        if (leftKids[0].isParseProductionNode()
+            && rightKids[0].equals(left)) {
+          return FILTER_LEFT_WINS;
+        }
+      }
+      if (rightKids.length > 0 && leftKids.length == 1) {
+        if (rightKids[0].isParseProductionNode()
+            && leftKids[0].equals(right)) {
+          return FILTER_RIGHT_WINS;
+        }
+      }
+    }
+    return FILTER_DRAW;
+  }
+
+  private int filterOnInjectionCount(AbstractParseNode left,
+      AbstractParseNode right) {
+
+    if (Tools.debugging) {
+      Tools.debug("filterOnInjectionCount()");
+    }
+
+    ambiguityManager.increaseInjectionCount();
+
+    final int leftInjectionCount = countAllInjections(left);
+    final int rightInjectionCount = countAllInjections(right);
+
+    if (leftInjectionCount != rightInjectionCount) {
+      ambiguityManager.increaseInjectionFilterSucceededCount();
+    }
+
+    if (leftInjectionCount > rightInjectionCount) {
+      return FILTER_RIGHT_WINS;
+    } else if (rightInjectionCount > leftInjectionCount) {
+      return FILTER_LEFT_WINS;
+    }
+
+    return FILTER_DRAW;
+  }
+
+  private int countAllInjections(AbstractParseNode t) {
+    // SG_CountAllInjectionsInTree
+    // - ok
+    if (t.isAmbNode()) {
+      // Trick from forest.c
+      return t.getChildren().length == 0 ? 0 : countAllInjections(t
+          .getChildren()[0]);
+    } else if (t.isParseNode()) {
+      final int c = getProductionLabel(t).isInjection() ? 1 : 0;
+      return c + countAllInjections(((ParseNode) t).kids);
+    }
+    return 0;
+  }
+
+  private int countAllInjections(AbstractParseNode[] ls) {
+    // SG_CountAllInjectionsInTree
+    // - ok
+    int r = 0;
+    for (int i = 0, max = ls.length; i < max; i++) {
+      r += countAllInjections(ls[i]);
     }
-	 */
+    return r;
+  }
 
-	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode[] kids, boolean b, PositionMap visited) {
+  private int filterOnPreferCount(AbstractParseNode left,
+      AbstractParseNode right) {
+
+    if (Tools.debugging) {
+      Tools.debug("filterOnPreferCount()");
+    }
 
-		for (int i = 0, max = kids.length; i < max; i++) {
-			final List<AbstractParseNode> cycle = computeCyclicTerm(kids[i], false, visited);
-			if (cycle != null) {
-				return cycle;
-			}
-		}
-		return null;
-	}
+    ambiguityManager.increaseEagernessFilterCalledCount();
+
+    int r = FILTER_DRAW;
+    if (parseTable.hasPrefers() || parseTable.hasAvoids()) {
+      final int leftPreferCount = countPrefers(left);
+      final int rightPreferCount = countPrefers(right);
+      final int leftAvoidCount = countAvoids(left);
+      final int rightAvoidCount = countAvoids(right);
+
+      if ((leftPreferCount > rightPreferCount && leftAvoidCount <= rightAvoidCount)
+          || (leftPreferCount == rightPreferCount && leftAvoidCount < rightAvoidCount)) {
+        Tools.logger("Eagerness priority: ", left, " > ", right);
+        r = FILTER_LEFT_WINS;
+      }
+
+      if ((rightPreferCount > leftPreferCount && rightAvoidCount <= leftAvoidCount)
+          || (rightPreferCount == leftPreferCount && rightAvoidCount < leftAvoidCount)) {
+        if (r != FILTER_DRAW) {
+          Tools.logger("Symmetric eagerness priority: ", left, " == ", right);
+          r = FILTER_DRAW;
+        } else {
+          Tools.logger("Eagerness priority: ", right, " > ", left);
+          r = FILTER_RIGHT_WINS;
+        }
+      }
+    }
 
+    if (r != FILTER_DRAW) {
+      ambiguityManager.increaseEagernessFilterSucceededCount();
+    }
+
+    return r;
+  }
+
+  private int countPrefers(AbstractParseNode t) {
+    // SG_CountPrefersInTree
+    // - ok
+    if (t.isAmbNode()) {
+      return countPrefers(t.getChildren());
+    } else if (t.isParseNode()) {
+      final int type = getProductionType(t);
+      if (type == ProductionType.PREFER) {
+        return 1;
+      } else if (type == ProductionType.AVOID) {
+        return 0;
+      }
+      return countPrefers(((ParseNode) t).kids);
+    }
+    return 0;
+  }
+
+  private int countPrefers(AbstractParseNode[] ls) {
+    // SG_CountPrefersInTree
+    // - ok
+    int r = 0;
+    for (final AbstractParseNode n : ls) {
+      r += countPrefers(n);
+    }
+    return r;
+  }
+
+  private int countAvoids(AbstractParseNode t) {
+    // SG_CountAvoidsInTree
+    // - ok
+    if (t.isAmbNode()) {
+      return countAvoids(t.getChildren());
+    } else if (t.isParseNode()) {
+      final int type = getProductionType(t);
+      if (type == ProductionType.PREFER) {
+        return 0;
+      } else if (type == ProductionType.AVOID) {
+        return 1;
+      }
+      return countAvoids(((ParseNode) t).kids);
+    }
+    return 0;
+  }
+
+  private int countAvoids(AbstractParseNode[] ls) {
+    // SG_CountAvoidsInTree
+    // - ok
+    int r = 0;
+    for (final AbstractParseNode n : ls) {
+      r += countAvoids(n);
+    }
+    return r;
+  }
+
+  private int filterOnIndirectPrefers(AbstractParseNode left,
+      AbstractParseNode right) {
+    // SG_Indirect_Eagerness_Filter
+
+    if (Tools.debugging) {
+      Tools.debug("filterOnIndirectPrefers()");
+    }
+
+    if (left.isAmbNode() || right.isAmbNode()) {
+      return FILTER_DRAW;
+    }
+
+    if (!getLabel(left).equals(getLabel(right))) {
+      return filterOnDirectPrefers(left, right);
+    }
+
+    final ParseNode l = (ParseNode) left;
+    final ParseNode r = (ParseNode) right;
+
+    final AbstractParseNode[] leftArgs = l.kids;
+    final AbstractParseNode[] rightArgs = r.kids;
+
+    final int diffs = computeDistinctArguments(leftArgs, rightArgs);
+
+    if (diffs == 1) {
+      for (int i = 0; i < leftArgs.length; i++) {
+        final AbstractParseNode leftArg = leftArgs[i];
+        final AbstractParseNode rightArg = rightArgs[i];
+
+        if (!leftArg.equals(rightArg)) {
+          return filterOnIndirectPrefers(leftArg, rightArg);
+        }
+      }
+
+    }
+    return FILTER_DRAW;
+  }
+
+  private int filterOnDirectPrefers(AbstractParseNode left,
+      AbstractParseNode right) {
+    // SG_Direct_Eagerness_Filter
+
+    if (Tools.debugging) {
+      Tools.debug("filterOnDirectPrefers()");
+    }
+
+    // TODO: optimize - move up the jumpOverInjectionsModuloEagerness calls
+    if (isLeftMoreEager(left, right)) {
+      return FILTER_LEFT_WINS;
+    }
+    if (isLeftMoreEager(right, left)) {
+      return FILTER_RIGHT_WINS;
+    }
+
+    return FILTER_DRAW;
+  }
+
+  private boolean isLeftMoreEager(AbstractParseNode left,
+      AbstractParseNode right) {
+    assert !(left.isAmbNode() || right.isAmbNode());
+    if (isMoreEager(left, right)) {
+      return true;
+    }
+
+    final AbstractParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
+    final AbstractParseNode newRight = jumpOverInjectionsModuloEagerness(right);
+
+    if (newLeft.isParseNode() && newRight.isParseNode()) {
+      return isMoreEager(newLeft, newRight);
+    }
+
+    return false;
+  }
+
+  private AbstractParseNode jumpOverInjectionsModuloEagerness(
+      AbstractParseNode t) {
+
+    if (Tools.debugging) {
+      Tools.debug("jumpOverInjectionsModuloEagerness()");
+    }
+
+    final int prodType = getProductionType(t);
+
+    if (t.isParseNode() && prodType != ProductionType.PREFER
+        && prodType != ProductionType.AVOID) {
+
+      Label prod = getLabel(t);
+
+      while (prod.isInjection()) {
+        t = ((ParseNode) t).kids[0];
+
+        if (t.isParseNode()) {
+          final int prodTypeX = getProductionType(t);
+
+          if (prodTypeX != ProductionType.PREFER
+              && prodTypeX != ProductionType.AVOID) {
+            prod = getLabel(t);
+            continue;
+          }
+        }
+        return t;
+      }
+    }
+    return t;
+  }
+
+  private Label getLabel(AbstractParseNode t) {
+    if (t.isParseNode()) {
+      final ParseNode n = (ParseNode) t;
+      return parseTable.getLabel(n.getLabel());
+    } else if (t instanceof ParseProductionNode) {
+      final ParseProductionNode n = (ParseProductionNode) t;
+      return parseTable.getLabel(n.prod);
+    }
+    return null;
+  }
+
+  private int getProductionType(AbstractParseNode t) {
+    return getLabel(t).getAttributes().getType();
+  }
+
+  private boolean isMoreEager(AbstractParseNode left, AbstractParseNode right) {
+    final int leftLabel = ((ParseNode) left).getLabel();
+    final int rightLabel = ((ParseNode) right).getLabel();
+
+    final Label leftProd = parseTable.getLabel(leftLabel);
+    final Label rightProd = parseTable.getLabel(rightLabel);
+
+    if (leftProd.isMoreEager(rightProd)) {
+      return true;
+    }
+
+    return false;
+  }
+
+  private int computeDistinctArguments(AbstractParseNode[] leftArgs,
+      AbstractParseNode[] rightArgs) {
+    // countDistinctArguments
+    int r = 0;
+    for (int i = 0; i < leftArgs.length; i++) {
+      if (!leftArgs[i].equals(rightArgs[i])) {
+        r++;
+      }
+    }
+    return r;
+  }
+
+  private boolean isCyclicTerm(AbstractParseNode t) {
+
+    ambiguityManager.dumpIndexTable();
+
+    final List<AbstractParseNode> cycles = computeCyclicTerm(t);
+
+    return cycles != null && cycles.size() > 0;
+  }
+
+  private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t) {
+    // FIXME rewrite to use HashMap and object id
+    final PositionMap visited = new PositionMap(
+        ambiguityManager.getMaxNumberOfAmbiguities());
+
+    ambiguityCount += ambiguityManager.getAmbiguitiesCount();
+    ambiguityManager.resetAmbiguityCount();
+
+    return computeCyclicTerm(t, false, visited);
+  }
+
+  private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t,
+      boolean inAmbiguityCluster, PositionMap visited) {
+
+    if (Tools.debugging) {
+      Tools.debug("computeCyclicTerm() - ", t);
+    }
+
+    if (t instanceof ParseProductionNode) {
+      if (Tools.debugging) {
+        Tools.debug(" bumping");
+      }
+      return null;
+    } else if (t.isParseNode()) {
+      // Amb ambiguities = null;
+      List<AbstractParseNode> cycle = null;
+      // int clusterIndex;
+      final ParseNode n = (ParseNode) t;
+
+      if (inAmbiguityCluster) {
+        cycle = computeCyclicTerm(n.kids, false, visited);
+      } else {
+        /*
+         * if (ambiguityManager.isInputAmbiguousAt(parseTreePosition)) {
+         * ambiguityManager.increaseAmbiguityCount(); clusterIndex =
+         * ambiguityManager.getClusterIndex(t, parseTreePosition); if
+         * (SGLR.isDebugging()) { Tools.debug(" - clusterIndex : ",
+         * clusterIndex); } if (markMap.isMarked(clusterIndex)) { return new
+         * ArrayList<IParseNode>(); } ambiguities =
+         * ambiguityManager.getClusterOnIndex(clusterIndex); } else {
+         * clusterIndex = -1; }
+         */
+
+        throw new NotImplementedException();
+        /*
+         * if (ambiguities == null) { cycle = computeCyclicTerm(((ParseNode)
+         * t).getKids(), false, visited); } else { int length =
+         * visited.getValue(clusterIndex); int savePos = parseTreePosition;
+         * 
+         * if (length == -1) { //markMap.mark(clusterIndex); cycle =
+         * computeCyclicTermInAmbiguityCluster(ambiguities, visited);
+         * visited.put(clusterIndex, parseTreePosition - savePos);
+         * //markMap.unmark(clusterIndex); } else { parseTreePosition += length;
+         * } }
+         */
+      }
+      return cycle;
+    } else {
+      throw new FatalException();
+    }
+  }
+
+  /*
+   * private List<IParseNode> computeCyclicTermInAmbiguityCluster(Amb
+   * ambiguities, PositionMap visited) {
+   * 
+   * 
+   * List<IParseNode> ambs = ambiguities.getAlternatives(); for (int i = 0, max
+   * = ambs.size(); i < max; i++) { IParseNode amb = ambs.get(i);
+   * List<IParseNode> cycle = computeCyclicTerm(amb, true, visited); if (cycle
+   * != null) return cycle; } return null; }
+   */
+
+  private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode[] kids,
+      boolean b, PositionMap visited) {
+
+    for (int i = 0, max = kids.length; i < max; i++) {
+      final List<AbstractParseNode> cycle = computeCyclicTerm(kids[i], false,
+          visited);
+      if (cycle != null) {
+        return cycle;
+      }
+    }
+    return null;
+  }
+
+  private List<int[]> getLongestMatchPositions(AbstractParseNode n) {
+    if (n.isAmbNode()) {
+      List<int[]> pos1 = getLongestMatchPositions(n.getChildren()[0]);
+      List<int[]> pos2 = getLongestMatchPositions(n.getChildren()[1]);
+      assert pos1.size() == pos2.size();
+      return pos1;
+    }
+
+    LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
+    nodes.push(n);
+    
+    ArrayList<int[]> positions = new ArrayList<int[]>();
+    
+    while (!nodes.isEmpty()) {
+      n = nodes.pop();
+      
+      if (n.isParseProductionNode())
+        continue;
+            
+      if (!n.isAmbNode() && parseTable.getLabel(n.getLabel()).getAttributes().isLongestMatch())
+        positions.add(new int[]{n.getLine(), n.getColumn(), n.getLast().getLine(), n.getLast().getColumn()});
+      
+      for (int i = n.getChildren().length - 1; i >= 0; i--)
+        nodes.push(n.getChildren()[i]);
+    }
+
+    return positions;
+  }
+  
+  private class LongestMatchIterator implements Iterator<int[]> {
+    private int[] next = null;
+    private boolean computedNext = false;
+    private LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
+    
+    public LongestMatchIterator(AbstractParseNode n) {
+      nodes.push(n);
+    }
+    
+    @Override
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
+    
+    @Override
+    public int[] next() {
+      if (!computedNext)
+        computeNext();
+      int[] res = next;
+      computedNext = false;
+      next = null;
+      return res;
+    }
+    
+    @Override
+    public boolean hasNext() {
+      if (!computedNext)
+        computeNext();
+      return next != null;
+    }
+    
+    private void computeNext() {
+      while (!computedNext && !nodes.isEmpty()) {
+        AbstractParseNode n = nodes.pop();
+        
+        if (n.isParseProductionNode())
+          continue;
+              
+        if (!n.isLayout())
+          for (int i = n.getChildren().length - 1; i >= 0; i--)
+            nodes.push(n.getChildren()[i]);
+
+        if (!n.isAmbNode() && parseTable.getLabel(n.getLabel()).getAttributes().isLongestMatch()) {
+          next = new int[]{n.getLine(), n.getColumn(), n.getLast().getLine(), n.getLast().getColumn()};
+          computedNext = true;
+        }
+      }
+    }
+  }
+  
+  private Iterator<int[]> getLongestMatchIterator(AbstractParseNode n) {
+    if (n.isAmbNode()) {
+      List<int[]> pos1 = getLongestMatchPositions(n.getChildren()[0]);
+      List<int[]> pos2 = getLongestMatchPositions(n.getChildren()[1]);
+      assert pos1.size() == pos2.size();
+      return pos1.iterator();
+    }
+
+    return new LongestMatchIterator(n); 
+  }
+  
+  private int filterLongestMatch(AbstractParseNode left, AbstractParseNode right) {
+    Iterator<int[]> leftPositions = getLongestMatchIterator(left);
+    Iterator<int[]> rightPositions = getLongestMatchIterator(right);
+    
+    while (leftPositions.hasNext() && rightPositions.hasNext()) {
+      int[] leftPosition = leftPositions.next();
+      int[] rightPosition = rightPositions.next();
+
+      if (leftPosition[0] == rightPosition[0] && leftPosition[1] == rightPosition[1]) {
+        if (leftPosition[2] > rightPosition[2] || leftPosition[2] == rightPosition[2] && leftPosition[3] > rightPosition[3])
+          return FILTER_LEFT_WINS;
+        else if (leftPosition[2] < rightPosition[2] || leftPosition[2] == rightPosition[2] && leftPosition[3] < rightPosition[3])
+          return FILTER_RIGHT_WINS;
+      }
+      else
+        System.out.println("mismatching start");
+    }
+    
+    assert !leftPositions.hasNext() && !rightPositions.hasNext();
+    
+    return FILTER_DRAW;
+  }
+  
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/FineGrainedOnRegion.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
--- src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	2012-09-28 00:32:15.000000000 +0200
@@ -0,0 +1,185 @@
+package org.spoofax.jsglr.client;
+
+import java.util.ArrayList;
+
+public class FineGrainedOnRegion {
+
+    private static final int MAX_NR_OF_EXPLORED_LINES = 75;
+	private int acceptRecoveryPosition;
+    private int regionEndPosition;
+    private ArrayList<BacktrackPosition> choicePoints;
+    private static int MAX_BACK_JUMPS=5;
+    private SGLR mySGLR;
+    
+    private ParserHistory getHistory() {
+        return mySGLR.getHistory();
+    }
+   
+    public void setInfoFGOnly(){
+        regionEndPosition=mySGLR.tokensSeen+5;
+        acceptRecoveryPosition=regionEndPosition+15;
+        int lastIndex=getHistory().getIndexLastLine();       
+        for (int i = Math.max(0, lastIndex-MAX_NR_OF_EXPLORED_LINES); i < lastIndex; i++) {
+            IndentInfo line= getHistory().getLine(i);
+            if(line.getStackNodes()!=null && line.getStackNodes().size()>0){
+                BacktrackPosition btPoint=new BacktrackPosition(line.getStackNodes(), line.getTokensSeen());
+                btPoint.setIndexHistory(i);
+                choicePoints.add(btPoint);
+            }            
+        }
+    }
+    
+    public void setRegionInfo(StructureSkipSuggestion erroneousRegion, int acceptPosition){
+        regionEndPosition=erroneousRegion.getEndSkip().getTokensSeen();
+        acceptRecoveryPosition=acceptPosition;
+        int lastIndex=Math.min(erroneousRegion.getIndexHistoryEnd(), getHistory().getIndexLastLine());
+        assert(
+        	lastIndex >= 0 &&
+        	erroneousRegion.getIndexHistoryStart()>=0 && 
+        	erroneousRegion.getIndexHistoryStart()<=erroneousRegion.getIndexHistoryEnd()
+        );
+        int btStartIndex=Math.max(erroneousRegion.getIndexHistoryStart(), lastIndex-MAX_NR_OF_EXPLORED_LINES);
+        for (int i = btStartIndex; i < lastIndex; i++) {
+            IndentInfo line= getHistory().getLine(i);
+            if (line.getStackNodes() != null && line.getStackNodes().size()>0){
+                BacktrackPosition btPoint=new BacktrackPosition(line.getStackNodes(), line.getTokensSeen());
+                btPoint.setIndexHistory(i);
+                choicePoints.add(btPoint);
+            }            
+        }
+    }
+    
+    public boolean recover() throws InterruptedException {
+        int btIndex=choicePoints.size()-1;
+        if(btIndex>=0)
+        	return recoverFrom(btIndex, new ArrayList<RecoverNode>());
+        return false;
+    }
+
+	private boolean recoverFrom(int btIndex, ArrayList<RecoverNode> unexplored_branches) throws InterruptedException {
+        ArrayList<RecoverNode> rec_Branches=new ArrayList<RecoverNode>();
+        if(btIndex>=0){
+        	rec_Branches=collectRecoverBranches(btIndex); //collect permissive branches at btIndex line
+        	resetSGLR(btIndex);
+        }
+        else
+        	resetSGLR(0);
+        rec_Branches.addAll(unexplored_branches);
+    	
+        ArrayList<RecoverNode> newbranches=recoverParse(rec_Branches, regionEndPosition); //explore and collect
+
+    	if(acceptParse())
+        	return true;
+        if(choicePoints.size()-1-btIndex > MAX_BACK_JUMPS){
+        	if(btIndex>0){
+        		//Permissive branches constructed by one recovery are always explored
+	        	ArrayList<RecoverNode> rec_Branches_prefix=new ArrayList<RecoverNode>();
+	        	rec_Branches_prefix=collectRecoverBranches(0, btIndex);
+	        	resetSGLR(0);
+	        	ArrayList<RecoverNode> oneRecoverBranches = recoverParse(rec_Branches_prefix, regionEndPosition);
+	        	if(!acceptParse()){
+	        		resetSGLR(0);
+	        		recoverParse(oneRecoverBranches, regionEndPosition);
+	        	}
+	        	return acceptParse();
+        	}
+        	return false;
+        }
+        return recoverFrom(btIndex-1, newbranches);
+	}
+
+	private void resetSGLR(int btIndex) {
+		BacktrackPosition btrPosition=choicePoints.get(btIndex);    
+    	mySGLR.activeStacks.clear(true); //only permissive branches are explored
+        getHistory().setTokenIndex(btrPosition.tokensSeen);
+	}
+
+	private ArrayList<RecoverNode> collectRecoverBranches(int btIndex) throws InterruptedException {
+		resetSGLR(btIndex);
+        mySGLR.activeStacks.addAll(choicePoints.get(btIndex).recoverStacks);
+        int endPos=btIndex<choicePoints.size()-1 ? choicePoints.get(btIndex+1).tokensSeen-1 : regionEndPosition;
+    	ArrayList<RecoverNode> rec1_Branches=recoverParse(new ArrayList<RecoverNode>(), endPos);
+		return rec1_Branches;
+	}
+	
+	private ArrayList<RecoverNode> collectRecoverBranches(int btIndex, int btIndex_end) throws InterruptedException {
+		resetSGLR(btIndex);
+        mySGLR.activeStacks.addAll(choicePoints.get(btIndex).recoverStacks);
+        int endPos=btIndex_end < choicePoints.size() ? choicePoints.get(btIndex_end).tokensSeen-1 : regionEndPosition;
+    	ArrayList<RecoverNode> rec1_Branches=recoverParse(new ArrayList<RecoverNode>(), endPos);
+		return rec1_Branches;
+	}
+    
+    /** 
+     * Explores permissive branches, and collects derived branches with higher recover count
+     * @throws InterruptedException 
+     */
+    private ArrayList<RecoverNode> recoverParse(ArrayList<RecoverNode> candidates, int endRecoverSearchPos) throws InterruptedException {
+    	mySGLR.setFineGrainedOnRegion(true);
+        ArrayList<RecoverNode> newCandidates=new ArrayList<RecoverNode>();
+        int curTokIndex;
+        do {
+            curTokIndex=getHistory().getTokenIndex();
+            addCurrentCandidates(candidates, curTokIndex);
+            getHistory().readRecoverToken(mySGLR, false);
+            //System.out.print((char)mySGLR.currentToken);
+            mySGLR.doParseStep();
+            newCandidates.addAll(collectNewRecoverCandidates(curTokIndex));
+            mySGLR.getRecoverStacks().clear();
+        } while(getHistory().getTokenIndex()<= endRecoverSearchPos && mySGLR.acceptingStack==null && mySGLR.getCurrentToken()!=SGLR.EOF);
+    	mySGLR.setFineGrainedOnRegion(false);
+        return newCandidates;
+    }
+    
+    /**
+     * Permissive branches are accepted if they are still alive at the accepting position
+     * @throws InterruptedException 
+     */
+    private boolean acceptParse() throws InterruptedException{
+        while(getHistory().getTokenIndex()<= acceptRecoveryPosition && mySGLR.acceptingStack==null && mySGLR.activeStacks.size()>0){
+            getHistory().readRecoverToken(mySGLR, false);
+            //System.out.print((char)mySGLR.currentToken);
+            mySGLR.doParseStep();
+        }
+    	return mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null;
+    }
+
+    private ArrayList<RecoverNode> collectNewRecoverCandidates(int tokenIndex) {
+        ArrayList<RecoverNode> results=new ArrayList<RecoverNode>();
+        for (Frame recoverStack : mySGLR.getRecoverStacks()) {
+            RecoverNode rn = new RecoverNode(recoverStack, tokenIndex);
+            results.add(rn);
+        }
+        return results;
+    }
+    
+    private void addCurrentCandidates(ArrayList<RecoverNode> candidates, int tokenPosition) {
+        for (RecoverNode recoverNode : candidates) {
+            if(tokenPosition==recoverNode.tokensSeen){
+            	Frame st =mySGLR.findStack(mySGLR.activeStacks, recoverNode.recoverStack.state);
+                if(st!=null) {
+                	for (Link ln : recoverNode.recoverStack.getAllLinks()) {
+                		st.addLink(ln);
+					}                	
+                }
+                else
+                	mySGLR.addStack(recoverNode.recoverStack);
+            }
+        }
+    }
+
+    public FineGrainedOnRegion(SGLR parser){
+        mySGLR=parser;
+        choicePoints=new ArrayList<BacktrackPosition>();
+    }
+
+    public boolean parseRemainingTokens() throws InterruptedException {
+        // TODO what if parsing fails here???
+        while(!getHistory().hasFinishedRecoverTokens() && mySGLR.activeStacks.size()>0 && mySGLR.acceptingStack==null){        
+            getHistory().readRecoverToken(mySGLR, true);
+            //System.out.print((char)mySGLR.currentToken);
+            mySGLR.doParseStep();            
+        }  
+        return mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null;        
+    }
+}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/FineGrainedRecovery.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/FineGrainedRecovery.java
--- src/org/spoofax/jsglr/client/FineGrainedRecovery.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/FineGrainedRecovery.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,309 +0,0 @@
-package org.spoofax.jsglr.client;
-
-import java.util.ArrayList;
-
-import org.spoofax.jsglr.client.SGLR;
-
-/**
- * @author maartje
- *
- */
-public class FineGrainedRecovery {
-	
-	// safety guard: > 1000 recover branches seem to cause performance problems
-	private static final int MAX_NUMBER_OF_RECOVER_BRANCHES = 1000;  	
-	//minimum number of characters that must be parsed error-free before recovery is accepted 
-	//(safety guard against false accepts after some empty lines)
-	private static final int ACCEPT_DISTANCE_CHARACTERS = 100; 
-
-	/*
-	 * Settings that control the heuristics applied to find a recover branch
-	 */
-	private final FineGrainedSetting settings;
-	
-	/*
-	 * Properties of the current error
-	 */
-	private int exploredRegionStartOffset; //recoveries at the left of the region start are not explored
-	private int exploredRegionEndOffset; //recoveries at the right of the region end are not explored
-	private int lineIndexRecovery; //line index where recovery search starts (parse failure line, region end line, cursor line(?!))
-	private int failureOffset; //location where parser failed
-	private long recoverStartTime; //start time
-
-	private void checkAssertionsForErrorProperties() {
-    	assert(exploredRegionStartOffset < exploredRegionEndOffset);
-    	assert(exploredRegionStartOffset < failureOffset);
-		assert(lineIndexRecovery <= getHistory().getIndexLastLine());
-		//assert(getHistory().getLine(lineIndexRecovery).getStackNodes().size() > 0);
-		assert(getTokensSeenAtLine(lineIndexRecovery) <= failureOffset);
-		assert(failureOffset >= getTokensSeenAtLine(lineIndexRecovery));
-	}
-
-	private void checkAssertionsUnexploredBranches(ArrayList<RecoverNode> unexplored_branches, int bwIndex) {
-		for (RecoverNode recoverNode : unexplored_branches) {
-			assert(exploredRegionStartOffset <= recoverNode.tokensSeen);
-			assert(getTokensSeenAtLine(bwIndex) <= recoverNode.tokensSeen);
-			assert(recoverNode.tokensSeen <= exploredRegionEndOffset);
-		}
-	}
-
-	/*
-	 * Parser instance
-	 */
-    private final SGLR mySGLR;
-    
-	private ParserHistory getHistory() {
-		return mySGLR.getHistory();
-	}
-	
-	/**
-	 * Correcting recovery technique for SGLR parser
-	 * Applies recover productions (which simulate token insertions and deletions) 
-	 * using a expanding search space heuristic over an untrusted source fragment  
-	 * @param SGLR parser
-	 */
-	public FineGrainedRecovery(SGLR parser) {
-		this(parser, FineGrainedSetting.createDefaultSetting());
-	}
-
-	/**
-	 * Correcting recovery technique for SGLR.
-	 * @param SGLR parser
-	 * @param Setting that determines the expanding search space heuristics applied to find a suitable recovery
-	 */
-	public FineGrainedRecovery(SGLR parser, FineGrainedSetting fgSettings) {
-		this.settings = fgSettings;		
-		this.mySGLR = parser;
-	}
-	
-    /**
-     * Constructs a recover branch for SGLR
-     * @param failureOffset location where the parser fails
-     * @param recoverIndex line index (from parser history) where recover search starts
-     * (typically: region-end index, failure index, or: index of cursor line if nearby and at the left of failure index)
-     * @param regionStartOffset restricts the search space to the left
-     * @param regionEndOffset restricts the search space to the right
-     * @return true iff suitable recover branch is constructed
-     */
-    public boolean recover(int failureOffset, int recoverIndex, int regionStartOffset, int regionEndOffset){
-    	this.exploredRegionStartOffset = regionStartOffset; 
-    	this.exploredRegionEndOffset = regionEndOffset;
-    	return finegrainedRecover(failureOffset, recoverIndex);
-    }
-
-    /**
-     * Constructs a recover branch for SGLR
-     * @param failureOffset location where the parser fails
-     * @param recoverIndex line index (from parser history) where recover search starts
-     * (typically: failure index, or: index of cursor line if nearby and at the left of failure index)
-     * @return true iff suitable recover branch is constructed
-     */
-	public boolean recover(int failureOffset, int recoverIndex){
-    	this.exploredRegionStartOffset = -1;
-    	this.exploredRegionEndOffset = Integer.MAX_VALUE;
-    	return finegrainedRecover(failureOffset, recoverIndex);
-    }
-
-	private boolean finegrainedRecover(int failureOffset, int recoverIndex) {
-		this.failureOffset = failureOffset;
-    	this.lineIndexRecovery = recoverIndex; 
-    	this.recoverStartTime = System.currentTimeMillis();
-    	checkAssertionsForErrorProperties();
-    	mySGLR.setFineGrainedRecoverMax(settings.getMaxNumberOfRecoverApplicationsLocal());
-    	return recoverFrom(0, new ArrayList<RecoverNode>());
-	}
-
-	private boolean recoverFrom(int loopIndex, ArrayList<RecoverNode> unexplored_branches) {
-		int bwLoopIndex = lineIndexRecovery - (int)(settings.getBackwardFactor() * loopIndex);
-		int backwardIndex = Math.max(0, bwLoopIndex);
-		int forwardLinesMax = Math.min(settings.getForwardDistanceLines(), (int)(settings.getForwardFactor() * loopIndex));
-		assert(forwardLinesMax >= 0);		
-		assert(forwardLinesMax <= settings.getForwardDistanceLines());		
-				
-		unexplored_branches.addAll(getBackwardRecoverCandidates(loopIndex));
-		checkAssertionsUnexploredBranches(unexplored_branches, backwardIndex);
-		resetSGLR(backwardIndex, false);
-		ArrayList<RecoverNode> newCandidates = recoverParse(forwardLinesMax, this.exploredRegionEndOffset, unexplored_branches);
-		if(!acceptParse()){
-			if(timelimitExpired()){
-				return false;
-			}			
-			if(continueBacktracking(bwLoopIndex)){
-				if(newCandidates.size() > MAX_NUMBER_OF_RECOVER_BRANCHES)
-					newCandidates = new ArrayList<RecoverNode>(); //too much branches causes performance problems
-				return recoverFrom(loopIndex + 1, newCandidates);
-			}
-			int exploreDepth = 1;
-			do {
-				resetSGLR(backwardIndex, false);
-				newCandidates = recoverParse(forwardLinesMax, this.exploredRegionEndOffset, newCandidates);
-				exploreDepth ++;
-				if(acceptParse())
-					return true;
-			} while(exploreDepth < settings.getMaxNumberOfRecoverApplicationsLocal() && 
-					!timelimitExpired() && 
-					newCandidates.size() < MAX_NUMBER_OF_RECOVER_BRANCHES &&
-					newCandidates.size() > 0);
-			if (continueSingleTokenBacktracking(bwLoopIndex)){
-				return recoverFrom(loopIndex + 1, new ArrayList<RecoverNode>());
-			}
-			return false;
-		}
-		return true;
-	}
-
-	/**
-	 * Collects recover branches between current parser location and fwTokensSeenMax. 
-	 * Either from a previously unexplored line,
-	 * or from a set of unexplored branches.
-	 * Stops in case more then fwLineMax newlines are parsed after the line where recovery started
-	 * @param fwLineMax restricts search space to the right: max number of lines that may be explored after recover line
-	 * @param fwTokensSeenMax restricts search space to the right, exploration within erroneous region
-	 * @param candidates candidate branches that are explored
-	 * @return new candidate branches
-	 */
-	private ArrayList<RecoverNode> recoverParse(int fwLineMax, int fwTokensSeenMax, ArrayList<RecoverNode> candidates) {
-		// Backtracking is not combined with exploration because that creates
-		// duplicates
-		assert (mySGLR.activeStacks.size() == 0 || candidates.size() == 0);
-
-		ArrayList<RecoverNode> newCandidates = new ArrayList<RecoverNode>();
-		int curTokIndex;
-		int exploredLinesForward = 0;
-		mySGLR.setFineGrainedStartLocation(getHistory().getTokenIndex());
-		do {
-			curTokIndex = getHistory().getTokenIndex();
-			addCurrentCandidates(candidates, curTokIndex);
-			getHistory().readRecoverToken(mySGLR, false);
-			if (mySGLR.getCurrentToken() == '\n' && curTokIndex > getTokensSeenAtLine(lineIndexRecovery)){
-				exploredLinesForward++;
-			}
-			// System.out.print((char)mySGLR.currentToken);
-			mySGLR.setFinegrainedRecoverMode(exploredRegionStartOffset <= curTokIndex);
-			mySGLR.doParseStep();
-			newCandidates.addAll(collectNewRecoverCandidates(curTokIndex));
-			mySGLR.getRecoverStacks().clear();
-		} while (
-				   (exploredLinesForward <= fwLineMax || RecoveryConnector.isLayoutCharacter((char)mySGLR.getCurrentToken()))
-				&& (exploredLinesForward <= settings.getForwardDistanceLines() || RecoveryConnector.isLayoutCharacter((char)mySGLR.getCurrentToken()))
-				&& getHistory().getTokenIndex() <= exploredRegionEndOffset
-				&& getHistory().getTokenIndex() <= fwTokensSeenMax
-				&& mySGLR.acceptingStack == null
-				&& mySGLR.getCurrentToken() != SGLR.EOF);
-		mySGLR.setFinegrainedRecoverMode(false);
-		return newCandidates;
-	}
-
-    private void addCurrentCandidates(ArrayList<RecoverNode> candidates, int tokenPosition) {
-        for (RecoverNode recoverNode : candidates) {
-            if(tokenPosition==recoverNode.tokensSeen){
-            	Frame st =mySGLR.findStack(mySGLR.activeStacks, recoverNode.recoverStack.state);
-                if(st != null) {
-                	for (Link ln : recoverNode.recoverStack.getAllLinks()) {
-                		assert(ln.recoverCount > 0 && ln.recoverWeight > 0);
-                		st.addLink(ln);
-					}                	
-                }
-                else
-                	mySGLR.addStack(recoverNode.recoverStack);
-            }
-        }
-    }
-
-	private void resetSGLR(int btIndex, boolean keepStacks) {
-    	mySGLR.activeStacks.clear();
-    	mySGLR.acceptingStack = null;
-		if(keepStacks){
-	        mySGLR.activeStacks.addAll(getHistory().getLine(btIndex).getStackNodes());
-		}
-        getHistory().setTokenIndex(getHistory().getLine(btIndex).getTokensSeen());
-	}
-
-    private ArrayList<RecoverNode> collectNewRecoverCandidates(int tokenIndex) {
-    	assert(tokenIndex >= exploredRegionStartOffset || mySGLR.getRecoverStacks().isEmpty());
-    	assert(tokenIndex <= exploredRegionEndOffset || mySGLR.getRecoverStacks().isEmpty());
-        ArrayList<RecoverNode> results=new ArrayList<RecoverNode>();
-        for (Frame recoverStack : mySGLR.getRecoverStacks()) {
-            RecoverNode rn = new RecoverNode(recoverStack, tokenIndex);
-            results.add(rn);
-        }
-        return results;
-    }
-
-	private boolean timelimitExpired() {
-		return System.currentTimeMillis() - this.recoverStartTime > settings.getTimeLimit();
-	}
-
-	private ArrayList<RecoverNode> getBackwardRecoverCandidates(int loopIndex) {
-
-		int bwIndexPrev = Math.max(0,lineIndexRecovery - (int)(settings.getBackwardFactor() * (loopIndex - 1)));
-		int bwIndex = Math.max(0, lineIndexRecovery - (int)(settings.getBackwardFactor() * loopIndex));
-
-		assert(0 <= bwIndex);
-		assert(bwIndex <= lineIndexRecovery);
-		assert(bwIndex <= bwIndexPrev);
-		if (loopIndex > 0 && bwIndex == bwIndexPrev || preceedsErroneousRegion(bwIndexPrev)){
-			return new ArrayList<RecoverNode>();
-		}
-		resetSGLR(bwIndex, true);
-		int fwTokensSeenMax = Integer.MAX_VALUE;
-		if(bwIndexPrev <= getHistory().getIndexLastLine()){
-			fwTokensSeenMax = getTokensSeenAtLine(bwIndexPrev);
-		}
-		ArrayList<RecoverNode> newBranches = recoverParse(0, fwTokensSeenMax, new ArrayList<RecoverNode>());
-		return newBranches;
-	}
-
-	private boolean preceedsErroneousRegion(int lineIndex) {
-		return 
-			lineIndex <= getHistory().getIndexLastLine() &&
-			getTokensSeenAtLine(lineIndex) <= exploredRegionStartOffset;
-	}
-
-	private int getTokensSeenAtLine(int lineIndex) {
-		return getHistory().getLine(lineIndex).getTokensSeen();
-	}
-
-	private boolean continueBacktracking(int backwardIndex) {
-		assert(backwardIndex <= lineIndexRecovery);
-		return lineIndexRecovery - backwardIndex < settings.getBacktrackDistanceLines();
-	}
-
-	private boolean continueSingleTokenBacktracking(int backwardIndex) {
-		return lineIndexRecovery - backwardIndex < settings.getBacktrackDistanceLinesSingleToken();
-	}
-	
-	/**
-	 * recovery is accepted in case a minimal number of characters and lines
-	 * are parsed error free after failure location (and last recovery location).
-	 * Or in case accepting stack is constructed
-	 * @return true iff suitable recover stack constructed
-	 */
-	private boolean acceptParse() {
-		String parsedFragment = "";
-		while (mySGLR.activeStacks.size() > 0 && !acceptRecovery(parsedFragment)) {
-			getHistory().readRecoverToken(mySGLR, false);
-			if(getHistory().getTokenIndex() > failureOffset){
-				parsedFragment += ((char)mySGLR.getCurrentToken());
-			}
-			// System.out.print((char)mySGLR.currentToken);
-			mySGLR.doParseStep();
-		}
-		return acceptRecovery(parsedFragment);
-	}
-
-	/**
-	 * Recovery is accepted if:
-	 * - Parser has accepting stack at EOF
-	 * - sufficiently large fragment is parsed without a recover application 
-	 */
-	private boolean acceptRecovery(String parsedFragmentSinceLastRecovery){
-		if(mySGLR.acceptingStack != null)
-			return true;
-		return 
-			mySGLR.activeStacks.size() > 0
-		&&	parsedFragmentSinceLastRecovery.split("\n").length > settings.getAcceptDistanceLines()
-		&&	parsedFragmentSinceLastRecovery.length() > ACCEPT_DISTANCE_CHARACTERS
-		&&  getHistory().getTokenIndex() > exploredRegionEndOffset;
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/FineGrainedSetting.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/FineGrainedSetting.java
--- src/org/spoofax/jsglr/client/FineGrainedSetting.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/FineGrainedSetting.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,256 +0,0 @@
-package org.spoofax.jsglr.client;
-
-public class FineGrainedSetting {
-
-	private int acceptDistanceLines; //number of lines that must be parsed error-free before recovery is accepted
-	private int backtrackDistanceLines; //maximum number of (non-empty) lines that is fully backtracked
-	private int forwardDistanceLines; //maximum number of (non-empty) lines that is explored at the right context
-	private int backtrackDistanceLinesSingleToken; //maximum number of (non-empty) lines that is explored for single token recoveries
-	private double backwardFactor; //increase explored left context with x lines at each loop 
-	private double forwardFactor; //increase explored right context with x lines at each loop (for example: 0.5 then extend one line after two loops)
-	private int maxNumberOfRecoverApplicationsLocal; //branches with more then x recoveries after backtrack offset are cut off in FG mode
-
-	/*
-	 * Settings that control the heuristics applied to find a recover branch
-	 */
-	private int timeLimit; //finegrained is stopped in case time limit expired
-	
-	public int getTimeLimit() {
-		return timeLimit;
-	}
-
-	public FineGrainedSetting setTimeLimit(int timeLimit) {
-		this.timeLimit = timeLimit;
-		return this;
-	}
-
-	public int getAcceptDistanceLines() {
-		return acceptDistanceLines;
-	}
-
-	public FineGrainedSetting setAcceptDistanceLines(int acceptDistanceLines) {
-		this.acceptDistanceLines = acceptDistanceLines;
-		return this;
-	}
-
-	public int getForwardDistanceLines() {
-		return forwardDistanceLines;
-	}
-
-	public FineGrainedSetting setForwardDistanceLines(int forwardDistanceLines) {
-		this.forwardDistanceLines = forwardDistanceLines;
-		return this;
-	}
-	public int getBacktrackDistanceLines() {
-		return backtrackDistanceLines;
-	}
-
-	public FineGrainedSetting setBacktrackDistanceLines(int backtrackDistanceLines) {
-		this.backtrackDistanceLines = backtrackDistanceLines;
-		return this;
-	}
-
-	public int getBacktrackDistanceLinesSingleToken() {
-		return backtrackDistanceLinesSingleToken;
-	}
-
-	public FineGrainedSetting setBacktrackDistanceLinesSingleToken(
-			int backtrackDistanceLinesSingleToken) {
-		this.backtrackDistanceLinesSingleToken = backtrackDistanceLinesSingleToken;
-		return this;
-	}
-
-	public double getBackwardFactor() {
-		return backwardFactor;
-	}
-
-	public FineGrainedSetting setBackwardFactor(double backwardFactor) {
-		this.backwardFactor = backwardFactor;
-		return this;
-	}
-
-	public double getForwardFactor() {
-		return forwardFactor;
-	}
-
-	public FineGrainedSetting setForwardFactor(double forwardFactor) {
-		this.forwardFactor = forwardFactor;
-		return this;
-	}
-
-	public int getMaxNumberOfRecoverApplicationsLocal() {
-		return maxNumberOfRecoverApplicationsLocal;
-	}
-
-	public FineGrainedSetting setMaxNumberOfRecoverApplicationsLocal(
-			int maxNumberOfRecoverApplicationsLocal) {
-		this.maxNumberOfRecoverApplicationsLocal = maxNumberOfRecoverApplicationsLocal;
-		return this;
-	}
-
-	private FineGrainedSetting() {
-		this.setTimeLimit(1000);
-		this.setAcceptDistanceLines(5);
-		this.setBacktrackDistanceLines(8);
-		this.setBacktrackDistanceLinesSingleToken(80);
-		this.setBackwardFactor(1);
-		this.setForwardDistanceLines(8);
-		this.setForwardFactor(0.5);
-		this.setMaxNumberOfRecoverApplicationsLocal(5);		
-	}
-	
-	/**
-	 * Setting that is fine tuned for interactive editing.
-	 * Both the left- and the right- context of the failure location are explored
-	 * using an expanding search space.
-	 * Recovery fails or succeeds within 1 second
-	 * @return Standard setting for fine grained recovery in an interactive environment
-	 */
-	public static FineGrainedSetting createDefaultSetting(){
-		FineGrainedSetting fgSetting = new FineGrainedSetting()
-			.setTimeLimit(1000)
-			.setAcceptDistanceLines(5)
-			.setBacktrackDistanceLines(10)
-			.setBacktrackDistanceLinesSingleToken(15)
-			.setBackwardFactor(1)
-			.setForwardDistanceLines(5)
-			.setForwardFactor(0.4)
-			.setMaxNumberOfRecoverApplicationsLocal(5);		
-		fgSetting.checkAssertionsForSettings();
-		return fgSetting;
-	}
-
-	/**
-	 * Setting is used for error analysis to find out how well
-	 * a local approach performs, only modifications on a single line are explored. 
-	 * Search heuristic: try all recover-count = 1, 2, 3, ... branches on the failure (or other) line,
-	 * @return Setting that locally searches for a recover branch
-	 */
-	public static FineGrainedSetting createCursorLineSetting(){
-		FineGrainedSetting fgSetting = new FineGrainedSetting()
-			.setTimeLimit(250)
-			.setAcceptDistanceLines(5)
-			.setBacktrackDistanceLines(1)
-			.setBacktrackDistanceLinesSingleToken(1)
-			.setBackwardFactor(1)
-			.setForwardDistanceLines(1)
-			.setForwardFactor(1)
-			.setMaxNumberOfRecoverApplicationsLocal(2);
-		fgSetting.checkAssertionsForSettings();
-		return fgSetting;
-	}
-
-	/**
-	 * Setting is used for error analysis to find out how many files
-	 * can be recovered with a single token insertion/deletion/replacement 
-	 * Search heuristic: try all recover-count = 1 branches in the left context
-	 * @return Setting that globally searches for a single token recovery
-	 */
-	public static FineGrainedSetting createSingleTokenSetting(){
-		FineGrainedSetting fgSetting = new FineGrainedSetting()
-			.setTimeLimit(2000)
-			.setAcceptDistanceLines(5)
-			.setBacktrackDistanceLines(0)
-			.setBacktrackDistanceLinesSingleToken(25)
-			.setBackwardFactor(2)
-			.setForwardDistanceLines(0)
-			.setForwardFactor(0)
-			.setMaxNumberOfRecoverApplicationsLocal(1);
-		fgSetting.checkAssertionsForSettings();
-		return fgSetting;
-	}
-
-	/**
-	 * Setting is used for error analysis, to find out
-	 * how many recover actions are required to recover from an error.
-	 * Search heuristic: regionally try all recover-count = 1 branches,
-	 * then continue with recover-count = 2, and so on. 
-	 * @return Setting that globally searches for a recover branch 
-	 * by modifying the left and right context
-	 */
-	public static FineGrainedSetting createMultipleTokensSetting(){
-		FineGrainedSetting fgSetting = new FineGrainedSetting()
-			.setTimeLimit(2000)
-			.setAcceptDistanceLines(5)
-			.setBacktrackDistanceLines(20)
-			.setBacktrackDistanceLinesSingleToken(20)
-			.setBackwardFactor(4)
-			.setForwardDistanceLines(20)
-			.setForwardFactor(4)
-			.setMaxNumberOfRecoverApplicationsLocal(8);
-		fgSetting.checkAssertionsForSettings();
-		return fgSetting;
-	}
-
-	/**
-	 * Setting is used for error analysis to find out how well
-	 * a local approach performs, only modifications on a single line are explored. 
-	 * Search heuristic: try all recover-count = 1, 2, 3, ... branches on the failure (or other) line,
-	 * @return Setting that locally searches for a recover branch
-	 */
-	public static FineGrainedSetting createLocalContextSetting(){
-		FineGrainedSetting fgSetting = new FineGrainedSetting()
-			.setTimeLimit(2500)
-			.setAcceptDistanceLines(5)
-			.setBacktrackDistanceLines(0)
-			.setBacktrackDistanceLinesSingleToken(0)
-			.setBackwardFactor(0)
-			.setForwardDistanceLines(0)
-			.setForwardFactor(0)
-			.setMaxNumberOfRecoverApplicationsLocal(10);
-		fgSetting.checkAssertionsForSettings();
-		return fgSetting;
-	}
-
-	/**
-	 * Setting is used for error analysis to find out how 
-	 * well a left context approach performs, only modifications at the (inclusive) 
-	 * left of the error location are explored 
-	 * Search heuristic: find recover branches at the left of the failure location using an expanding search space
-	 * @return Setting that searches for a recover branch by modifying the left context
-	 */
-	public static FineGrainedSetting createLeftContextSetting(){
-		FineGrainedSetting fgSetting = new FineGrainedSetting()
-			.setTimeLimit(2500)
-			.setAcceptDistanceLines(5)
-			.setBacktrackDistanceLines(20)
-			.setBacktrackDistanceLinesSingleToken(80)
-			.setBackwardFactor(1)
-			.setForwardDistanceLines(0)
-			.setForwardFactor(0)
-			.setMaxNumberOfRecoverApplicationsLocal(6);
-		fgSetting.checkAssertionsForSettings();
-		return fgSetting;
-	}
-
-	/**
-	 * Setting is used for error analysis to find out how 
-	 * well a right context approach performs, only modifications at the (inclusive) 
-	 * right of the error location are explored 
-	 * Search heuristic: find recover branches at the right of the failure location using an expanding search space
-	 * @return Setting that searches for a recover branch by modifying the right context
-	 */
-	public static FineGrainedSetting createRightContextSetting(){
-		FineGrainedSetting fgSetting = new FineGrainedSetting()
-			.setTimeLimit(2500)
-			.setAcceptDistanceLines(5)
-			.setBacktrackDistanceLines(0)
-			.setBacktrackDistanceLinesSingleToken(0)
-			.setBackwardFactor(0)
-			.setForwardDistanceLines(Integer.MAX_VALUE)
-			.setForwardFactor(1)
-			.setMaxNumberOfRecoverApplicationsLocal(6);
-		fgSetting.checkAssertionsForSettings();
-		return fgSetting;
-	}
-	
-	private void checkAssertionsForSettings() {
-    	assert(timeLimit > 0);
-    	assert(acceptDistanceLines > 0);
-    	assert(backtrackDistanceLines <= backtrackDistanceLinesSingleToken);
-    	assert(backwardFactor >= 0);
-    	assert(forwardFactor >= 0);
-    	assert(maxNumberOfRecoverApplicationsLocal >= 1);
-    	assert(maxNumberOfRecoverApplicationsLocal <= 10);
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Frame.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Frame.java
--- src/org/spoofax/jsglr/client/Frame.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Frame.java	2012-09-28 00:32:16.000000000 +0200
@@ -1,22 +1,23 @@
 /*
  * Created on 04.des.2005
  *
- * Copyright (c) 2005-2011, Karl Trygve Kalleberg <karltk near strategoxt dot org>
- *
+ * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
+ * 
  * Licensed under the GNU Lesser General Public License, v2.1
  */
 package org.spoofax.jsglr.client;
 
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.List;
 
 import org.spoofax.jsglr.shared.Tools;
 
 
 public class Frame implements Serializable {
-
+    
     private static final long serialVersionUID = -4757644376472129935L;
-
+            
     public static int framesCreated =0; //MJ: for testing
 
     public final State state;
@@ -24,12 +25,12 @@
     // Using a Vector and regular iteration takes parsing of file-test from 1100ms (min) to 2020ms (max)!
     // TODO: Just use an ArrayList for Frame.steps?
     //       which should have better performance than the obsolete, synchronized Vector classs
-
-
+    
+    
 
     private Link[] steps;
     private int stepsCount;
-
+    
     // FIXME: All frames except the root must have a step with a label
     // that goes to the parent frame. Should we enforce this in this
     // constructor?
@@ -37,15 +38,14 @@
         state = s;
         steps = new Link[20];
         stepsCount = 0;
-        framesCreated +=1; //MJ: for testing
-
+        framesCreated +=1; //MJ: for testing 
     }
 
     public boolean allLinksRejected() {
         if(Tools.tracing) {
             SGLR.TRACE("SG_Rejected() - " + state.stateNumber);
         }
-
+        
         if (stepsCount == 0)
             return false;
 
@@ -60,12 +60,26 @@
     public State peek() {
         return state;
     }
+    
+    public Link peekLink() {
+      if (stepsCount == 0)
+        return null;
+      return steps[0];
+  }
+
+  public Link[] peekLinks() {
+    return steps;
+  }
 
-    public void findAllPaths(PooledPathList pool, int arity) {
+    
+    public void findAllPaths(PooledPathList pool, int arity) throws InterruptedException {
     	doComputePathsToRoot(pool, null, arity, 0, 0);
     }
 
-    private void doComputePathsToRoot(PooledPathList pool, Path node, int arity, int parentCount, int length) {
+    private void doComputePathsToRoot(PooledPathList pool, Path node, int arity, int parentCount, int length) throws InterruptedException {
+        
+      if (Thread.currentThread().isInterrupted())
+        throw new InterruptedException();
 
     	if(Tools.tracing) {
             SGLR.TRACE("SG_FindAllPaths() - " + arity + ", " + length);
@@ -76,10 +90,10 @@
             if(Tools.tracing) {
                 SGLR.TRACE("SG_NewPath() - " + state.stateNumber + ", " + length);
             }
-        } else {
+        } else { 
             for (int i = 1; i <= stepsCount; i++) {
                 Link link = steps[stepsCount - i];
-
+                
                 Path n = pool.makePath(node, link, this, link.getLength(), parentCount);
                 link.parent.doComputePathsToRoot(pool, n, arity - 1, parentCount + 1, length + link.getLength());
             }
@@ -98,15 +112,15 @@
         if(Tools.tracing) {
             SGLR.TRACE("SG_FindDirectLink() - [" + state.stateNumber + ", " + st0.state.stateNumber + "]");
         }
-
+        
         for (int i = 0; i < stepsCount; i++) {
             if (steps[i].parent == st0)
                 return steps[i];
         }
-
+        
         return null;
-    }
-
+    }   
+    
     /**
      * @deprecated Use the primitive types (or an iterator) to just iterate over the links.
      */
@@ -114,24 +128,25 @@
         ArrayList<Link> links=new ArrayList<Link>();
         for (int i = 0; i < stepsCount; i++) {
             links.add(steps[i]);
-        }
+        }        
         return links;
-    }
-
+    }   
+    
 
 //    static public int[] counter = new int[1000];
-
-    public Link addLink(Frame st0, AbstractParseNode n, int length) {
+    
+    public Link addLink(Frame st0, AbstractParseNode n, int length, int line, int column) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_AddLink() - " + state.stateNumber + ", " + st0.state.stateNumber + ", " + length);
         }
         if(stepsCount >= steps.length) {
             resizeSteps();
         }
+        
 //        counter[stepsCount]++;
-        return steps[stepsCount++] = new Link(st0, n, length);
+        return steps[stepsCount++] = new Link(st0, n, length, line, column); 
     }
-
+    
     public Link addLink(Link ln) {
         if(Tools.tracing) {
             SGLR.TRACE("SG_AddLink() - " + state.stateNumber + " (recover node) ");
@@ -139,10 +154,11 @@
         if(stepsCount >= steps.length) {
             resizeSteps();
         }
+        
 //        counter[stepsCount]++;
-        return steps[stepsCount++] = ln;
+        return steps[stepsCount++] = ln; 
     }
-
+    
     private void resizeSteps() {
         // Resize the steps array (not necessary for most grammars).
         // (see steps field)
@@ -217,14 +233,14 @@
         return sb.toString();
     }
 
-    public void findLimitedPaths(PooledPathList pool, int arity, Link l) {
+    public void findLimitedPaths(PooledPathList pool, int arity, Link l) throws InterruptedException {
         if(Tools.tracing) {
             SGLR.TRACE("SG_FindLimitedPaths() - " + arity + ", " + l.getLength() + ", " + l.parent.state.stateNumber);
             TRACE_DumpLinks(steps);
         }
-        if(findLink(arity, l)) {
+        if(findLink(arity, l)) { 
             doComputePathsToRoot(pool, null, l, false, arity, 0, 0);
-        }
+        } 
     }
 
     private void TRACE_DumpLinks(Link[] st) {
@@ -241,7 +257,7 @@
             SGLR.TRACE("SG_FindLink() - " + arity);
             SGLR.TRACE("SG_ - links: " + stepsCount);
         }
-
+        
         if(arity > 0) {
             for(int i = 0; i < stepsCount; i++) {
                 Link l1 = steps[stepsCount - i - 1];
@@ -262,7 +278,10 @@
     }
 
     private void doComputePathsToRoot(PooledPathList pool, Path node, Link l,
-      boolean seen, int arity, int parentCount, int length) {
+      boolean seen, int arity, int parentCount, int length) throws InterruptedException {
+        if (Thread.currentThread().isInterrupted())
+          throw new InterruptedException();
+      
         if(Tools.tracing) {
             SGLR.TRACE("SG_FindPaths() - " + arity);
         }
@@ -293,21 +312,21 @@
             this.stepsCount = 0;
         }
     }
-
-    /*mj debug info function
+    
+    //mj debug info function
     public int minAvoidValue()
     {
         int result = 0;
         for (int i = 0; i < stepsCount; i++) {
             if(i==0){
-                result = steps[i].recoverWeight;
-            result = Math.min(result, steps[i].recoverWeight);
-            }
+                result = steps[i].recoverCount;
+            result = Math.min(result, steps[i].recoverCount);
+            }            
         }
         return result;
     }
-
-    //mj debug info function
+    
+  //mj debug info function
     public List<String> getStackPaths(String frontEnd, boolean avoidFree)
     {
         String front = this.state.stateNumber + frontEnd;
@@ -319,16 +338,16 @@
         for (int i = 0; i < stepsCount; i++) {
             Link ln = steps[i];
             List<String> childColl;
-            if(ln.recoverWeight ==0 || (avoidFree==false)) {
-                if(ln.recoverWeight ==0)
-                    childColl= ln.parent.getStackPaths(" - "+front, avoidFree);
+            if(ln.recoverCount ==0 || (avoidFree==false)) {
+                if(ln.recoverCount ==0)
+                    childColl= ln.parent.getStackPaths(" - "+front, avoidFree); 
                 else {
-                    String frnt = "-$"+ ln.recoverWeight +"$-" + front;
+                    String frnt = "-$"+ ln.recoverCount +"$-" + front;
                     childColl=ln.parent.getStackPaths(frnt, avoidFree);
                 }
                 stackStrings.addAll(childColl);
-            }
-        }
+            }            
+        }            
         return stackStrings;
     }
 
@@ -336,5 +355,5 @@
     public String[] getStackRepresentation(boolean avoidFree){
         List<String> stackStrings=this.getStackPaths("", avoidFree);
         return stackStrings.toArray(new String[stackStrings.size()]);
-    }*/
+    }
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/IRecoveryParser.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IRecoveryParser.java
--- src/org/spoofax/jsglr/client/IRecoveryParser.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IRecoveryParser.java	2012-09-28 00:32:16.000000000 +0200
@@ -1,5 +1,6 @@
 package org.spoofax.jsglr.client;
 
+
 public interface IRecoveryParser {
     IRecoveryResult recover(String text) throws Exception;
     IRecoveryResult recover(String text, String startSymbol) throws Exception;
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/IndentInfo.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentInfo.java
--- src/org/spoofax/jsglr/client/IndentInfo.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentInfo.java	2012-09-28 00:32:15.000000000 +0200
@@ -62,7 +62,7 @@
      */
     private PooledPathList indentPathCache = new PooledPathList(512, false);
     
-    public int maxReduceLength() {
+    public int maxReduceLength() throws InterruptedException {
         int maxPathLength = 0;
         for (Frame activeStack : stackNodes) {
         	indentPathCache.start();
@@ -83,12 +83,12 @@
     }    
     
     //Calculates the start position of the biggest reduce
-    public int structureStartPosition()
+    public int structureStartPosition() throws InterruptedException
     {
         return tokensSeen - maxReduceLength();        
     }
     
-    public Link getReductionLink() {
+    public Link getReductionLink() throws InterruptedException {
         int maxPathLength = -1;
         Link result=null;
         for (Frame activeStack : stackNodes) {
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/IndentTokenizer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentTokenizer.java
--- src/org/spoofax/jsglr/client/IndentTokenizer.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentTokenizer.java	2012-09-28 00:32:16.000000000 +0200
@@ -58,7 +58,7 @@
     /*
      * Recognizes an indent or dedent at the new line and tries to parse a indent-token or dedent-token
      */
-    public void handleIndentShifts(SGLR parser) throws IOException, ParseException
+    public void handleIndentShifts(SGLR parser) throws IOException, ParseException, InterruptedException
     {
         int curTok=parser.getCurrentToken();
         if(myIndentHandler.lineMarginEnded()){
@@ -70,7 +70,7 @@
     }    
 
     private void parseIndentation(SGLR parser) throws ParseException,
-            IOException {
+            IOException, InterruptedException {
         ArrayDeque<Frame> oldActiveStacks = parser.activeStacks;
         if(dedentCount > 0 && indentShift){
             //TODO: warnings?
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/IndentationHandler.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentationHandler.java
--- src/org/spoofax/jsglr/client/IndentationHandler.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentationHandler.java	2012-09-28 00:32:16.000000000 +0200
@@ -1,6 +1,7 @@
 package org.spoofax.jsglr.client;
 
 
+
 /*
  * Keeps up with indentation by inspecting characters
  * Use: inspect characters during parsing, or during the traversal of an ATerm
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/IntegratedRecoverySettings.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IntegratedRecoverySettings.java
--- src/org/spoofax/jsglr/client/IntegratedRecoverySettings.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IntegratedRecoverySettings.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-package org.spoofax.jsglr.client;
-
-public class IntegratedRecoverySettings {
-	private boolean useFineGrained;
-	private boolean useRegionSelection;
-	private boolean useRegionRecovery;
-	private boolean useCursorLocation;
-	private int maxNumberOfRecoverApplicationsGlobal; //branches with more then x recoveries are cut off (IS USED FOR ANALYSIS)
-	
-	public boolean useFineGrained() {
-		return useFineGrained;
-	}
-	public void setUseFineGrained(boolean useFineGrained) {
-		this.useFineGrained = useFineGrained;
-	}
-	public boolean useRegionSelection() {
-		return useRegionSelection;
-	}
-	public void setUseRegionSelection(boolean useRegionSelection) {
-		this.useRegionSelection = useRegionSelection;
-	}
-	public boolean useCursorLocation() {
-		return useCursorLocation;
-	}
-	public void setUseCursorLocation(boolean useCursorLocation) {
-		this.useCursorLocation = useCursorLocation;
-	}
-	public boolean useRegionRecovery() {
-		return useRegionRecovery;
-	}
-	public void setUseRegionRecovery(boolean useRegionRecovery) {
-		this.useRegionRecovery = useRegionRecovery;
-	}
-	
-	public int getMaxNumberOfRecoverApplicationsGlobal() {
-		return maxNumberOfRecoverApplicationsGlobal;
-	}
-
-	public void setMaxNumberOfRecoverApplicationsGlobal(
-			int maxNumberOfRecoverApplicationsGlobal) {
-		this.maxNumberOfRecoverApplicationsGlobal = maxNumberOfRecoverApplicationsGlobal;
-	}
-
-	
-	private IntegratedRecoverySettings(){
-		useFineGrained = true;
-		useRegionSelection = true;
-		useRegionRecovery = true;
-		useCursorLocation = true;
-		this.setMaxNumberOfRecoverApplicationsGlobal(Integer.MAX_VALUE);		
-	}
-	
-	public static IntegratedRecoverySettings createDefaultSettings(){
-		return new IntegratedRecoverySettings();
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Label.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Label.java
--- src/org/spoofax/jsglr/client/Label.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Label.java	2012-09-28 00:32:16.000000000 +0200
@@ -10,6 +10,8 @@
 import java.io.Serializable;
 
 import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.terms.Term;
 
 public class Label implements Serializable {
 
@@ -19,6 +21,8 @@
     /*package*/ final IStrategoAppl prod;
     private final ProductionAttributes productionAttributes;
     private final boolean injection;
+    private Boolean isLayout;
+    //private final boolean isNewlineEnforcer;
 
     public Label(int labelNumber, IStrategoAppl prod, ProductionAttributes productionAttributes, boolean injection) {
         this.labelNumber = labelNumber;
@@ -41,10 +45,6 @@
     public boolean isRecoverProduction() {
         return productionAttributes.isRecoverProduction();
     }
-    
-    public boolean isCompletionProduction() {
-        return productionAttributes.isCompletionProduction();
-    }
 
     public boolean isMoreEager(Label rightProd) {
         return productionAttributes.isMoreEager(rightProd.productionAttributes);
@@ -71,4 +71,40 @@
     public int hashCode() {
         return labelNumber;
     }
+
+    
+    
+    public boolean isLayout() {
+      if (isLayout != null)
+        return isLayout;
+      
+      IStrategoTerm t = prod.getSubterm(1);
+      
+      while (true) {
+        if (t.getTermType() != IStrategoTerm.APPL) {
+          isLayout = false;
+          break;
+        }
+        
+        IStrategoAppl app = (IStrategoAppl) t;
+        
+        if (Term.hasConstructor(app, "layout")) {
+          isLayout = true;
+          break;
+        }
+        
+        if (app.getSubtermCount() == 1 &&
+            (Term.hasConstructor(app, "cf") ||
+             Term.hasConstructor(app, "lex") ||
+             Term.hasConstructor(app, "opt") ||
+             Term.hasConstructor(app, "iter")))
+          t = app.getSubterm(0);
+        else {
+          isLayout = false;
+          break;
+        }
+      }
+      
+      return isLayout;
+    }
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Link.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Link.java
--- src/org/spoofax/jsglr/client/Link.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Link.java	2012-09-28 00:32:16.000000000 +0200
@@ -23,17 +23,19 @@
     
     public int length; //mj: private final (see sglr.reducer: replace link by link with less avoids)
     
-    public int recoverWeight; //Weighted count used for disambiguation: Deletions are more expensive then Insertions
-
-    public int recoverCount; //number of recover actions (used for cutting branches and error analysis)
+    private int line;
+    private int column;
+    
+    public int recoverCount;
 
-    public Link(Frame destination, AbstractParseNode t, int length) {
+    public Link(Frame destination, AbstractParseNode t, int length, int line, int column) {
         this.parent = destination;
         label = t;
         rejected = false;
         this.length = length;
-        recoverWeight =0;
-        recoverCount = 0;
+        this.line = line;
+        this.column = column;
+        recoverCount =0;
         linksCreated +=1;
     }
 
@@ -57,6 +59,14 @@
     public int getLength() {
         return length;
     }
+    
+    public int getLine() {
+      return line;
+    }
+
+    public int getColumn() {
+      return column;
+    }
 
     public void clear() {
         if(parent != null) {
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Measures.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Measures.java
--- src/org/spoofax/jsglr/client/Measures.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Measures.java	2012-09-28 00:32:16.000000000 +0200
@@ -1,5 +1,6 @@
 package org.spoofax.jsglr.client;
 
+
 /**
  * 
  * @author Emma Nilsson-Nyman <emma at cs.lth.se>
@@ -161,7 +162,7 @@
             proAvgParseTime = (int)Math.round((m.getAverageParseTime()*1.0/base.getAverageParseTime())*100);
             
             // Count
-            proParseCount = (int)Math.round((Measures.getParseCount()*1.0/Measures.getParseCount())*100);
+            proParseCount = (int)Math.round((m.getParseCount()*1.0/base.getParseCount())*100);
             proRedCount = (int)Math.round((m.getReductionCount()*1.0/base.getReductionCount())*100);
             proAvoidCount = (int)Math.round((m.getAvoidCount()*1.0/base.getAvoidCount())*100);
             
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/NewStructureSkipper.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/NewStructureSkipper.java
--- src/org/spoofax/jsglr/client/NewStructureSkipper.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/NewStructureSkipper.java	2012-09-28 00:32:15.000000000 +0200
@@ -241,9 +241,9 @@
             }
             indexEnd++;
         }         
-        if(indexStart<0 || indexEnd > getHistory().getIndexLastLine())
-            return prevRegions;
         IndentInfo endSkip=IndentInfo.cloneIndentInfo(getHistory().getLine(indexEnd));
+        if(indexStart<0)
+            return prevRegions;
         IndentInfo startSkip=IndentInfo.cloneIndentInfo(getHistory().getLine(indexStart));
         StructureSkipSuggestion previousRegion=new StructureSkipSuggestion();
         previousRegion.setSkipLocations(startSkip, endSkip, indexStart, indexEnd);
@@ -406,8 +406,9 @@
     
     private int findParentBegin(int startLineIndex) {
         int indentStartLine=separatorIndent(startLineIndex); 
-        int indexHistoryLines=startLineIndex-1;
+        int indexHistoryLines=startLineIndex;
         while(indexHistoryLines > 0){
+            indexHistoryLines-=1;            
             int indentSkipPosition=separatorIndent(indexHistoryLines); //currentLine.getIndentValue();
             indentShift shift=calculateShift(indentStartLine, indentSkipPosition);
             if (shift==indentShift.DEDENT){
@@ -420,7 +421,6 @@
                 }                
                 return indexHistoryLines;
             }            
-            indexHistoryLines-=1;            
         }        
         return 0; //SOF
     }
@@ -454,7 +454,7 @@
     private String readLine(int index) {
         while(getHistory().getIndexLastLine()<=index && myParser.getCurrentToken()!=SGLR.EOF)
             getHistory().readRecoverToken(myParser, false);
-        if(0 <= index && index<=getHistory().getIndexLastLine()){
+        if(index<=getHistory().getIndexLastLine()){
             IndentInfo line=getHistory().getLine(index);
             return readLine(line);
         }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/ParseNode.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseNode.java
--- src/org/spoofax/jsglr/client/ParseNode.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseNode.java	2012-09-28 00:32:16.000000000 +0200
@@ -1,4 +1,5 @@
 /*
+
  * Created on 30.mar.2006
  *
  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
@@ -18,325 +19,404 @@
 import org.spoofax.terms.TermFactory;
 
 public class ParseNode extends AbstractParseNode {
-	
-	private static final int AMB_LABEL = -1;
 
-    private int label;
+  private static final int AMB_LABEL = -1;
 
-    AbstractParseNode[] kids;
-    
-    private boolean isParseProductionChain; //should be set only after parsing 
+  private int label;
 
-    private boolean isSetPPC;
-    
-    private int nodeType;
+  AbstractParseNode[] kids;
 
-    private int cachedHashCode; //should be set only after parsing 
+  private boolean isParseProductionChain; // should be set only after parsing
 
-    @Override
-	public int getLabel() {
-    	if(isAmbNode() || label == AMB_LABEL)
-    		throw new UnsupportedOperationException();
-    	return label;
-    }
-
-    public ParseNode(int label, AbstractParseNode[] kids, int type) {
-    	setFields(label, kids, type);
-    	if(type == AbstractParseNode.AMBIGUITY){
-        	this.isParseProductionChain=false;
-        	this.isSetPPC=true;
-        	assert this.label == AMB_LABEL;
-    	}
-    }
-    
-    public static ParseNode createAmbNode(AbstractParseNode... kids){
-    	ParseNode amb = new ParseNode(AMB_LABEL, kids, AbstractParseNode.AMBIGUITY);
-    	return amb;
-    }
-
-	private void setFields(int label, AbstractParseNode[] kids, int type) {
-		assert (type!=AbstractParseNode.AMBIGUITY || (label==AMB_LABEL));
-		this.nodeType = type;
-        this.label = label;
-        this.kids = kids;
-        this.isParseProductionChain = false;
-        this.isSetPPC=false;
- 	}
-	
-	@Override
-	public void reject() {
-		// FIXME: this might not work if the current node is an AMB
-		nodeType = REJECT;
-	}
-	
-	public void makeAmbiguity(AbstractParseNode pn){
-		//if (isAmbNode()) {
-		//	if (isInAmbiguityCluster(pn)) return;
-		//	AbstractParseNode[] newKids = new AbstractParseNode[kids.length + 1];
-		//	System.arraycopy(kids, 0, newKids, 0, kids.length);
-		//	newKids[newKids.length - 1] = pn;
-		//	kids = newKids;
-		//
-		//	if(pn instanceof ParseNode)
-		//		((ParseNode) pn).replaceCycle(this, null);
-		//} else {
-			if (this == pn || (isAmbNode() && isInAmbiguityCluster(pn)))
-				return;
-			ParseNode left = new ParseNode(this.label, this.kids, this.nodeType); 
-			setFields(AMB_LABEL, new AbstractParseNode[] { left, pn }, AbstractParseNode.AMBIGUITY);
-
-			if(pn instanceof ParseNode)
-				((ParseNode) pn).replaceCycle(this, left);
-		//}
-		
-		assert(this.cachedHashCode == NO_HASH_CODE) : "Hashcode should not be cached during parsing because descendant nodes may change";
-		assert(!this.isParseProductionChain) : "PPC is not set to true during parsing because descendents may change";
-	}
-
-	private boolean isInAmbiguityCluster(AbstractParseNode pn) {
-		for (AbstractParseNode existing : kids) {
-			if (pn == existing) {
-				return true;
-			} else if (existing.isAmbNode()) {
-				if (((ParseNode) existing).isInAmbiguityCluster(pn))
-					return true;
-			}
-		}
-		return false;
-	}
-	
-	private void replaceCycle(ParseNode before, ParseNode after) {
-		//only reductions for current char (right chain) are inspected
-		// XXX: is that assumption correct? what about epsylon productions that consume no chars?
-		if(isAmbNode()) { // all kids relate to current char
-			for (int i = 0; i < kids.length; i++)
-				replaceDescendantAt(before, after, i);			
-		} else if(kids.length > 0 ){ 
-			replaceDescendantAt(before, after, kids.length-1);			
-		}
-	}
-
-	private void replaceDescendantAt(ParseNode before, ParseNode after, int index) {
-		AbstractParseNode kid = kids[index];
-		if(kid==before){
-			kids[index] = after == null ? new CycleParseNode(before) : after; 
-			return; //no further inspection needed since cycles should not occur
-		}
-		else if(kid instanceof ParseNode){
-			((ParseNode)kid).replaceCycle(before, after);
-		}
-	}
-	    
-    @Override
-	public boolean isParseProductionChain() {
-    	//REMARK: works because PPC property is not set during parsing, so descendants will not change
-		// assert isParseProductionChain == calculateIsParseProdChain(kids);
-    	if(!isSetPPC)
-    		initParseProductionChain();
-		return isParseProductionChain;
-	}
-    
-    /**
-     * Initialize the {@link #isParseProductionChain} method
-     * for this node and any candidate chain nodes below it,
-     * without using recursion (which would potentially
-     * lead to a stack overflow).
-     */
-    private void initParseProductionChain() {
-    	AbstractParseNode deepest = getDeepestNonChainNode();
-    	if (deepest == this) { // fast path
-    		isSetPPC = true;
-    		isParseProductionChain = false;
-    	} else {
-    		setParseProductionChainUpTo(deepest == null, deepest);
-    	}
-    }
-	
-	/**
-	 * Find the deepest parse node that is clearly not a 
-	 * parse production chain node.
-	 *
-	 * @see #isParseProductionChain
-	 */
-    private AbstractParseNode getDeepestNonChainNode() {
-		AbstractParseNode current = this;
-		for (;;) {
-			AbstractParseNode[] kids = current.getChildren();
-			switch (kids.length) {
-				case 2:
-					if (current instanceof ParseNode) {
-						if (((ParseNode) current).isSetPPC)
-							return current.isParseProductionChain() ? null : current;
-					}
-					if (!kids[0].isParseProductionNode())
-						return kids[0];
-					current = kids[1]; 
-					break;
-				case 1:
-					current = kids[0];
-					break;
-				case 0:
-					return current.isParseProductionNode() ? null : current;
-				default:
-					return current;
-			}
-		}
-	}
-	
-	private void setParseProductionChainUpTo(boolean value, AbstractParseNode end) {
-		AbstractParseNode current = this;
-		AbstractParseNode next = this;
-		do {
-			current = next;
-			ParseNode parseCurrent = null;
-			if (current instanceof ParseNode)
-				parseCurrent = (ParseNode) current;
-			if (parseCurrent == null) {
-				assert current.isCycle() || current.isParseProductionNode();
-				return;
-			}
-			parseCurrent.isParseProductionChain = value;
-			parseCurrent.isSetPPC = true;
-			AbstractParseNode[] kids = parseCurrent.kids;
-			switch (kids.length) {
-				case 2:
-					next = kids[1];
-					break;
-				case 1:
-					next = kids[0];
-					break;
-				default:
-					return;
-			}
-		} while (current != end);
-	}
-
-	@Override 
-    public Object toTreeTopdown(TopdownTreeBuilder builder) {
-    	if(isAmbNode())
-        	return builder.buildTreeAmb(this);
-    	return builder.buildTreeNode(this);
-    }
-
-    //TODO: refactor
-    @Override 
-	public Object toTreeBottomup(BottomupTreeBuilder builder) {
-    	if(isAmbNode()){
-    		return toTreeBottomupAmb(builder);
-    	}
-    	builder.visitLabel(label);
-        ArrayList<Object> subtrees = new ArrayList<Object>(kids.length);
-        for (int i = 0; i < kids.length; i++) {
-        	subtrees.add(kids[i].toTreeBottomup(builder));
-        }
+  private boolean isSetPPC;
 
-        Object result = builder.buildNode(label, subtrees);
-        builder.endVisitLabel(label);
-		return result;
-    }
-    
-	
-	public Object toTreeBottomupAmb(BottomupTreeBuilder builder) {
-    	ArrayList<Object> collect = new ArrayList<Object>();
-    	addToTreeAmb(builder, collect);
-    	return builder.buildAmb(collect);
-    }
-        
-    private void addToTreeAmb(BottomupTreeBuilder builder, List<Object> collect) {
-    	for (int i = kids.length - 1; i >= 0; i--) {
-    		AbstractParseNode alt = kids[i];
-    		if (alt.isAmbNode()) {
-    			((ParseNode) alt).addToTreeAmb(builder, collect);
-    		} else {
-    			collect.add(alt.toTreeBottomup(builder));
-    		}
-    	}
-    }
-
-    /**
-     * todo: stolen from TAFReader; move elsewhere
-     */
-    public static IStrategoList makeList(TermFactory factory, List<IStrategoTerm> terms) {
-        IStrategoList result = factory.makeList();
-        for (int i = terms.size() - 1; i >= 0; i--) {
-        	result = factory.makeListCons(terms.get(i), result);
-        }
-        return result;
+  private int nodeType;
+
+  private int cachedHashCode; // should be set only after parsing
+  
+  private AbstractParseNode left;
+  
+  private final boolean isLayout;
+  private final boolean isIgnoreLayout;
+
+  @Override
+  public int getLabel() {
+    return label;
+  }
+
+  public ParseNode(int label, AbstractParseNode[] kids, int type, int line, int column, boolean isLayout, boolean isIgnoreLayout) {
+    super(line, column);
+    this.isLayout = isLayout;
+    this.isIgnoreLayout = isIgnoreLayout;
+    setFields(label, kids, type);
+    if (type == AbstractParseNode.AMBIGUITY) {
+      this.isParseProductionChain = false;
+      this.isSetPPC = true;
+      assert this.label == AMB_LABEL;
     }
+  }
 
-    @Override
-    public String toString() {
-    	switch (nodeType) {
-		case AbstractParseNode.AMBIGUITY:
-    		return "amb(" + Arrays.toString(kids) + ")";
-		case AbstractParseNode.PARSENODE:
-	        return "regular(aprod(" + label + ")," + Arrays.toString(kids) + ")";
-		case AbstractParseNode.AVOID:
-			return "avoid(" + getLabel() + "," + kids + ")";
-		case AbstractParseNode.PREFER:
-			return "prefer(" + getLabel() + "," + kids + ")";
-		case AbstractParseNode.REJECT:
-		    return "reject(" + getLabel() + "," + kids + ")";
-		default:
-			throw new NotImplementedException();
-		}
-    }
-
-	@Override
-	public int getNodeType() {
-		return nodeType;
-	}
-
-    @Override
-    public AbstractParseNode[] getChildren() {
-		return kids;
-	}
-    
-    @Override
-    public boolean equals(Object obj) {
-        if(!(obj instanceof ParseNode))
-            return false;
-        if (obj == this)
-            return true;
-        final ParseNode o = (ParseNode)obj;
-        if (getNodeType() != o.getNodeType() || 
-        	label != o.label || 
-        	kids.length != o.kids.length || 
-        	hashCode() != o.hashCode())
-            return false;
-        for(int i = 0; i < kids.length; i++) {
-            if(!kids[i].equals(o.kids[i]))
-                return false;
-        }
-        return true;
+  public static ParseNode createAmbNode(AbstractParseNode... kids) {
+    assert kids.length > 0;
+
+    int line = kids[0].getLine();
+    int column = kids[0].getColumn();
+
+    for (int i = 1; i < kids.length; i++) {
+      assert kids[i].getLine() == line;
+      assert kids[i].getColumn() == column;
     }
 
-    @Override
-    public int hashCode() {
-        if (cachedHashCode != NO_HASH_CODE)
-            return cachedHashCode;
-        final int prime = 31;
-        int result = prime * label;
-        for(AbstractParseNode n : kids)
-            result += (prime * n.hashCode());
-        cachedHashCode = result; //Assumption is that hashcode is not set during parsing
-        return result;
-    }
-
-    @Override
-    public String toStringShallow() {
-    	if (isAmbNode())
-    		return "Amb";
-        return "regular*(" + label + ", {" +  kids.length + "})";
-    }
-	
-    /*
-	private void log(){
-		System.out.println(this.toStringShallow());
-		for (int i = 0; i < kids.length; i++) {
-			if(kids[i].isParseNode() || kids[i].isAmbNode())
-				((ParseNode)kids[i]).log();			
-		}
-	}*/
+    ParseNode amb = new ParseNode(AMB_LABEL, kids, AbstractParseNode.AMBIGUITY, line, column, kids[0].isLayout(), kids[0].isIgnoreLayout());
+    return amb;
+  }
 
+  private void setFields(int label, AbstractParseNode[] kids, int type) {
+    assert (type != AbstractParseNode.AMBIGUITY || (label == AMB_LABEL));
+    this.nodeType = type;
+    this.label = label;
+    this.kids = kids;
+    this.isParseProductionChain = false;
+    this.isSetPPC = false;
+    
+    for (AbstractParseNode kid : kids)
+      if (!kid.isLayout() && !kid.isEmpty() && !kid.isIgnoreLayout()) {
+        if (kid.getLine() > getLine() && (left == null || kid.getColumn() < left.getColumn()))
+          left = kid;
+        AbstractParseNode kidLeft = kid.getLeft();
+        if (kidLeft != null && 
+            kidLeft.getLine() > getLine() &&
+            (left == null || kidLeft.getColumn() < left.getColumn()))
+          left = kidLeft;
+      }
+
+  }
+
+  @Override
+  public void reject() {
+    // FIXME: this might not work if the current node is an AMB
+    nodeType = REJECT;
+  }
+
+  public void makeAmbiguity(AbstractParseNode pn) {
+    // if (isAmbNode()) {
+    // if (isInAmbiguityCluster(pn)) return;
+    // AbstractParseNode[] newKids = new AbstractParseNode[kids.length + 1];
+    // System.arraycopy(kids, 0, newKids, 0, kids.length);
+    // newKids[newKids.length - 1] = pn;
+    // kids = newKids;
+    //
+    // if(pn instanceof ParseNode)
+    // ((ParseNode) pn).replaceCycle(this, null);
+    // } else {
+    if (this == pn || (isAmbNode() && isInAmbiguityCluster(pn)))
+      return;
+
+    assert getLine() == pn.getLine();
+    assert getColumn() == pn.getColumn();
+
+    ParseNode left = new ParseNode(this.label, this.kids, this.nodeType, getLine(), getColumn(), isLayout, isIgnoreLayout);
+
+    if (pn instanceof ParseNode)
+      ((ParseNode) pn).replaceCycle(this, left);
+
+    setFields(AMB_LABEL, new AbstractParseNode[] { left, pn }, AbstractParseNode.AMBIGUITY);
+
+
+    assert (this.cachedHashCode == NO_HASH_CODE) : "Hashcode should not be cached during parsing because descendant nodes may change";
+    assert (!this.isParseProductionChain) : "PPC is not set to true during parsing because descendents may change";
+  }
+
+  /**
+   * Transforms this ambuguity node into a non-ambiguous node by selecting either the left or right child.
+   * 
+   * @param n the left or right child.
+   */
+  public void disambiguate(AbstractParseNode n) {
+    assert isAmbNode();
+    assert n.isParseNode();
+    assert getChildren().length == 2 && (n == getChildren()[0] || n == getChildren()[1]);
+    
+    setFields(n.isAmbNode() ? AMB_LABEL : n.getLabel(), n.getChildren(), n.getNodeType()) ;
+    cachedHashCode = NO_HASH_CODE;
+  }
+  
+  private boolean isInAmbiguityCluster(AbstractParseNode pn) {
+    for (AbstractParseNode existing : kids) {
+      if (pn == existing) {
+        return true;
+      } else if (existing.isAmbNode()) {
+        if (((ParseNode) existing).isInAmbiguityCluster(pn))
+          return true;
+      }
+    }
+    return false;
+  }
+
+  private void replaceCycle(ParseNode before, ParseNode after) {
+    assert after != null;
+
+    // only reductions for current char (right chain) are inspected
+    // XXX: is that assumption correct? what about epsylon productions that
+    // consume no chars?
+    if (isAmbNode()) { // all kids relate to current char
+      for (int i = 0; i < kids.length; i++)
+        replaceDescendantAt(before, after, i);
+    } else if (kids.length > 0) {
+      replaceDescendantAt(before, after, kids.length - 1);
+    }
+  }
+
+  private void replaceDescendantAt(ParseNode before, ParseNode after, int index) {
+    AbstractParseNode kid = kids[index];
+    if (kid == before) {
+      kids[index] = after;
+      return; // no further inspection needed since cycles should not occur
+    } else if (kid instanceof ParseNode && kid.getLine() == getLine() && kid.getColumn() == getColumn()) {
+      ((ParseNode) kid).replaceCycle(before, after);
+    }
+  }
+
+  @Override
+  public boolean isParseProductionChain() {
+    // REMARK: works because PPC property is not set during parsing, so
+    // descendants will not change
+    // assert isParseProductionChain == calculateIsParseProdChain(kids);
+    if (!isSetPPC)
+      initParseProductionChain();
+    return isParseProductionChain;
+//    return false;
+  }
+
+  /**
+   * Initialize the {@link #isParseProductionChain} method for this node and any
+   * candidate chain nodes below it, without using recursion (which would
+   * potentially lead to a stack overflow).
+   */
+  private void initParseProductionChain() {
+    AbstractParseNode deepest = getDeepestNonChainNode();
+    if (deepest == this) { // fast path
+      isSetPPC = true;
+      isParseProductionChain = false;
+    } else {
+      setParseProductionChainUpTo(deepest == null, deepest);
+    }
+  }
+
+  /**
+   * Find the deepest parse node that is clearly not a parse production chain
+   * node.
+   * 
+   * @see #isParseProductionChain
+   */
+  private AbstractParseNode getDeepestNonChainNode() {
+    AbstractParseNode current = this;
+    for (;;) {
+      AbstractParseNode[] kids = current.getChildren();
+      switch (kids.length) {
+      case 2:
+        if (current instanceof ParseNode) {
+          if (((ParseNode) current).isSetPPC)
+            return current.isParseProductionChain() ? null : current;
+        }
+        if (!kids[0].isParseProductionNode())
+          return kids[0];
+        current = kids[1];
+        break;
+      case 1:
+        current = kids[0];
+        break;
+      case 0:
+        return current.isParseProductionNode() ? null : current;
+      default:
+        return current;
+      }
+    }
+  }
+
+  private void setParseProductionChainUpTo(boolean value, AbstractParseNode end) {
+    AbstractParseNode current = this;
+    AbstractParseNode next = this;
+    do {
+      current = next;
+      ParseNode parseCurrent = null;
+      if (current instanceof ParseNode)
+        parseCurrent = (ParseNode) current;
+      if (parseCurrent == null) {
+        assert current.isCycle() || current.isParseProductionNode();
+        return;
+      }
+      parseCurrent.isParseProductionChain = value;
+      parseCurrent.isSetPPC = true;
+      AbstractParseNode[] kids = parseCurrent.kids;
+      switch (kids.length) {
+      case 2:
+        next = kids[1];
+        break;
+      case 1:
+        next = kids[0];
+        break;
+      default:
+        return;
+      }
+    } while (current != end);
+  }
+
+  // TODO: refactor
+  @Override
+  public Object toTreeBottomup(BottomupTreeBuilder builder) {
+    if (isAmbNode()) {
+      return toTreeBottomupAmb(builder);
+    }
+    builder.visitLabel(label);
+    ArrayList<Object> subtrees = new ArrayList<Object>(kids.length);
+    for (int i = 0; i < kids.length; i++) {
+      subtrees.add(kids[i].toTreeBottomup(builder));
+    }
+
+    Object result = builder.buildNode(label, subtrees);
+    builder.endVisitLabel(label);
+    return result;
+  }
+
+  public Object toTreeBottomupAmb(BottomupTreeBuilder builder) {
+    ArrayList<Object> collect = new ArrayList<Object>();
+    addToTreeAmb(builder, collect);
+    return builder.buildAmb(collect);
+  }
+  
+  @Override 
+  public Object toTreeTopdown(TopdownTreeBuilder builder) {
+    if(isAmbNode())
+        return builder.buildTreeAmb(this);
+    return builder.buildTreeNode(this);
+  }
+
+
+  private void addToTreeAmb(BottomupTreeBuilder builder, List<Object> collect) {
+    for (int i = kids.length - 1; i >= 0; i--) {
+      AbstractParseNode alt = kids[i];
+      if (alt.isAmbNode()) {
+        ((ParseNode) alt).addToTreeAmb(builder, collect);
+      } else {
+        collect.add(alt.toTreeBottomup(builder));
+      }
+    }
+  }
+
+  /**
+   * todo: stolen from TAFReader; move elsewhere
+   */
+  public static IStrategoList makeList(TermFactory factory,
+      List<IStrategoTerm> terms) {
+    IStrategoList result = factory.makeList();
+    for (int i = terms.size() - 1; i >= 0; i--) {
+      result = factory.makeListCons(terms.get(i), result);
+    }
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    switch (nodeType) {
+    case AbstractParseNode.AMBIGUITY:
+      return "amb(" + Arrays.toString(kids) + ")";
+    case AbstractParseNode.PARSENODE:
+      return "regular(aprod(" + label + ")," + Arrays.toString(kids) + ")";
+    case AbstractParseNode.AVOID:
+      return "avoid(" + getLabel() + "," + Arrays.toString(kids) + ")";
+    case AbstractParseNode.PREFER:
+      return "prefer(" + getLabel() + "," + Arrays.toString(kids) + ")";
+    case AbstractParseNode.REJECT:
+      return "reject(" + getLabel() + "," + Arrays.toString(kids) + ")";
+    default:
+      throw new NotImplementedException();
+    }
+  }
+
+  @Override
+  public int getNodeType() {
+    return nodeType;
+  }
+
+  @Override
+  public AbstractParseNode[] getChildren() {
+    return kids;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (!(obj instanceof ParseNode) || !super.equals(obj))
+      return false;
+    if (obj == this)
+      return true;
+    final ParseNode o = (ParseNode) obj;
+    if (getNodeType() != o.getNodeType() || label != o.label
+        || kids.length != o.kids.length || hashCode() != o.hashCode())
+      return false;
+    for (int i = 0; i < kids.length; i++) {
+      if (!kids[i].equals(o.kids[i]))
+        return false;
+    }
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    if (cachedHashCode != NO_HASH_CODE)
+      return cachedHashCode;
+    final int prime = 31;
+    int result = prime * label;
+    for (AbstractParseNode n : kids)
+      result += (prime * n.hashCode());
+    cachedHashCode = result; // Assumption is that hashcode is not set during
+                             // parsing
+    return result;
+  }
+
+  @Override
+  public String toStringShallow() {
+    if (isAmbNode())
+      return "Amb";
+    return "regular*(" + label + ", {" + kids.length + "})";
+  }
+
+  private Boolean isEmpty;
+
+  @Override
+  public boolean isEmpty() {
+    if (isEmpty != null)
+      return isEmpty;
+
+    isEmpty = true;
+
+    for (AbstractParseNode kid : kids)
+      if (!kid.isEmpty()) {
+        isEmpty = false;
+        break;
+      }
+
+    return isEmpty;
+  }
+
+  @Override
+  public AbstractParseNode getLeft() {
+    return left;
+  }
+  
+  @Override
+  public boolean isLayout() {
+    return isLayout;
+  }
+
+  @Override
+  public boolean isIgnoreLayout() {
+    return isIgnoreLayout;
+  }
+  
+  /*
+   * private void log(){ System.out.println(this.toStringShallow()); for (int i
+   * = 0; i < kids.length; i++) { if(kids[i].isParseNode() ||
+   * kids[i].isAmbNode()) ((ParseNode)kids[i]).log(); } }
+   */
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/ParseProductionNode.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseProductionNode.java
--- src/org/spoofax/jsglr/client/ParseProductionNode.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseProductionNode.java	2012-09-28 00:32:16.000000000 +0200
@@ -10,6 +10,7 @@
 import org.spoofax.jsglr.client.imploder.TopdownTreeBuilder;
 
 
+
 public class ParseProductionNode extends AbstractParseNode {
 
 	private static final AbstractParseNode[] NO_CHILDREN =
@@ -17,7 +18,8 @@
 
 	public final int prod;
 
-    public ParseProductionNode(int prod) {
+    public ParseProductionNode(int prod, int line, int column) {
+      super(line, column);
         this.prod = prod;
     }
     
@@ -32,32 +34,34 @@
     }
 
     @Override
-	public Object toTreeBottomup(BottomupTreeBuilder builder) {
+    public Object toTreeBottomup(BottomupTreeBuilder builder) {
     	return builder.buildProduction(prod);
     }
     
     @Override
     public Object toTreeTopdown(TopdownTreeBuilder builder) {
-    	return builder.buildTreeProduction(this);
+      return builder.buildTreeProduction(this);
     }
 
+    
     @Override
     public String toString() {
-        return "" + prod;
+        return "\"" + prod + (prod >= 32 ? (":" + (char) prod) : "").replace("\"", "\\\"") + "\"";
     }
 
-    public int getProduction() { return prod; }
+    @Override
+    public int getLabel() { return prod; }
 
     @Override
     public boolean equals(Object obj) {
-        if(!(obj instanceof ParseProductionNode))
+        if(!(obj instanceof ParseProductionNode) ||!super.equals(obj))
             return false;
         return prod == ((ParseProductionNode)obj).prod;
     }
 
     @Override
     public int hashCode() {
-        return 6359 * prod;
+        return 6359 * prod + super.hashCode();
     }
 
     @Override
@@ -74,9 +78,24 @@
 	public AbstractParseNode[] getChildren() {
 		return NO_CHILDREN;
 	}
-	
-    @Override
-	public int getLabel() {
-    	return prod;
-    }
+
+  @Override
+  public boolean isEmpty() {
+    return false;
+  }
+  
+  @Override
+  public AbstractParseNode getLeft() {
+    return this;
+  }
+  
+  @Override
+  public boolean isLayout() {
+    return false;
+  }
+
+  @Override
+  public boolean isIgnoreLayout() {
+    return false;
+  }
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/ParseTable.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseTable.java
--- src/org/spoofax/jsglr/client/ParseTable.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseTable.java	2012-09-28 00:32:15.000000000 +0200
@@ -15,10 +15,13 @@
 import static org.spoofax.terms.Term.javaInt;
 import static org.spoofax.terms.Term.termAt;
 
+import java.io.IOException;
+import java.io.InputStream;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
@@ -29,6 +32,11 @@
 import org.spoofax.interpreter.terms.IStrategoNamed;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.jsglr.client.imploder.TreeBuilder;
+import org.spoofax.jsglr.io.ParseTableManager;
+import org.spoofax.jsglr.io.SGLR;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.terms.ParseError;
 import org.spoofax.terms.Term;
 import org.spoofax.terms.TermFactory;
 
@@ -48,6 +56,8 @@
     public static final int LABEL_BASE = NUM_CHARS + 1;
     
     private static final long serialVersionUID = -3372429249660900093L;
+    
+    private static SGLR layoutParser;
 
     private State[] states;
 
@@ -74,7 +84,7 @@
     transient public IStrategoConstructor ambIStrategoConstructor;
 
     private Label[] injections;
-
+    
     // TODO: allocate prototypes to avoid measurable GC overhead in ParseTable construction
     //       (especially when using the CMS garbage collector, those gotos and stuff
     //        introduce a lot of overhead)
@@ -89,16 +99,8 @@
 
     private transient Map<Label, List<Priority>> priorityCache;
 	
-	private transient KeywordRecognizer keywords;
-
-    private static final ParseProductionNode[] productionNodes = new ParseProductionNode[256 + 1];
+    private transient KeywordRecognizer keywords;
     
-    static {
-    	for(int i = 0; i < productionNodes.length; i++) {
-    		productionNodes[i] = new ParseProductionNode(i);
-    	}
-    }
-                                             
     public ParseTable(IStrategoTerm pt, ITermFactory factory) throws InvalidParseTableException {
         initTransientData(factory);
         parse(pt);
@@ -136,7 +138,7 @@
         states = parseStates(statesTerm);
         priorities = parsePriorities(prioritiesTerm);
         associativities = parseAssociativities(prioritiesTerm);
-
+        
         injections = new Label[labels.length];
         for(int i = 0; i < labels.length; i++)
             if(labels[i] != null && labels[i].isInjection())
@@ -266,13 +268,17 @@
         final IStrategoConstructor fun = ((IStrategoAppl)ls.head()).getConstructor();
         return !(fun.getName().equals("lit") && fun.getArity() == 1);
     }
+    
 
     private ProductionAttributes parseProductionAttributes(IStrategoAppl attr)
             throws InvalidParseTableException {
-        if (attr.getName().equals("attrs")) {
+      if (attr.getName().equals("attrs")) {
             int type = 0;
             boolean isRecover = false;
-            boolean isCompletion = false;
+            boolean isIgnoreLayout = false;
+            IStrategoTerm layoutConstraint = null;
+            boolean isNewlineEnforced = false;
+            boolean isLongestMatch = false;
             IStrategoTerm term = null;
 
             for (IStrategoList ls = (IStrategoList) attr.getSubterm(0); !ls.isEmpty(); ls = ls.tail()) {
@@ -313,10 +319,39 @@
                     			term = t.getSubterm(0).getSubterm(0);
                     		} else if (child.getSubtermCount() == 0 && child.getName().equals("recover")) {
                     		    hasRecovers = isRecover = true;
-                       		} else if (child.getSubtermCount() == 0 && child.getName().equals("completion")) {
-                    		    isCompletion = true;
                     		}
+                        else if (child.getSubtermCount() == 0 && (child.getName().equals("ignore-layout") || child.getName().equals("ignore-indent"))) {
+                          isIgnoreLayout = true;
+                        }
+                        else if (child.getSubtermCount() == 1 && child.getName().equals("layout")) {
+                          layoutConstraint = child.getSubterm(0);
+                          if (Term.isTermString(layoutConstraint))
+                            try {
+                              if (layoutParser == null) {
+                                try {
+                                  InputStream in = getClass().getResourceAsStream("indentation/LayoutConstraint.tbl");
+                                  ParseTable pt = new ParseTableManager(factory).loadFromStream(in);
+                                  layoutParser =  new SGLR(new TreeBuilder(), pt);
+                                } catch (ParseError e) {
+                                  e.printStackTrace();
+                                } catch (IOException e) {
+                                  e.printStackTrace();
+                                }
+                              }
+                              layoutConstraint = (IStrategoTerm) layoutParser.parse(Term.asJavaString(layoutConstraint), "", "Constraint");
+                            } catch (SGLRException e) {
+                              throw new InvalidParseTableException("invalid layout constraint " + Term.asJavaString(layoutConstraint) + ": " + e.getMessage());
+                            } catch (InterruptedException e) {
+                              e.printStackTrace();
+                            }
+                        }
+                        else if (child.getSubtermCount() == 0 && child.getName().equals("enforce-newline")) {
+                          isNewlineEnforced = true;
                         }
+                        else if (child.getSubtermCount() == 0 && child.getName().equals("longest-match")) {
+                          isLongestMatch = true;
+                        }
+                    	}
                     	// TODO Support other terms that are not a constructor (custom annotations)
                     } else if (ctor.equals("id")) {
                         // FIXME not certain about this
@@ -326,9 +361,9 @@
                     }
                 }
             }
-            return new ProductionAttributes(term, type, isRecover, isCompletion);
+            return new ProductionAttributes(term, type, isRecover, isIgnoreLayout, layoutConstraint, isNewlineEnforced, isLongestMatch);
         } else if (attr.getName().equals("no-attrs")) {
-            return new ProductionAttributes(null, ProductionType.NO_TYPE, false, false);
+            return new ProductionAttributes(null, ProductionType.NO_TYPE, false, false, null, false, false);
         }
         throw new InvalidParseTableException("Unknown attribute type: " + attr);
     }
@@ -390,8 +425,7 @@
                 int label = intAt(a, 1);
                 int status = intAt(a, 2);
                 boolean isRecoverAction = getLabel(label).getAttributes().isRecoverProduction();
-                boolean isCompletionAction = getLabel(label).getAttributes().isCompletionProduction();
-                item = makeReduce(productionArity, label, status, isRecoverAction, isCompletionAction);
+                item = makeReduce(productionArity, label, status, isRecoverAction);
             } else if(a.getName().equals("reduce") && a.getConstructor().getArity() == 4) {
                 int productionArity = intAt(a, 0);
                 int label = intAt(a, 1);
@@ -413,8 +447,8 @@
     }
 
     private RangeList[] parseCharRanges(IStrategoList list) throws InvalidParseTableException {
-        RangeList[] ret = new RangeList[list.getSubtermCount()];
-        for (int i=0;i<ret.length; i++) {
+        List<RangeList> ret = new LinkedList<RangeList>();
+        for (int i=0;i<list.getSubtermCount(); i++) {
             IStrategoNamed t = (IStrategoNamed) list.head();
             list = list.tail();
             IStrategoList l, n;
@@ -430,34 +464,22 @@
             // FIXME: multiple lookahead are not fully supported or tested
             //        (and should work for both 2.4 and 2.6 tables)
 
-            if (n.getSubtermCount() > 0 && l.getSubtermCount() == 1) {
-                // This handles restrictions like:
-                //   LAYOUT? -/- [\/].[\/]
-                // where there is no other restriction that starts with a [\/]
-                
-                ret[i] = parseRanges(l);
-            } else if (n.getSubtermCount() > 0) {
-                // This handles restrictions like:
-                //   LAYOUT? -/- [\/].[\/\+].[\*]
-                throw new InvalidParseTableException("Multiple lookahead not fully supported");
-            } else {
-                // This handles restrictions like:
-                //   LAYOUT? -/- [\/].[\/]
-                //   LAYOUT? -/- [\/].[\*]
-                //   LAYOUT? -/- [\/].[\{]
-
-                ret[i] = parseRanges(l);
-            }
+            ret.add(parseRanges(l));
+            
+            if (n.getSubtermCount() > 0) 
+              throw new InvalidParseTableException("Multiple lookahead not fully supported"); 
+            for (IStrategoTerm nt : n.getAllSubterms())
+              ret.add(parseRanges((IStrategoList) nt.getSubterm(0)));
         }
-        return ret;
+        return ret.toArray(new RangeList[ret.size()]);
     }
 
     private ActionItem makeReduceLookahead(int productionArity, int label, int status, RangeList[] charClasses) {
         return new ReduceLookahead(productionArity, label, status, charClasses);
     }
 
-    private Reduce makeReduce(int arity, int label, int status, boolean isRecoverAction, boolean isCompletionAction) {
-        Reduce r = new Reduce(arity, label, status, isRecoverAction, isCompletionAction);
+    private Reduce makeReduce(int arity, int label, int status, boolean isRecoverAction) {
+        Reduce r = new Reduce(arity, label, status, isRecoverAction);
         Reduce cached = reduceCache.get(r);
         if (cached == null) {
             reduceCache.put(r, r);
@@ -545,7 +567,7 @@
             return cached;
         }
     }
-
+    
     public State getInitialState() {
         return states[startState];
     }
@@ -618,10 +640,6 @@
         return hasAvoids() || hasPrefers();
     }
 
-    public AbstractParseNode lookupProduction(int currentToken) {
-    	return productionNodes[currentToken];
-    }
-
     public IStrategoTerm getProduction(int prod) {
         if (prod < NUM_CHARS) {
             return factory.makeInt(prod);
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/ParserHistory.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParserHistory.java
--- src/org/spoofax/jsglr/client/ParserHistory.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParserHistory.java	2012-09-28 00:32:15.000000000 +0200
@@ -46,17 +46,15 @@
     /*
      * Set current token of parser based on recover tokens or read from new tokens
      */
-    public void readRecoverToken(SGLR myParser, boolean keepStacks) { 
+    public void readRecoverToken(SGLR myParser, boolean keepRecoveredLines) {  
         if (hasFinishedRecoverTokens()) {             
             if(myParser.getCurrentToken()!=SGLR.EOF){                
                 if(getIndexLastToken()>=0){
                     myParser.readNextToken();
                     indentHandler.updateIndentation(myParser.getCurrentToken());
                     recoverTokenCount++;   
-                    if (myParser.getCurrentToken()==SGLR.EOF)
-                        keepNewLinePoint(myParser, myParser.getParserLocation(), !keepStacks, indentHandler);
-                    else if (indentHandler.lineMarginEnded())
-                        keepNewLinePoint(myParser, myParser.getParserLocation()-1, !keepStacks, indentHandler);
+                    if(indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF)
+                        keepNewLinePoint(myParser, myParser.tokensSeen-1, true, indentHandler);
                 }
             }
         }
@@ -65,10 +63,14 @@
             if(myParser.getCurrentToken() == -1) {
             	myParser.setCurrentToken(SGLR.EOF);
     		}
-            if(keepStacks)
-            	addStackNodesToNewLinePoint(myParser);
+            if(keepRecoveredLines){
+                recoveryIndentHandler.updateIndentation(myParser.getCurrentToken());
+                if(recoveryIndentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF)
+                    keepNewLinePoint(myParser, tokenIndex, false, recoveryIndentHandler);
+            }    
         }
-        tokenIndex++;        
+        tokenIndex++;
+        
     }
     
     public boolean hasFinishedRecoverTokens() {
@@ -92,11 +94,8 @@
         indentHandler.updateIndentation(myParser.getCurrentToken());
         recoverTokenCount++;
         tokenIndex++;
-        //assert myParser.tokensSeen == this.getTokenIndex(): "inconsistentcy in token index";
-        if (indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF || tokenIndex == 1)
-            keepNewLinePoint(myParser, myParser.getParserLocation() - 1, false, indentHandler);
-        else if (indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF || tokenIndex == 1)
-            keepNewLinePoint(myParser, myParser.getParserLocation() - 1, false, indentHandler);
+        if(indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF || tokenIndex == 1)
+            keepNewLinePoint(myParser, myParser.tokensSeen-1, false, indentHandler);
     }
     
     public void keepInitialState(SGLR myParser) {        
@@ -110,47 +109,31 @@
         IndentInfo newLinePoint= new IndentInfo(myParser.lineNumber, tokSeen, indent);
         newLinePoints.add(newLinePoint);
         //System.out.println(newLinePoints.size()-1+" NEWLINE ("+newLinePoint.getIndentValue()+")"+newLinePoint.getTokensSeen());
-        if (!inRecoverMode){
+        if(!inRecoverMode){
             newLinePoint.fillStackNodes(myParser.activeStacks);           
         }
     }
-    
-    private void addStackNodesToNewLinePoint(SGLR myParser) {
-		// TODO Auto-generated method stub
-    	int tokensSeen = myParser.getParserLocation() - 1;
-    	for (int i = newLinePoints.size()-1; i >= 0; i--) {
-			IndentInfo newLinePoint = newLinePoints.get(i);
-			if(newLinePoint.getTokensSeen() == tokensSeen){
-	            newLinePoint.fillStackNodes(myParser.activeStacks);
-	            return;
-	        }
-			if(newLinePoint.getTokensSeen() < tokensSeen)
-				return;
-		}
-	}
-
 
     public String getFragment(int startTok, int endTok, PushbackStringIterator chars) {
-        StringBuilder fragment = new StringBuilder();
+        String fragment="";
         for (int i = startTok; i <= endTok; i++) {
-        	int nextChar = readCharAt(i, chars);
-            if(i >= recoverTokenCount || nextChar == -1)
+            if(i >= recoverTokenCount)
                 break;
-            fragment.append((char)nextChar);
+            fragment+= (char)readCharAt(i, chars);
         }        
-        return fragment.toString();
+        return fragment;
     }
     
     public String readLine(int StartTok, PushbackStringIterator chars) {
-        StringBuilder fragment = new StringBuilder();
+        String fragment="";
         int pos=StartTok;
         int currentTok=' ';
         while(currentTok!='\n' && currentTok!=SGLR.EOF && pos<recoverTokenCount) {            
             currentTok=readCharAt(pos, chars);
-            fragment.append((char)currentTok);
+            fragment+= (char)currentTok;
             pos++;
         }        
-        return fragment.toString();
+        return fragment;
     }
     
     public IndentInfo getLine(int index){
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Path.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Path.java
--- src/org/spoofax/jsglr/client/Path.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Path.java	2012-09-28 00:32:16.000000000 +0200
@@ -7,6 +7,7 @@
  */
 package org.spoofax.jsglr.client;
 
+
 public class Path {
 
 	private Path parent;
@@ -16,18 +17,6 @@
 	private int parentCount;
 	private Link link;
 
-	public int getRecoverWeight()
-	{
-		int result = 0;
-		if(link != null) {
-			result += link.recoverWeight;           
-		}
-		if(parent != null) {
-			result += parent.getRecoverWeight();
-		}
-		return result;        
-	}
-
 	public int getRecoverCount()
 	{
 		int result = 0;
@@ -39,7 +28,14 @@
 		}
 		return result;        
 	}
-	
+
+	public int getRecoverCount(int maxCharLength)
+	{
+		if(parent == null || this.length <= maxCharLength)
+			return getRecoverCount();
+		return parent.getRecoverCount(maxCharLength);
+	}
+
 	public Path reuse(Path parent, Link link, Frame frame, int length, int parentCount) {
 		this.parent = parent;
 		this.link = link;
@@ -59,6 +55,10 @@
 	public Frame getEnd() {
 		return frame;
 	}
+	
+	public int getParentCount() {
+	  return parentCount;
+	}
 
 	public final AbstractParseNode[] getParseNodes() {
 		AbstractParseNode[] ret = new AbstractParseNode[parentCount];
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/PathListPool.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/PathListPool.java
--- src/org/spoofax/jsglr/client/PathListPool.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/PathListPool.java	2012-09-28 00:32:15.000000000 +0200
@@ -2,6 +2,7 @@
 
 
 
+
 public class PathListPool {
 
 	// Poor man's queue (?)
@@ -11,10 +12,10 @@
 	private PooledPathList asyncP3 = new PooledPathList(512, false);
 	private PooledPathList asyncP4 = new PooledPathList(512, false);
 	
-	public static int asyncCacheMisses = 0;
+	public int asyncCacheMisses = 0;
 	
 	// this would be a weak reference, if GWT had one
-	private static PathListPool asyncInstance = new PathListPool();
+//	private static PathListPool asyncInstance = new PathListPool();
 	
 	private PathListPool() {
 		// singleton
@@ -25,7 +26,7 @@
 	}
 	
 	public static PathListPool getInstance() {
-		return asyncInstance;
+		return new PathListPool();
 	}
 	
 	public PooledPathList create() {
@@ -48,7 +49,7 @@
 		}
 	}
 	
-	public static void resetPerformanceCounters() {
+	public void resetPerformanceCounters() {
 		synchronized (getSyncRoot()) {
 			asyncCacheMisses = 0;
 		}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/PooledPathList.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/PooledPathList.java
--- src/org/spoofax/jsglr/client/PooledPathList.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/PooledPathList.java	2012-09-28 00:32:15.000000000 +0200
@@ -1,6 +1,7 @@
 package org.spoofax.jsglr.client;
 
 
+
 public class PooledPathList {
 
 	int rememberIndex;
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Production.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Production.java
--- src/org/spoofax/jsglr/client/Production.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Production.java	2012-09-28 00:32:16.000000000 +0200
@@ -16,74 +16,60 @@
 
 public class Production implements Serializable {
 
-    static final long serialVersionUID = 8767621343854666185L;
+  static final long serialVersionUID = 8767621343854666185L;
 
-    public final int arity;
+  public final int arity;
 
-    public final int label;
+  public final int label;
 
-    public final int status;
-    
-    private final boolean isRecover;
+  public final int status;
 
-    private final boolean isCompletion;
-
-    public Production(int arity, int label, int status, boolean isRecover, boolean isCompletion) {
-        this.arity = arity;
-        this.label = label;
-        this.status = status;
-        this.isRecover = isRecover;
-        this.isCompletion = isCompletion;
-    }
-
-    public AbstractParseNode apply(AbstractParseNode[] kids) {
-        switch(status) {
-        case REJECT:
-            return new ParseNode(label, kids, AbstractParseNode.REJECT);
-        case AVOID:
-            return new ParseNode(label, kids, AbstractParseNode.AVOID);
-        case PREFER:
-            return new ParseNode(label, kids, AbstractParseNode.PREFER);
-        case NO_TYPE:
-            return new ParseNode(label, kids, AbstractParseNode.PARSENODE);
-        }
-        throw new IllegalStateException();
-    }
-
-    public boolean isRejectProduction() {
-        return status == REJECT;
-    }
-    
-    public boolean isRecoverProduction() {
-        return isRecover;
-    }
-
-    public boolean isCompletionProduction() {
-        return isCompletion;
-    }
-
-    /**
-     * -> "@#$"{completion} (added for performance reasons)
-     */
-    public boolean isCompletionStartProduction() {
-        return isCompletion && this.arity == 0; 
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if(!(obj instanceof Production))
-            return false;
-        Production o = (Production)obj;
-        return arity == o.arity && label == o.label && status == o.status;
-    }
-
-    @Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + arity;
-		result = prime * result + label;
-		result = prime * result + status;
-		return result;
-	}
+  private final boolean isRecover;
+
+  public Production(int arity, int label, int status, boolean isRecover) {
+    this.arity = arity;
+    this.label = label;
+    this.status = status;
+    this.isRecover = isRecover;
+  }
+
+  public AbstractParseNode apply(AbstractParseNode[] kids, int line, int column, boolean isLayout, boolean isIgnoreLayout) {
+    switch (status) {
+    case REJECT:
+      return new ParseNode(label, kids, AbstractParseNode.REJECT, line, column, isLayout, isIgnoreLayout);
+    case AVOID:
+      return new ParseNode(label, kids, AbstractParseNode.AVOID, line, column, isLayout, isIgnoreLayout);
+    case PREFER:
+      return new ParseNode(label, kids, AbstractParseNode.PREFER, line, column, isLayout, isIgnoreLayout);
+    case NO_TYPE:
+      return new ParseNode(label, kids, AbstractParseNode.PARSENODE, line, column, isLayout, isIgnoreLayout);
+    }
+    throw new IllegalStateException();
+  }
+
+  public boolean isRejectProduction() {
+    return status == REJECT;
+  }
+
+  public boolean isRecoverProduction() {
+    return isRecover;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (!(obj instanceof Production))
+      return false;
+    Production o = (Production) obj;
+    return arity == o.arity && label == o.label && status == o.status;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + arity;
+    result = prime * result + label;
+    result = prime * result + status;
+    return result;
+  }
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/ProductionAttributes.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ProductionAttributes.java
--- src/org/spoofax/jsglr/client/ProductionAttributes.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ProductionAttributes.java	2012-09-28 00:32:16.000000000 +0200
@@ -21,16 +21,21 @@
     private final int type;
 
     private final boolean isRecover;
-
-    private final boolean isCompletion;
+    private final boolean isIgnoreLayout;
+    private final IStrategoTerm layoutConstraint;
+    private final boolean isNewlineEnforced;
+    private final boolean isLongestMatch;
 
     private final transient IStrategoTerm abstractCtor;
 
-    ProductionAttributes(IStrategoTerm ctor, int type, boolean isRecover, boolean isCompletion) {
+    ProductionAttributes(IStrategoTerm ctor, int type, boolean isRecover, boolean isIgnoreIndent, IStrategoTerm layoutConstraint, boolean isNewlineEnforced, boolean isLongestMatch) {
         this.type = type;
         this.abstractCtor = ctor;
         this.isRecover = isRecover;
-        this.isCompletion = isCompletion;
+        this.isIgnoreLayout = isIgnoreIndent;
+        this.layoutConstraint = layoutConstraint;
+        this.isNewlineEnforced = isNewlineEnforced;
+        this.isLongestMatch = isLongestMatch;
     }
 
     public final int getType() {
@@ -44,12 +49,24 @@
     public boolean isRecoverProduction() {
         return isRecover;
     }
-
-    public boolean isCompletionProduction() {
-        return isCompletion;
+    
+    public boolean isIgnoreLayout() {
+      return isIgnoreLayout;
+    }
+    
+    public IStrategoTerm getLayoutConstraint() {
+      return layoutConstraint;
+    }
+    
+    public boolean isNewlineEnforced() {
+      return isNewlineEnforced;
     }
 
     public boolean isMoreEager(ProductionAttributes other) {
         return type != other.type && (type == PREFER || other.type == AVOID);
     }
+
+    public boolean isLongestMatch() {
+      return isLongestMatch;
+    }
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/RecoverDisambiguator.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoverDisambiguator.java
--- src/org/spoofax/jsglr/client/RecoverDisambiguator.java	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoverDisambiguator.java	2012-09-28 00:32:15.000000000 +0200
@@ -0,0 +1,52 @@
+package org.spoofax.jsglr.client;
+
+
+
+public class RecoverDisambiguator {
+    
+    private ParseTable parseTable;
+    static int testCount=0;
+    
+    public RecoverDisambiguator(ParseTable pt){
+        parseTable=pt;        
+    }
+    
+    public void handleAmbiguity(int recoverCount_t, AbstractParseNode t, Link nl){  
+        //System.out.println("RECOVERCOUNT: "+recoverCount_t);
+        //System.out.println("LNK_RECOVERCOUNT: "+nl.recoverCount);
+        testCount++;
+        /*
+        if(nl.isRejected()){
+            setLabel(recoverCount_t, t, nl);            
+            return;
+        } */ 
+        boolean hasCountDiff = trySelectOnRecoverCount(recoverCount_t, t, nl);
+        //if(hasCountDiff==false)
+          //  trySelectByIndentation(recoverCount_t, t, nl);
+    }
+    
+    private boolean trySelectOnRecoverCount(int recoverCount_t, AbstractParseNode t, Link nl) {
+        if(recoverCount_t == nl.recoverCount){
+            setLabel(recoverCount_t, t, nl);
+            return false;
+        }
+        if(recoverCount_t < nl.recoverCount)
+            setLabel(recoverCount_t, t, nl);
+        return true;
+    }
+    
+    private boolean trySelectNoRecoveries(int avoidCount_t, AbstractParseNode t, Link nl){     
+        if(nl.recoverCount==0)
+            return true;
+        if(avoidCount_t==0){
+            setLabel(0, t, nl);
+            return true;
+        }
+        return false;
+    }
+    
+    private void setLabel(int recoverCount_t, AbstractParseNode t, Link nl) {
+        nl.label=t;
+        nl.recoverCount=recoverCount_t;
+    }
+}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/RecoverNode.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoverNode.java
--- src/org/spoofax/jsglr/client/RecoverNode.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoverNode.java	2012-09-28 00:32:16.000000000 +0200
@@ -1,6 +1,7 @@
 package org.spoofax.jsglr.client;
 
 
+
 public class RecoverNode {
     public final int tokensSeen;
     public Frame recoverStack;    
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/RecoveryConnector.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoveryConnector.java
--- src/org/spoofax/jsglr/client/RecoveryConnector.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoveryConnector.java	2012-09-28 00:32:15.000000000 +0200
@@ -1,179 +1,233 @@
 package org.spoofax.jsglr.client;
 
+import org.spoofax.jsglr.shared.ArrayDeque;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
 public class RecoveryConnector {
-	private SGLR mySGLR;
-	private IntegratedRecoverySettings settings;
-	private RegionRecovery regionSelector;
-	private FineGrainedRecovery fgRegionalRecovery; // used on errorneous region (or on region near failure line)
-	private FineGrainedRecovery fgCursorLineRecovery; // intended for recovery near cursor
-
-	public void setFgRegionalRecovery(FineGrainedRecovery fgRegionalRecovery) {
-		this.fgRegionalRecovery = fgRegionalRecovery;
-	}
-
-	private ParserHistory getHistory() {
-		return mySGLR.getHistory();
-	}
-
-	public RecoveryConnector(SGLR parser){
-		this(parser, IntegratedRecoverySettings.createDefaultSettings(), FineGrainedSetting.createDefaultSetting());
-	}
-	
-	public RecoveryConnector(SGLR parser, IntegratedRecoverySettings settings) {
-		this(parser, settings, FineGrainedSetting.createDefaultSetting());
-	}
-
-	public int getMaxNumberOfRecoverApplicationsGlobal(){
-		return this.settings.getMaxNumberOfRecoverApplicationsGlobal();
-	}
-	
-	public RecoveryConnector(SGLR parser, IntegratedRecoverySettings settings, FineGrainedSetting fgSettings) {
-		this.mySGLR = parser;
-		this.regionSelector = new RegionRecovery(mySGLR);
-		this.settings = settings;
-		this.fgCursorLineRecovery = new FineGrainedRecovery(mySGLR, FineGrainedSetting.createCursorLineSetting());		
-		this.fgRegionalRecovery = new FineGrainedRecovery(mySGLR, fgSettings);
-	}
-	
-	public void recover() {
-		mySGLR.getPerformanceMeasuring().startRecovery();
-		boolean recoverySucceeded = combinedRecover();
-		mySGLR.getPerformanceMeasuring().endRecovery(recoverySucceeded);
-	}
-
-	private boolean combinedRecover() {
-		int failureOffset = mySGLR.getParserLocation();
-		int failureLineIndex = getHistory().getLineOfTokenPosition(failureOffset - 1);
-		int cursorLineIndex = getHistory().getLineOfTokenPosition(mySGLR.getCursorLocation());
-
-		mySGLR.getPerformanceMeasuring().addFailureLocation(failureOffset);
-
-		if (settings.useFineGrained() && settings.useCursorLocation()) {
-			if(tryFineGrainedOnCursorLine(failureOffset, failureLineIndex, cursorLineIndex)){
-				//System.out.println("FG on cursor line succeeded!");
-				return true;
-			}
-		}
-		boolean skipSucceeded = false;
-		if (settings.useRegionSelection() || settings.useRegionRecovery()) {
-			skipSucceeded = trySelectErroneousRegion(failureOffset, failureLineIndex, cursorLineIndex);
-		}
-		if (settings.useFineGrained()) {
-			boolean fgSucceeded = tryFineGrainedRecovery(failureOffset, failureLineIndex, skipSucceeded);
-			if (parseRemainingTokens(true)) {
-				return true;
-			} else if (fgSucceeded && mySGLR.getParserLocation() > failureOffset) {
-				return combinedRecover();
-			}
-		}
-		if (settings.useRegionRecovery() && skipSucceeded) {
-			parseErrorFragmentAsWhiteSpace();
-			if (parseRemainingTokens(true))
-				return true;
-			else if (mySGLR.getParserLocation() > failureOffset)
-				return combinedRecover();
-		}
-		return false;
-	}
-
-	private boolean tryFineGrainedOnCursorLine(int failureOffset, int failureLineIndex, int cursorLineIndex) {
-		if(isLikelyErrorLocation(failureLineIndex, cursorLineIndex)){
-			/*			
-			int startTok = getHistory().getLine(Math.max(0, cursorLineIndex - 1)).getTokensSeen();		
-			int endTok = failureOffset;
-			System.out.println(getHistory().getFragment(startTok, endTok, mySGLR.currentInputStream));
-			*/
-			
-			mySGLR.getPerformanceMeasuring().startFGOnCursor();
-			boolean fgSucceededOnCursor = fgCursorLineRecovery.recover(failureOffset, cursorLineIndex);
-			mySGLR.getPerformanceMeasuring().endFGOnCursor(fgSucceededOnCursor);
-			if (fgSucceededOnCursor && parseRemainingTokens(true)) {
-				return true;
-			}
-		}
-		//System.out.println("FG on cursor line failed!");
-		return false;
-	}
-
-	private boolean trySelectErroneousRegion(int failureOffset, int failureLineIndex, int cursorLineIndex) {
-		boolean skipSucceeded;
-		mySGLR.getPerformanceMeasuring().startCG();
-		if(settings.useCursorLocation() && isPossibleErrorLocation(failureLineIndex, cursorLineIndex))
-			skipSucceeded = regionSelector.selectErroneousFragment(failureOffset, failureLineIndex, cursorLineIndex); 
-		else
-			skipSucceeded = regionSelector.selectErroneousFragment(failureOffset, failureLineIndex);
-		mySGLR.getPerformanceMeasuring().endCG(skipSucceeded);
-		mySGLR.acceptingStack = null;
-		mySGLR.activeStacks.clear();
-		return skipSucceeded;
-	}
-
-	private boolean tryFineGrainedRecovery(int failureOffset, int failureLineIndex, boolean skipSucceeded) {
-		mySGLR.getPerformanceMeasuring().startFG();
-		boolean fgSucceeded = false;
-		if (skipSucceeded && settings.useRegionSelection()) {
-			StructureSkipSuggestion erroneousRegion = regionSelector.getErroneousRegion();
-			fgSucceeded = fgRegionalRecovery.recover(
-				failureOffset, 
-				Math.min(erroneousRegion.getIndexHistoryEnd(), failureLineIndex), 
-				erroneousRegion.getStartSkip().getTokensSeen(), 
-				erroneousRegion.getEndSkip().getTokensSeen()
-			);
-		} else {
-			fgSucceeded = fgRegionalRecovery.recover(failureOffset, failureLineIndex);
-		}
-		mySGLR.getPerformanceMeasuring().endFG(fgSucceeded);
-		return fgSucceeded;
-	}
-
-	private boolean isLikelyErrorLocation(int failureLineIndex, int cursorLineIndex) {
-		return 
-			isPossibleErrorLocation(failureLineIndex, cursorLineIndex) && 
-			failureLineIndex - cursorLineIndex <= 10;
-	}
-
-	private boolean isPossibleErrorLocation(int failureLineIndex, int cursorLineIndex) {
-		return mySGLR.isSetCursorLocation() && failureLineIndex >= cursorLineIndex;
-	}
-
-	public boolean parseRemainingTokens(boolean keepHistory) {
-		while ((!getHistory().hasFinishedRecoverTokens())
-				&& mySGLR.activeStacks.size() > 0
-				&& mySGLR.acceptingStack == null) {
-			getHistory().readRecoverToken(mySGLR, keepHistory);
-			mySGLR.doParseStep();
-		}
-		return recoverySucceeded();
-	}
-
-	private boolean recoverySucceeded() {
-		return (mySGLR.activeStacks.size() > 0 || mySGLR.acceptingStack != null);
-	}
-
-	public boolean parseErrorFragmentAsWhiteSpace() {
-		mySGLR.activeStacks.clear();
-		mySGLR.activeStacks.addAll(regionSelector.getStartLineErrorFragment().getStackNodes());
-		getHistory().setTokenIndex(regionSelector.getStartPositionErrorFragment());
-		getHistory().resetRecoveryIndentHandler(regionSelector.getStartLineErrorFragment().getIndentValue());
-		while ((getHistory().getTokenIndex() < regionSelector.getEndPositionErrorFragment())
-				&& mySGLR.activeStacks.size() > 0
-				&& mySGLR.acceptingStack == null) {
-			getHistory().readRecoverToken(mySGLR, false);
-			parseAsLayout();
-		}
-		return recoverySucceeded();
-	}
-
-	private void parseAsLayout() {
-		if (!isLayoutCharacter((char) mySGLR.getCurrentToken()) && mySGLR.getCurrentToken() != SGLR.EOF) {
-			mySGLR.setCurrentToken(' ');
-		}
-		mySGLR.doParseStep();
-	}
-
-	public static boolean isLayoutCharacter(char aChar) {
-		// TODO: Move this to the parse table class; only it truly can know
-		// layout characters
-		return aChar == ' ' || aChar == '\t' || aChar == '\n';
-	}
+    private SGLR mySGLR;
+    private IRecoveryParser recoveryParser;
+    private RegionRecovery skipRecovery;
+    private boolean useBridgeParser;
+    private boolean useFineGrained;
+    private boolean onlyFineGrained;
+    
+    
+    public void setOnlyFineGrained(boolean onlyFG) {
+        onlyFineGrained=onlyFG;        
+    }
+    
+    public void setUseFineGrained(boolean useFG) {
+        useFineGrained=useFG;        
+    }
+    
+    public void setUseBridgeParser(boolean useBridgeParser) {
+        this.useBridgeParser = useBridgeParser;
+    }
+
+    public RecoveryConnector(SGLR parser, IRecoveryParser recoveryParser){
+        mySGLR=parser;        
+        skipRecovery = new RegionRecovery(mySGLR); 
+        useFineGrained=true;
+        onlyFineGrained=false;
+        if(recoveryParser!=null){
+            this.recoveryParser = recoveryParser;
+            useBridgeParser=true;
+        }
+        else
+            useBridgeParser=false;
+        
+    }    
+
+    private ParserHistory getHistory() {
+        return mySGLR.getHistory();
+    }
+    public void recover() throws InterruptedException {
+        mySGLR.getPerformanceMeasuring().startRecovery();
+        combinedRecover();
+        mySGLR.getPerformanceMeasuring().endRecovery(recoverySucceeded());
+    }
+
+    private void combinedRecover() throws InterruptedException {
+        if(onlyFineGrained){
+            mySGLR.getPerformanceMeasuring().startFG();
+            boolean fg=tryFineGrainedRepair();
+            if(fg){
+            	System.out.println("FG-only Succeeded");
+            }
+            mySGLR.getPerformanceMeasuring().endFG(fg);
+            return;
+        }
+        mySGLR.getPerformanceMeasuring().startCG();
+        boolean skipSucceeded = skipRecovery.selectErroneousFragment(); //decides whether whitespace parse makes sense
+        /*
+        System.out.println();
+        System.out.println("------------------------------");
+        System.out.println("SKIP-RESULT: "+skipSucceeded);
+        System.out.print(skipRecovery.getErrorFragment());
+        System.out.println();
+        System.out.println("------------------------------");
+        */
+        mySGLR.getPerformanceMeasuring().endCG(skipSucceeded);
+        mySGLR.acceptingStack=null;
+        mySGLR.activeStacks.clear();
+        //BRIDGE REPAIR
+        if(useBridgeParser){            
+            String errorFragment = skipRecovery.getErrorFragmentWithLeftMargin();
+            mySGLR.getPerformanceMeasuring().startBP();
+            boolean succeeded = tryBridgeRepair(errorFragment);
+            mySGLR.getPerformanceMeasuring().endBP(succeeded);
+            if(succeeded){
+            	//System.out.println("BP-Succeeded");
+                return;
+            }
+        }
+        //FINEGRAINED REPAIR 
+        if(useFineGrained){
+            mySGLR.getPerformanceMeasuring().startFG();
+            boolean FGSucceeded=tryFineGrainedRepair();
+            mySGLR.getPerformanceMeasuring().endFG(FGSucceeded);
+            if(FGSucceeded){ //FG succeeded  
+                addSkipOption(skipSucceeded);
+                //System.out.println("FG-Succeeded");
+                return;
+            }
+        }
+        //WHITESPACE REPAIR
+        if (skipSucceeded) { 
+            getHistory().deleteLinesFrom(skipRecovery.getStartIndexErrorFragment());//TODO: integrate with FG and BP
+            getHistory().resetRecoveryIndentHandler(skipRecovery.getStartLineErrorFragment().getIndentValue());
+            parseErrorFragmentAsWhiteSpace(false);
+            boolean rsSucceeded=parseRemainingTokens(true);
+            /*
+            if(rsSucceeded)
+            	System.out.println("RS-Succeeded");
+            else
+            	System.err.println("RS failed");
+            */
+            
+        }
+    }
+
+    private void addSkipOption(boolean skipSucceeded) throws InterruptedException {
+        ArrayDeque<Frame> fgStacks=new ArrayDeque<Frame>();
+        fgStacks.addAll(mySGLR.activeStacks);
+        if(skipSucceeded && parseErrorFragmentAsWhiteSpace(false) && parseRemainingTokens(false)){
+            for (Frame frame : mySGLR.activeStacks) {
+                for (Link l : frame.getAllLinks()) {
+                    l.recoverCount = 5;
+                }
+            }                        
+            for (Frame frame : fgStacks) {
+                mySGLR.addStack(frame);
+            } 
+        }
+    }
+    
+    private boolean recoverySucceeded() {
+        return (mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null);
+    }
+
+    private boolean tryFineGrainedRepair() throws InterruptedException {
+        FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR); 
+        if(!onlyFineGrained){
+            fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
+        }
+        else{
+            fgRepair.setInfoFGOnly();
+        }
+        fgRepair.recover();
+        fgRepair.parseRemainingTokens();
+        return recoverySucceeded();
+    }
+
+    private boolean tryBridgeRepair(String errorFragment) throws InterruptedException {
+        String repairedFragment = repairBridges(errorFragment);
+        mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());   
+        tryParsing(repairedFragment, false);      
+        return parseRemainingTokens(true);
+    }
+
+    private String repairBridges(String errorFragment) {        
+        try {            
+            IRecoveryResult bpResult = null;
+            bpResult = recoveryParser.recover(errorFragment);
+            return bpResult.getResult();
+        } catch (TokenExpectedException e) {
+            e.printStackTrace();
+        } catch (BadTokenException e) {
+            e.printStackTrace();
+        } catch (SGLRException e) {
+            e.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return  errorFragment;
+    }
+    
+    private void tryParsing(String fragment, boolean asLayout) throws InterruptedException {
+        // Skip any leading whitespace, since we already parsed up to that point
+        int indexFragment = findFirstNonLayoutToken(fragment);
+        while(indexFragment<fragment.length() && mySGLR.activeStacks.size()>0) {                        
+            mySGLR.setCurrentToken(fragment.charAt(indexFragment));
+            indexFragment++;
+            if(!asLayout)
+                mySGLR.doParseStep();
+            else
+                parseAsLayout();
+        }       
+    }
+    
+    public boolean parseErrorFragmentAsWhiteSpace(boolean keepLines) throws InterruptedException {
+        //System.out.println("---------- Start WhiteSpace Parsing ----------");
+        mySGLR.activeStacks.clear();
+        mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());
+        getHistory().setTokenIndex(skipRecovery.getStartPositionErrorFragment());
+        while((getHistory().getTokenIndex()<skipRecovery.getEndPositionErrorFragment()) && mySGLR.activeStacks.size()>0 && mySGLR.acceptingStack==null){        
+            getHistory().readRecoverToken(mySGLR, keepLines);
+            //System.out.print((char)mySGLR.currentToken);
+            parseAsLayout();           
+        }
+        //System.out.println("----------- End WhiteSpace Parsing ---------");
+        return recoverySucceeded();
+    }
+    
+    public boolean parseRemainingTokens(boolean keepHistory) throws InterruptedException {
+        //System.out.println("------------- REMAINING CHARACTERS --------------- ");
+        //System.out.println();
+        getHistory().setTokenIndex(skipRecovery.getEndPositionErrorFragment());
+        while(
+        		(!getHistory().hasFinishedRecoverTokens()) 
+        		&& mySGLR.activeStacks.size()>0 
+        		&& mySGLR.acceptingStack==null
+        )
+        {        
+            getHistory().readRecoverToken(mySGLR, keepHistory);
+            //System.out.print((char)mySGLR.currentToken);
+            //System.out.print("("+mySGLR.currentToken+")");
+            mySGLR.doParseStep();            
+        }  
+        return recoverySucceeded();
+    }
+    
+    private void parseAsLayout() throws InterruptedException {
+        if(!isLayoutCharacter((char)mySGLR.getCurrentToken()) && mySGLR.getCurrentToken()!=SGLR.EOF){
+            mySGLR.setCurrentToken(' ');
+        }
+        mySGLR.doParseStep();
+    }
+    
+    public static boolean isLayoutCharacter(char aChar) {
+        // TODO: Move this to the parse table class; only it truly can now layout characters
+        return aChar==' ' || aChar == '\t' || aChar=='\n';
+    }
+
+    private int findFirstNonLayoutToken(String repairedFragment) {
+        int indexFragment=0;
+        while(indexFragment<repairedFragment.length()-1 && isLayoutCharacter(repairedFragment.charAt(indexFragment)))
+            indexFragment++;
+        return indexFragment;
+    }
+
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/RecoveryPerformance.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoveryPerformance.java
--- src/org/spoofax/jsglr/client/RecoveryPerformance.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoveryPerformance.java	2012-09-28 00:32:15.000000000 +0200
@@ -9,8 +9,6 @@
     private long startCG;
     private ArrayList<Integer> CGTimes;
     private long startFG;
-    private ArrayList<Integer> FGOnCursorTimes;
-    private long startFGOnCursor;
     private ArrayList<Integer> FGTimes;
     private long startBP;
     private ArrayList<Integer> BPTimes;
@@ -19,31 +17,20 @@
     
     private ArrayList<Boolean> CGResults;
     private ArrayList<Boolean> FGResults;
-    private ArrayList<Boolean> FGOnCursorResults;
     private ArrayList<Boolean> BPResults;
     private ArrayList<Boolean> recoveryResults;
     private boolean parseResult;
-    private int recoverCount; 
-
-    private ArrayList<Integer> failureLocations;
-    
-    public ArrayList<Integer> getFailureLocations() {
-		return failureLocations;
-	}
     
     public RecoveryPerformance(){
         CGTimes=new ArrayList<Integer>();
         FGTimes=new ArrayList<Integer>();
-        FGOnCursorTimes=new ArrayList<Integer>();
         BPTimes=new ArrayList<Integer>();
         recoveryTimes=new ArrayList<Integer>();
         
         CGResults=new ArrayList<Boolean>();
         FGResults=new ArrayList<Boolean>();
-        FGOnCursorResults=new ArrayList<Boolean>();
         BPResults=new ArrayList<Boolean>();
         recoveryResults=new ArrayList<Boolean>();
-        failureLocations = new ArrayList<Integer>();
     }
     
     public boolean isParseSucceeded() {
@@ -114,17 +101,7 @@
         FGTimes.add((int)FGTime);
         FGResults.add(succeeded);
     }
-
-	public void startFGOnCursor() {
-        startFGOnCursor = System.currentTimeMillis();
-	}
-
-	public void endFGOnCursor(boolean succeeded) {
-        long FGTime=System.currentTimeMillis()-startFGOnCursor;
-        FGOnCursorTimes.add((int)FGTime);
-        FGOnCursorResults.add(succeeded);
-	}
-
+    
     void startBP(){
         startBP=System.currentTimeMillis();
     }
@@ -144,16 +121,4 @@
         recoveryTimes.add((int)recoveryTime);
         recoveryResults.add(succeeded);
     }
-
-    public void addFailureLocation(int tokensSeen) {
-		failureLocations.add(tokensSeen);		
-	}
-    
-	public void setRecoverCount(int recoverCount) {
-		this.recoverCount = recoverCount;
-	}
-    
-	public int getRecoverCount() {
-		return recoverCount;
-	}
 }
\ No newline at end of file
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Reduce.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Reduce.java
--- src/org/spoofax/jsglr/client/Reduce.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Reduce.java	2012-09-28 00:32:15.000000000 +0200
@@ -9,6 +9,7 @@
 
 
 
+
 public class Reduce extends ActionItem {
 
     private static final long serialVersionUID = 8620275049778432244L;
@@ -21,7 +22,7 @@
 
     public final Production production;
 
-    public Reduce(int arity, int label, int status, boolean isRecoverAction, boolean isCompletionAction) {
+    public Reduce(int arity, int label, int status, boolean isRecoverAction) {
 
         super(REDUCE);
 
@@ -29,7 +30,7 @@
         this.label = label;
         this.status = status;
 
-        production = new Production(arity, label, status, isRecoverAction, isCompletionAction);
+        production = new Production(arity, label, status, isRecoverAction);
     }
 
 
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/ReduceLookahead.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ReduceLookahead.java
--- src/org/spoofax/jsglr/client/ReduceLookahead.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ReduceLookahead.java	2012-09-28 00:32:16.000000000 +0200
@@ -8,6 +8,7 @@
 package org.spoofax.jsglr.client;
 
 
+
 public class ReduceLookahead extends ActionItem {
 
     private static final long serialVersionUID = 8620275049778432243L;
@@ -30,7 +31,7 @@
         this.status = status;
         this.charRanges = charClasses;
 
-        production = new Production(arity, label, status, false, false);
+        production = new Production(arity, label, status, false);
     }
 
     @Override
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/RegionRecovery.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RegionRecovery.java
--- src/org/spoofax/jsglr/client/RegionRecovery.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RegionRecovery.java	2012-09-28 00:32:16.000000000 +0200
@@ -74,72 +74,53 @@
         return getHistory().getLinesFromTo(erroneousRegion.getIndexHistoryStart(), getEndPositionErrorFragment());
     }      
 
-    public boolean selectErroneousFragment(int failureOffset, int failureLineIndex){
-    	return selectErroneousFragment(failureOffset, failureLineIndex, -1);
-    }
-
     /**
      * Selects erroneous region based on layout 
+     * @throws InterruptedException 
      */
-    public boolean selectErroneousFragment(int failureOffset, int failureLineIndex, int cursorLineIndex) { 
+    public boolean selectErroneousFragment() throws InterruptedException { 
         boolean eofReached=myParser.getCurrentToken()==SGLR.EOF;
         acceptPosition=-1;
         NewStructureSkipper newRegionSelector=new NewStructureSkipper(myParser);
-        errorDetectionLocation = failureOffset - 1;
-        assert(failureLineIndex >= 0);
-                
-        ArrayList<StructureSkipSuggestion> prevRegions=newRegionSelector.getPreviousSkipSuggestions(failureLineIndex);
+        int failureIndex=getHistory().getIndexLastLine();
+        assert(failureIndex >= 0);
+        errorDetectionLocation=getHistory().getIndexLastToken();
+        ArrayList<StructureSkipSuggestion> prevRegions=newRegionSelector.getPreviousSkipSuggestions(failureIndex);
         //System.out.println("PREVIOUS REGION");        
         if(trySetErroneousRegion(prevRegions)){
             ArrayList<StructureSkipSuggestion> decomposedRegions=newRegionSelector.getZoomOnPreviousSuggestions(erroneousRegion);
             trySetErroneousRegion(decomposedRegions);
             return true;
         }        
-        ArrayList<StructureSkipSuggestion> currentRegions=newRegionSelector.getCurrentSkipSuggestions(failureLineIndex);
+        ArrayList<StructureSkipSuggestion> currentRegions=newRegionSelector.getCurrentSkipSuggestions(failureIndex);
         //System.out.println("CURRENT REGION");
         if(trySetErroneousRegion(currentRegions)){            
             return true;
         }
-
-        if(0 <= cursorLineIndex && cursorLineIndex < failureLineIndex){
-	        ArrayList<StructureSkipSuggestion> cursorRegions=newRegionSelector.getCurrentSkipSuggestions(cursorLineIndex);
-	        //System.out.println("CURSOR REGION");
-	        if(trySetErroneousRegion(cursorRegions)){
-				//System.out.println("Region Selection on cursor line succeeded!");
-	            return true;
-	        }
-	        //System.out.println("CURSOR PARENT REGION");
-	        ArrayList<StructureSkipSuggestion> cursorParentRegion=newRegionSelector.getParentSkipSuggestions(cursorLineIndex);
-	        if(trySetErroneousRegion(cursorParentRegion)){            
-				//System.out.println("Region Selection on cursor line succeeded!");
-	            return true;
-	        }
-        }
-
         //System.out.println("PRIOR REGIONS");
-        ArrayList<StructureSkipSuggestion> priorRegions=newRegionSelector.getPriorSkipSuggestions(failureLineIndex);
+        ArrayList<StructureSkipSuggestion> priorRegions=newRegionSelector.getPriorSkipSuggestions(failureIndex);
         if(trySetErroneousRegion(priorRegions)){
             ArrayList<StructureSkipSuggestion> decomposedRegions=newRegionSelector.getZoomOnPreviousSuggestions(erroneousRegion);
             trySetErroneousRegion(decomposedRegions);
             return true;
         }
         //System.out.println("FW-SIB REGIONS");
-        ArrayList<StructureSkipSuggestion> siblingForWardRegions=newRegionSelector.getSibblingForwardSuggestions(failureLineIndex);
+        ArrayList<StructureSkipSuggestion> siblingForWardRegions=newRegionSelector.getSibblingForwardSuggestions(failureIndex);
         if(trySetErroneousRegion(siblingForWardRegions)){            
             return true;
         }
         //System.out.println("BW-SIB REGIONS");
-        ArrayList<StructureSkipSuggestion> siblingBackWardRegions=newRegionSelector.getSibblingBackwardSuggestions(failureLineIndex);
+        ArrayList<StructureSkipSuggestion> siblingBackWardRegions=newRegionSelector.getSibblingBackwardSuggestions(failureIndex);
         if(trySetErroneousRegion(siblingBackWardRegions)){            
             return true;
         }
         //System.out.println("SURROUNDING-SIB REGIONS");        
-        ArrayList<StructureSkipSuggestion> siblingSurroundingRegions=newRegionSelector.getSibblingSurroundingSuggestions(failureLineIndex);
+        ArrayList<StructureSkipSuggestion> siblingSurroundingRegions=newRegionSelector.getSibblingSurroundingSuggestions(failureIndex);
         if(trySetErroneousRegion(siblingSurroundingRegions)){            
             return true;
         }
         //System.out.println("PARENT REGION");
-        ArrayList<StructureSkipSuggestion> parentRegion=newRegionSelector.getParentSkipSuggestions(failureLineIndex);
+        ArrayList<StructureSkipSuggestion> parentRegion=newRegionSelector.getParentSkipSuggestions(failureIndex);
         if(trySetErroneousRegion(parentRegion)){            
             return true;
         }
@@ -148,7 +129,7 @@
         //if(trySetErroneousRegion(parentRegion)){            
           //  return true;
         //}
-        erroneousRegion=newRegionSelector.getErroneousPrefix(failureLineIndex);
+        erroneousRegion=newRegionSelector.getErroneousPrefix(failureIndex);
         ArrayList<StructureSkipSuggestion> decomposedRegions=newRegionSelector.getZoomOnPreviousSuggestions(erroneousRegion);
         boolean findSmallerPart=trySetErroneousRegion(decomposedRegions);
         if(!findSmallerPart){
@@ -165,8 +146,8 @@
             }
             
             int indexAccept;
-            if(getHistory().getIndexLastLine()>=failureLineIndex+NR_OF_LINES_TILL_SUCCESS)
-                indexAccept=failureLineIndex+NR_OF_LINES_TILL_SUCCESS;
+            if(getHistory().getIndexLastLine()>=failureIndex+NR_OF_LINES_TILL_SUCCESS)
+                indexAccept=failureIndex+NR_OF_LINES_TILL_SUCCESS;
             else
                 indexAccept=getHistory().getIndexLastLine();            
             acceptPosition=getHistory().getLine(indexAccept).getTokensSeen();
@@ -178,7 +159,7 @@
         return true; 
     }
 
-    private boolean trySetErroneousRegion(ArrayList<StructureSkipSuggestion> regions) {
+    private boolean trySetErroneousRegion(ArrayList<StructureSkipSuggestion> regions) throws InterruptedException {
         StructureSkipSuggestion aSkip=new StructureSkipSuggestion();
         int indexSkips=0;
         myParser.acceptingStack=null; 
@@ -196,7 +177,7 @@
         return hasFoundErroneousRegion;
     }
 
-    private boolean testRegion(StructureSkipSuggestion aSkip) {
+    private boolean testRegion(StructureSkipSuggestion aSkip) throws InterruptedException {
        // System.out.println("%%%%%%%%%%% TEST REGION %%%%%%%%%%%");
         //System.out.println(getInputFragment(aSkip));
         IndentInfo endPos=aSkip.getEndSkip();
@@ -227,7 +208,7 @@
     }
 
     private void parseAdditionalTokens(
-            StructureSkipSuggestion aSkip) {
+            StructureSkipSuggestion aSkip) throws InterruptedException {
         for (char aChar : aSkip.getAdditionalTokens()) {
             myParser.setCurrentToken(aChar);           
             myParser.doParseStep();
@@ -240,6 +221,10 @@
         }
     }
 
+    private String getInputFragment(StructureSkipSuggestion aSkip) {
+        return getHistory().getFragment(aSkip.getStartSkip().getTokensSeen(), aSkip.getEndSkip().getTokensSeen()-1, myParser.currentInputStream);
+    }
+
     private boolean successCriterion() {
         return myParser.activeStacks.size() > 0 || myParser.acceptingStack!=null;
     }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/SGLR.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/SGLR.java
--- src/org/spoofax/jsglr/client/SGLR.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/SGLR.java	2012-09-28 00:32:16.000000000 +0200
@@ -15,6 +15,7 @@
 
 import org.spoofax.PushbackStringIterator;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.jsglr.client.indentation.LayoutFilter;
 import org.spoofax.jsglr.shared.ArrayDeque;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
@@ -23,15 +24,20 @@
 
 public class SGLR {
 
-    private static final int COMPLETION_REGION_SIZE = 1000;
-
-	private RecoveryPerformance performanceMeasuring;
+  private static final boolean ENFORCE_NEWLINE_FITER = true;
+  private static final boolean PARSE_TIME_LAYOUT_FITER = true;
+  
+  private int layoutFiltering;
+  
+  private int enforcedNewlineSkip = 0;
+  
+  private RecoveryPerformance performanceMeasuring;
 
 	private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
 
 	public static final int EOF = ParseTable.NUM_CHARS;
 
-	static final int TAB_SIZE = 4;//8;
+	static final int TAB_SIZE = 8;
 
 	protected static boolean WORK_AROUND_MULTIPLE_LOOKAHEAD;
 
@@ -52,14 +58,20 @@
 	private ParseTable parseTable;
 
 	private int currentToken;
-
-	private int tokensSeen;
+	
+	private int currentIndentation;
+	
+	protected int tokensSeen;
 
 	protected int lineNumber;
 
 	protected int columnNumber;
 
-	private int startOffset;
+  protected int lastLineNumber;
+
+  protected int lastColumnNumber;
+
+  private int startOffset;
 
 	private final ArrayDeque<ActionState> forShifter;
 
@@ -96,49 +108,19 @@
 	private RecoveryConnector recoverIntegrator;
 	
 	private ITreeBuilder treeBuilder;
+	
+	private AbstractParseNode parseTree;
 
 	protected boolean useIntegratedRecovery;
-
-	public void setUseStructureRecovery(boolean useRecovery) {
-		this.useIntegratedRecovery = useRecovery;
-		this.recoverIntegrator = new RecoveryConnector(this);
-	}
-
-	public void setUseStructureRecovery(boolean useRecovery, IntegratedRecoverySettings settings, FineGrainedSetting fgSettings) {
-		this.useIntegratedRecovery = useRecovery;
-		this.recoverIntegrator = new RecoveryConnector(this, settings, fgSettings);
-	}
-
-	private boolean isCompletionMode;
 	
 	public ParserHistory getHistory() {
 		return history;
 	}
-	
-	public int getParserLocation(){
-		return this.getHistory().getTokenIndex(); //should also work in recover mode
-	}
 
-	private boolean isFineGrainedMode;
-	
-	private int fineGrainedStartLocation;
+	private boolean fineGrainedOnRegion;
 	
-	private int fineGrainedRecoverMax;
-
-	private int cursorLocation;
+	private LayoutFilter layoutFilter;
 
-	public int getCursorLocation() {
-		return cursorLocation;
-	}
-	
-	public boolean isSetCursorLocation() {
-		return 0 < cursorLocation && cursorLocation != Integer.MAX_VALUE;
-	}
-	
-	private void setCompletionParse(boolean isCompletionMode, int cursorLocation){
-		this.isCompletionMode = isCompletionMode;
-		this.cursorLocation = cursorLocation;
-	}
 
 	protected ArrayDeque<Frame> getRecoverStacks() {
 		return recoverStacks;
@@ -147,7 +129,19 @@
 	public Set<BadTokenException> getCollectedErrors() {
 		return collectedErrors;
 	}
-    
+	
+	public int getEnforcedNewlineSkips() {
+	  return enforcedNewlineSkip;
+	}
+   
+	public int getLayoutFilteringCount() {
+    return layoutFiltering;
+  }
+	
+	 public int getLayoutFilterCallCount() {
+	    return layoutFilter.getFilterCallCount();
+	  }
+	  
     /**
      * Attempts to set a timeout for parsing.
      * Default implementation throws an
@@ -177,30 +171,53 @@
 		assert parseTable != null;
 		// Init with a new factory for both serialized or BAF instances.
 		this.parseTable = parseTable;
+
 		activeStacks = new ArrayDeque<Frame>();
 		forActor = new ArrayDeque<Frame>();
 		forActorDelayed = new ArrayDeque<Frame>();
 		forShifter = new ArrayDeque<ActionState>();
 		disambiguator = new Disambiguator();
 		useIntegratedRecovery = false;
-		setUseStructureRecovery(false);
+		recoverIntegrator = null;
 		history = new ParserHistory();
-    	setCompletionParse(false, Integer.MAX_VALUE);
 		setTreeBuilder(treeBuilder);
+		layoutFilter = new LayoutFilter(parseTable, true);
+	}
+
+	public void setUseStructureRecovery(boolean useRecovery, IRecoveryParser parser) {
+		useIntegratedRecovery = useRecovery;
+		recoverIntegrator = new RecoveryConnector(this, parser);
+	}
+
+	/**
+	 * Enables error recovery based on region recovery and, if available, recovery rules.
+	 * Does not enable bridge parsing.
+	 *
+	 * @see ParseTable#hasRecovers()   Determines if the parse table supports recovery rules
+	 */
+	public final void setUseStructureRecovery(boolean useRecovery) {
+		setUseStructureRecovery(useRecovery, null);
 	}
 	
-    protected void setFinegrainedRecoverMode(boolean fineGrainedMode) {
-        this.isFineGrainedMode = fineGrainedMode;
+    protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
+        fineGrainedOnRegion = fineGrainedMode;
         recoverStacks = new ArrayDeque<Frame>();
     }
-    
-    protected void setFineGrainedStartLocation(int fineGrainedStartLocation) {
-		this.fineGrainedStartLocation = fineGrainedStartLocation;
-	}
 
-    protected void setFineGrainedRecoverMax(int fineGrainedRecoverMax) {
-		this.fineGrainedRecoverMax = fineGrainedRecoverMax;
-	}
+    @Deprecated
+    protected void setUseFineGrained(boolean useFG) {
+        recoverIntegrator.setUseFineGrained(useFG);
+    }
+
+    // FIXME: we have way to many of these accessors; does this have to be public?
+    //        if not for normal use, it should at least be 'internalSet....'
+    @Deprecated
+    public void setCombinedRecovery(boolean useBP, boolean useFG,
+            boolean useOnlyFG) {
+        recoverIntegrator.setOnlyFineGrained(useOnlyFG);
+        recoverIntegrator.setUseBridgeParser(useBP);
+        recoverIntegrator.setUseFineGrained(useFG);
+    }
 
     public RecoveryPerformance getPerformanceMeasuring() {
         return performanceMeasuring;
@@ -252,13 +269,13 @@
 	
 	@Deprecated
 	public Object parse(String input) throws BadTokenException,
-    TokenExpectedException, ParseException, SGLRException {
+    TokenExpectedException, ParseException, SGLRException, InterruptedException {
 	    return parse(input, null, null);
 	}
 
     @Deprecated
 	public final Object parse(String input, String filename) throws BadTokenException,
-    TokenExpectedException, ParseException, SGLRException {
+    TokenExpectedException, ParseException, SGLRException, InterruptedException {
 
         return parse(input, filename, null);
     }
@@ -266,47 +283,35 @@
 	/**
 	 * Parses a string and constructs a new tree using the tree builder.
 	 * 
-	 * @param input           The input string.
-	 * @param filename        The source filename of the string, or null if not available.
-	 * @param startSymbol     The start symbol to use, or null if any applicable.
-	 * @param completionMode  True in case the parser result is used for content completion.
-	 * @param cursorLocation  The location of the cursor used to find completion recoveries.
-	 */
-    public Object parse(String input, String filename, String startSymbol, boolean completionMode, int cursorLocation) 
-    	throws BadTokenException, TokenExpectedException, ParseException, SGLRException {
-    	setCompletionParse(completionMode, cursorLocation);
-    	Object parseResult = parse(input, filename, startSymbol);
-    	setCompletionParse(false, Integer.MAX_VALUE);
-    	return parseResult;
-    }
-
-    /**
-	 * Parses a string and constructs a new tree using the tree builder.
-	 * 
 	 * @param input        The input string.
 	 * @param filename     The source filename of the string, or null if not available.
 	 * @param startSymbol  The start symbol to use, or null if any applicable.
+	 * @throws InterruptedException 
 	 */
     public Object parse(String input, String filename, String startSymbol) throws BadTokenException, TokenExpectedException, ParseException,
-	SGLRException {
+	SGLRException, InterruptedException {
 		logBeforeParsing();
 		initParseVariables(input, filename);
 		startTime = System.currentTimeMillis();
 		initParseTimer();
-		getPerformanceMeasuring().startParse();
         Object result = sglrParse(startSymbol);
         return result;
 	}
 
 	private Object sglrParse(String startSymbol)
 	throws BadTokenException, TokenExpectedException,
-	ParseException, SGLRException {
+	ParseException, SGLRException, InterruptedException {
+		getPerformanceMeasuring().startParse();
 		try {
 			do {
+		     if (Thread.currentThread().isInterrupted())
+		        throw new InterruptedException();
+
 				readNextToken();
+				//System.out.print((char)currentToken);
 				history.keepTokenAndState(this);
 				doParseStep();
-			} while (getCurrentToken() != SGLR.EOF && activeStacks.size() > 0);
+			} while (currentToken != SGLR.EOF && activeStacks.size() > 0);
 
 			if (acceptingStack == null) {
 				collectedErrors.add(createBadTokenException());
@@ -320,7 +325,7 @@
 			}
 			getPerformanceMeasuring().endParse(acceptingStack!=null);
 		} catch (final TaskCancellationException e) {
-			throw new ParseTimeoutException(this, getCurrentToken(), tokensSeen - 1, lineNumber,
+			throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
 					columnNumber, collectedErrors);
 		} finally {
 			activeStacks.clear();
@@ -337,19 +342,15 @@
 		if (s == null) {
 			throw new ParseException(this, "Accepting stack has no link");
 		}
-		//System.out.println(s.recoverCount);
-		assert(s.recoverCount <= s.recoverWeight);
-
-		performanceMeasuring.setRecoverCount(s.recoverCount);
 
 		logParseResult(s);
-		//System.out.println("recoveries: " + s.recoverCount);
-		Tools.debug("recoveries: ", s.recoverCount);
+		Tools.debug("avoids: ", s.recoverCount);
 		//Tools.debug(s.label.toParseTree(parseTable));
 
 		if (getTreeBuilder() instanceof NullTreeBuilder) {
 			return null;
 		} else {
+		  this.parseTree = s.label;
 			return disambiguator.applyFilters(this, s.label, startSymbol, tokensSeen);
 		}
 	}
@@ -358,8 +359,32 @@
 		logCurrentToken();
 		setCurrentToken(getNextToken());
 	}
+	
+	protected void setCurrentToken(int tok) {
+	  if (currentToken == -1)
+	    currentIndentation = 0;
+	  else
+	    switch (currentToken) {
+	    case '\n':
+	      currentIndentation = 0;
+	      break;
+	    case '\t':
+	      currentIndentation = (currentIndentation / TAB_SIZE + 1) * TAB_SIZE;
+	      break;
+	    case -1:
+	      break;
+	    default:
+	      currentIndentation++;
+	    }
+	  
+	  this.currentToken = tok;
+	}
+	
+	protected int getCurrentToken() {
+	  return this.currentToken;
+	}
 
-	protected void doParseStep() {
+	protected void doParseStep() throws InterruptedException {
 		logBeforeParseCharacter();
 		parseCharacter(); //applies reductions on active stack structure and fills forshifter
 		shifter(); //renewes active stacks with states in forshifter
@@ -371,6 +396,8 @@
 		forShifter.clear();
 		history.clear();
 		startFrame = initActiveStacks();
+		currentToken = -1;
+		currentIndentation = 0;
 		tokensSeen = 0;
 		currentInputStream = new PushbackStringIterator(input);
 		acceptingStack = null;
@@ -379,8 +406,11 @@
 		performanceMeasuring=new RecoveryPerformance();
 		getTreeBuilder().initializeInput(input, filename);
 		PooledPathList.resetPerformanceCounters();
-		PathListPool.resetPerformanceCounters();
+		pathCache.resetPerformanceCounters();
 		ambiguityManager = new AmbiguityManager(input.length());
+		parseTree = null;
+		enforcedNewlineSkip = 0;
+		layoutFiltering = 0;
 		if (getTreeBuilder().getTokenizer() != null) {
 			// Make sure we use the same starting offsets as the tokenizer, if any
 			// (crucial for parsing fragments at a time)
@@ -422,20 +452,20 @@
 				} while (action != null);
 
 				if (expected.length() > 0) {
-					return new TokenExpectedException(this, expected.toString(), getCurrentToken(),
+					return new TokenExpectedException(this, expected.toString(), currentToken,
 							tokensSeen + startOffset - 1, lineNumber, columnNumber);
 				}
 			}
 		}
 
-		return new BadTokenException(this, getCurrentToken(), tokensSeen + startOffset - 1, lineNumber,
+		return new BadTokenException(this, currentToken, tokensSeen + startOffset - 1, lineNumber,
 				columnNumber);
 	}
 
 	private void shifter() {
 		logBeforeShifter();
 		activeStacks.clear();
-		final AbstractParseNode prod = parseTable.lookupProduction(getCurrentToken());
+		final AbstractParseNode prod = new ParseProductionNode(currentToken, lastLineNumber, lastColumnNumber);
 
 		while (forShifter.size() > 0) {
 			final ActionState as = forShifter.remove();
@@ -445,7 +475,7 @@
 					st1 = newStack(as.s);
 					addStack(st1);
 				}
-				st1.addLink(as.st, prod, 1);
+				st1.addLink(as.st, prod, 1, lastLineNumber, lastColumnNumber);
 			} else {
 				if (Tools.logging) {
 					Tools.logger("Shifter: skipping rejected stack with state ",
@@ -463,7 +493,7 @@
 		activeStacks.addFirst(st1);
 	}
 
-	private void parseCharacter() {
+	private void parseCharacter() throws InterruptedException {
 		logBeforeParseCharacter();
 
 		activeStacksWorkQueue.clear();
@@ -473,6 +503,9 @@
 		forShifter.clear();
 
 		while (activeStacksWorkQueue.size() > 0 || forActor.size() > 0) {
+		  if (Thread.currentThread().isInterrupted())
+		    throw new InterruptedException();
+		  
 			final Frame st = pickStackNodeFromActivesOrForActor(activeStacksWorkQueue);
 			if (!st.allLinksRejected()) {
 				actor(st);
@@ -510,19 +543,19 @@
 		return st;
 	}
 
-	private void actor(Frame st) {
+	private void actor(Frame st) throws InterruptedException {
 
 		final State s = st.peek();
 		logBeforeActor(st, s);
 
 		for (final Action action : s.getActions()) {
-			if (action.accepts(getCurrentToken())) {
+			if (action.accepts(currentToken)) {
 				for (final ActionItem ai : action.getActionItems()) {
 					switch (ai.type) {
 					case ActionItem.SHIFT: {
 						final Shift sh = (Shift) ai;
 						final ActionState actState = new ActionState(st, parseTable.getState(sh.nextState));
-						actState.currentToken = getCurrentToken();
+						actState.currentToken = currentToken;
 						addShiftPair(actState); //Adds StackNode to forshifter
 						statsRecordParsers(); //sets some values un current parse state
 						break;
@@ -564,28 +597,41 @@
 	}
 
 	private boolean checkLookahead(ReduceLookahead red) {
-		return doCheckLookahead(red, red.getCharRanges(), 0);
+		return doCheckLookahead(red, red.getCharRanges());
 	}
 
-	private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) {
+	private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass) {
 		if(Tools.tracing) {
 			TRACE("SG_CheckLookAhead() - ");
 		}
 
-		final int c = currentInputStream.read();
-
-		// EOF
-		if(c == -1) {
-			return true;
-		}
-
-		boolean permit = true;
-
-		if(pos < charClass.length) {
-			permit = charClass[pos].within(c) ? false : doCheckLookahead(red, charClass, pos + 1);
+		if (charClass.length == 0)
+		  return true;
+		
+    boolean permit = false;
+    int offset = -1;
+    int[] readChars = new int[charClass.length];
+		
+    int i;
+		for (i = 0; i < charClass.length; i++) {
+  		int c = currentInputStream.read();
+  		offset++;
+  		readChars[offset] = c; 
+  
+  		// EOF
+  		if(c == -1) {
+  			permit = true;
+  			break;
+  		}
+  
+  		if (!charClass[i].within(c)) {
+  		  permit = true;
+  		  break;
+  		}
 		}
 
-		currentInputStream.unread(c);
+		for (int j = offset; j >= 0; j--)
+		  currentInputStream.unread(readChars[j]);
 
 		return permit;
 	}
@@ -600,7 +646,7 @@
 	private void statsRecordParsers() {
 		if (forShifter.size() > maxBranches) {
 			maxBranches = forShifter.size();
-			maxToken = getCurrentToken();
+			maxToken = currentToken;
 			maxColumn = columnNumber;
 			maxLine = lineNumber;
 			maxTokenNumber = tokensSeen;
@@ -608,13 +654,16 @@
 	}
 
 
-	private void doReductions(Frame st, Production prod) {
+	private void doReductions(Frame st, Production prod) throws InterruptedException {
 
+	  if (Thread.currentThread().isInterrupted())
+	    throw new InterruptedException();
+	  
 		if(!recoverModeOk(st, prod)) {
 			return;
 		}
-
-		PooledPathList paths = pathCache.create();
+		
+				PooledPathList paths = pathCache.create();
 		try {
 			st.findAllPaths(paths, prod.arity);
 			logBeforeDoReductions(st, prod, paths.size());
@@ -626,19 +675,10 @@
 	}
 
 	private boolean recoverModeOk(Frame st, Production prod) {
-		if(!prod.isCompletionProduction()){
-			return !prod.isRecoverProduction() || isFineGrainedMode;
-		}
-		return inCompletionMode(prod);
-	}
-
-	private boolean inCompletionMode(Production prod) {
-		if(!prod.isCompletionStartProduction()) //Performance trick: -> "@#$" {completion} starts the completion
-			return isCompletionMode && cursorLocation <= getParserLocation() && getParserLocation() <= cursorLocation + COMPLETION_REGION_SIZE;
-		return isCompletionMode && cursorLocation - COMPLETION_REGION_SIZE <= getParserLocation() && getParserLocation() <= cursorLocation;
+		return !prod.isRecoverProduction() || fineGrainedOnRegion;
 	}
 
-	private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
+	private void doLimitedReductions(Frame st, Production prod, Link l) throws InterruptedException { //Todo: Look add sharing code with doReductions
 		if(!recoverModeOk(st, prod)) {
 			return;
 		}
@@ -652,7 +692,7 @@
 		}
 	}
 
-	private void reduceAllPaths(Production prod, PooledPathList paths) {
+	private void reduceAllPaths(Production prod, PooledPathList paths) throws InterruptedException {
 
 		for(int i = 0; i < paths.size(); i++) {
 			final Path path = paths.get(i);
@@ -660,14 +700,42 @@
 			final Frame st0 = path.getEnd();
 			final State next = parseTable.go(st0.state, prod.label);
 			logReductionPath(prod, path, st0, next);
-			if(!prod.isCompletionProduction() || isReductionOverCursorLocation(path)){
-				if(checkMaxRecoverCount(prod, path)){
-					if(!prod.isRecoverProduction())
-						reducer(st0, next, prod, kids, path);
-					else
-						reducerRecoverProduction(st0, next, prod, kids, path);
-				}
-			}
+			
+			if (PARSE_TIME_LAYOUT_FITER &&
+			    !layoutFilter.hasValidLayout(prod.label, kids)) {
+			  layoutFiltering++;
+			  continue;
+			}
+			else if (PARSE_TIME_LAYOUT_FITER)
+			  layoutFiltering += layoutFilter.getDisambiguationCount();
+			
+			if (ENFORCE_NEWLINE_FITER && 
+          parseTable.getLabel(prod.label).getAttributes().isNewlineEnforced()) {
+        boolean hasNewline = false;
+        for (int j = kids.length - 1; j >= 0; j--) {
+          int status = kids[j].getLayoutStatus();
+          
+          if (status == AbstractParseNode.NEWLINE_LAYOUT) {
+            hasNewline = true;
+            break;
+          }
+          if (status == AbstractParseNode.OTHER_LAYOUT) {
+            hasNewline = false;
+            break;
+          }
+        }
+        
+        if (!hasNewline) {
+          enforcedNewlineSkip++;
+          continue;
+        }
+      }
+
+
+			if(!prod.isRecoverProduction())
+				reducer(st0, next, prod, kids, path);
+			else
+				reducerRecoverProduction(st0, next, prod, kids, path);				
 		}
 
 		if (asyncAborted) {
@@ -676,72 +744,62 @@
 		}
 	}
 
-	private boolean checkMaxRecoverCount(Production prod, final Path path) {
-		return checkRecoverCountLocal(prod, path) && checkRecoverCountGlobal(prod, path);
-	}
-
-	private boolean checkRecoverCountLocal(Production prod, final Path path) {
-		return !isFineGrainedMode || 
-			calcRecoverCount(prod, path) <= fineGrainedRecoverMax || 
-			getHistory().getTokenIndex() - path.getLength() < fineGrainedStartLocation; //large reduction
-	}
-
-	private boolean checkRecoverCountGlobal(Production prod, final Path path) {
-		return calcRecoverCount(prod, path) <= this.recoverIntegrator.getMaxNumberOfRecoverApplicationsGlobal();
-	}
-
-	private boolean isReductionOverCursorLocation(final Path path) {
-		return getParserLocation() - path.getLength() < cursorLocation;
-	}
 	
-	private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) {
+	private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) throws InterruptedException {
 		assert(!prod.isRecoverProduction());
 		logBeforeReducer(s, prod, path.getLength());
 		increaseReductionCount();
 
+//		final boolean illegalLayout = !layoutFilter.hasValidLayout(prod, kids, parseTable);
 		final int length = path.getLength();
 		final int numberOfRecoveries = calcRecoverCount(prod, path);
-		final int recoverWeight = calcRecoverWeight(prod, path);
-		final AbstractParseNode t = prod.apply(kids);
+		final AbstractParseNode t = prod.apply(kids, 
+		                                       path.getParentCount() > 0 ? path.getParent().getLink().getLine() : lineNumber, 
+		                                       path.getParentCount() > 0 ? path.getParent().getLink().getColumn() : columnNumber,
+		                                       parseTable.getLabel(prod.label).isLayout(),
+		                                       parseTable.getLabel(prod.label).getAttributes().isIgnoreLayout());
 		final Frame st1 = findStack(activeStacks, s);
 
 		if (st1 == null) {
 			// Found no existing stack with for state s; make new stack
-			addNewStack(st0, s, prod, length, numberOfRecoveries, recoverWeight, t);
+			Link nl = addNewStack(st0, s, prod, length, numberOfRecoveries, t);
+//			if (illegalLayout) {
+//			  nl.reject();
+//			}
 		} else {
 			/* A stack with state s exists; check for ambiguities */
 			Link nl = st1.findDirectLink(st0);
 
 			if (nl != null) {
-				logAmbiguity(st0, prod, st1, nl);
-				if (prod.isRejectProduction()) {
-					nl.reject();
-				} 
-				if(recoverWeight == 0 && nl.recoverWeight == 0 || nl.isRejected()) {
-					createAmbNode(t, nl);
-				} else if (recoverWeight < nl.recoverWeight) {
-					nl.label = t;
-					nl.recoverCount = numberOfRecoveries;
-					nl.recoverWeight = recoverWeight;
-					actorOnActiveStacksOverNewLink(nl);
-				} else if (recoverWeight == nl.recoverWeight) {
-					nl.label = t;
-				}
-			} else {
-				nl = st1.addLink(st0, t, length);
-				nl.recoverWeight = recoverWeight;
-				nl.recoverCount = numberOfRecoveries;
-				if (prod.isRejectProduction()) {
-					nl.reject();
-					increaseRejectCount();
-				}
-				logAddedLink(st0, st1, nl);
-				actorOnActiveStacksOverNewLink(nl);
-			}
-		}
-		if(Tools.tracing) {
-			TRACE_ActiveStacks();
-			TRACE("SG_ - reducer done");
+        logAmbiguity(st0, prod, st1, nl);
+        if (prod.isRejectProduction()) {
+          nl.reject();
+        } 
+//        else if (illegalLayout) {
+//          nl.reject();
+//        }
+        if(numberOfRecoveries == 0 && nl.recoverCount == 0 || nl.isRejected()) {
+          createAmbNode(t, nl);
+        } else if (numberOfRecoveries < nl.recoverCount) {
+          nl.label = t;
+          nl.recoverCount = numberOfRecoveries;
+          actorOnActiveStacksOverNewLink(nl);
+        } else if (numberOfRecoveries == nl.recoverCount) {
+          nl.label = t;
+        }
+      } else {
+        nl = st1.addLink(st0, t, length, t.getLine(), t.getColumn());
+        nl.recoverCount = numberOfRecoveries;
+        if (prod.isRejectProduction()) {
+          nl.reject();
+          increaseRejectCount();
+        }
+//        else if (illegalLayout) {
+//          nl.reject();
+//        }
+        logAddedLink(st0, st1, nl);
+        actorOnActiveStacksOverNewLink(nl);
+      }
 		}
 	}
 	
@@ -749,27 +807,25 @@
 		assert(prod.isRecoverProduction());
 		final int length = path.getLength();
 		final int numberOfRecoveries = calcRecoverCount(prod, path);
-		final int recoverWeight = calcRecoverWeight(prod, path);
-		final AbstractParseNode t = prod.apply(kids);
+		final AbstractParseNode t = prod.apply(kids, lineNumber, columnNumber, parseTable.getLabel(prod.label).isLayout(), parseTable.getLabel(prod.label).getAttributes().isIgnoreLayout());
 		final Frame stActive = findStack(activeStacks, s);
-		if(stActive != null){
+		if(stActive!=null){
 			Link lnActive=stActive.findDirectLink(st0);
 			if(lnActive!=null){
 				return; //TODO: ambiguity
 			}
 		}
 		final Frame stRecover = findStack(recoverStacks, s);
-		if(stRecover != null){
+		if(stRecover!=null){
 			Link nlRecover = stRecover.findDirectLink(st0);
-			if(nlRecover != null){
+			if(nlRecover!=null){
 				return; //TODO: ambiguity
 			}
-			nlRecover = stRecover.addLink(st0, t, length);
+			nlRecover = stRecover.addLink(st0, t, length, t.getLine(), t.getColumn());
 			nlRecover.recoverCount = numberOfRecoveries;
-			nlRecover.recoverWeight = recoverWeight;
 			return;
 		}
-		addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, recoverWeight, t);
+		addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
 	}
 
 	private void createAmbNode(AbstractParseNode t, Link nl) {
@@ -780,14 +836,13 @@
 	/**
 	 * Found no existing stack with for state s; make new stack
 	 */
-	private void addNewStack(Frame st0, State s, Production prod, int length,
-			int numberOfRecoveries, int recoverWeight, AbstractParseNode t) {
+	private Link addNewStack(Frame st0, State s, Production prod, int length,
+			int numberOfRecoveries, AbstractParseNode t) {
 
 		final Frame st1 = newStack(s);
-		final Link nl = st1.addLink(st0, t, length);
+		final Link nl = st1.addLink(st0, t, length, t.getLine(), t.getColumn());
 
 		nl.recoverCount = numberOfRecoveries;
-		nl.recoverWeight = recoverWeight;
 		addStack(st1);
 		forActorDelayed.addFirst(st1);
 
@@ -802,24 +857,25 @@
 			nl.reject();
 			increaseRejectCount();
 		}
+		
+		return nl;
 	}
 
 	/**
 	 *  Found no existing stack with for state s; make new stack
 	 */
 	private void addNewRecoverStack(Frame st0, State s, Production prod, int length,
-			int numberOfRecoveries, int recoverWeight, AbstractParseNode t) {
-		if (!(isFineGrainedMode && !prod.isRejectProduction())) {
+			int numberOfRecoveries, AbstractParseNode t) {
+		if (!(fineGrainedOnRegion && !prod.isRejectProduction())) {
 			return;
 		}
 		final Frame st1 = newStack(s);
-		final Link nl = st1.addLink(st0, t, length);
+		final Link nl = st1.addLink(st0, t, length, t.getLine(), t.getColumn());
 		nl.recoverCount = numberOfRecoveries;
-		nl.recoverWeight = recoverWeight;
 		recoverStacks.addFirst(st1);
 	}
 
-	private void actorOnActiveStacksOverNewLink(Link nl) {
+	private void actorOnActiveStacksOverNewLink(Link nl) throws InterruptedException {
 		// Note: ActiveStacks can be modified inside doLimitedReductions
 		// new elements may be inserted at the beginning
 		final int sz = activeStacks.size();
@@ -836,7 +892,7 @@
 			}
 
 			for (final Action action : st2.peek().getActions()) {
-				if (action.accepts(getCurrentToken())) {
+				if (action.accepts(currentToken)) {
 					for (final ActionItem ai : action.getActionItems()) {
 						switch(ai.type) {
 						case ActionItem.REDUCE:
@@ -858,23 +914,142 @@
 
 	private int calcRecoverCount(Production prod, Path path) {
 		int result = path.getRecoverCount();
-		if (prod.isRecoverProduction() || prod.isCompletionProduction()){
-			result += 1;
-		}
-		return result;
-	}
-
-	private int calcRecoverWeight(Production prod, Path path) {
-		int result = path.getRecoverWeight();
-		if (prod.isRecoverProduction() || prod.isCompletionProduction()){
+		if (prod.isRecoverProduction()){
 			result += 1;
-			if (path.getLength() > 0 && !prod.isCompletionProduction())
+			if (path.getLength() > 0)
 				result += 1; //Hack: insertion rules (length 0) should be preferred above water rules.
 		}
 		return result;
 	}
 
-	private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
+	
+	int count = 0;
+	int count2 = 0;
+	
+	
+//	private class LongestMatchKey {
+//	  private AbstractParseNode n1, n2;
+//	  public LongestMatchKey(AbstractParseNode n1, AbstractParseNode n2) { this.n1 = n1; this.n2 = n2; }
+//	  @Override public int hashCode() { return (9 << n1.hashCode()) + n2.hashCode(); }
+//	  @Override public boolean equals(Object o) { 
+//	    return o instanceof LongestMatchKey && ((LongestMatchKey) o).n1 == n1 && ((LongestMatchKey) o).n2 == n2;
+//	  }
+//	}
+//	private Map<LongestMatchKey, Integer> longestMatchCache = new HashMap<LongestMatchKey, Integer>();
+//	
+//	@SuppressWarnings("null")
+//  private AbstractParseNode filterLongestMatch(AbstractParseNode t1, AbstractParseNode t2) {
+//	  if (t1.isParseRejectNode() || t2.isParseRejectNode())
+//	    return null;
+//	  
+//	  System.out.println(t1.toString());
+//	  System.out.println(t2.toString());
+//	  
+//	  Stack<AbstractParseNode[]> stack = new Stack<AbstractParseNode[]>();
+//	  stack.push(new AbstractParseNode[] {t1, t2});
+//
+//	  LinkedList<LongestMatchKey> done = new LinkedList<LongestMatchKey>();
+//	  
+//	  AbstractParseNode res = null;
+//	  
+//	  while (!stack.isEmpty()) {
+//	    AbstractParseNode[] ns = stack.pop();
+//	    AbstractParseNode n1 = ns[0];
+//	    AbstractParseNode n2 = ns[1];
+//	  
+//	    if (n1.equals(n2))
+//	      continue;
+//	    
+//	    LongestMatchKey key = new LongestMatchKey(n1, n2);
+//	    Integer prevRes = longestMatchCache.get(key);
+//	    if (prevRes != null) {
+//	      AbstractParseNode newres = prevRes == -1 ? null : (prevRes == 0 ? t1 : t2);
+//	      if (res != null && res != newres) {
+//	        res = null;
+//	        break;
+//	      }
+//	      if (newres == null)
+//	        continue;
+//	      
+//	      res = newres;
+//	      break;
+//	    }
+//	    
+//	    Label l1 = n1.isAmbNode() ? null : parseTable.getLabel(n1.getLabel());
+//	    Label l2 = n2.isAmbNode() ? null : parseTable.getLabel(n2.getLabel());
+//	    
+//      if (n1.isAmbNode() || n2.isAmbNode()) {
+//        AbstractParseNode[] n1Array = n1.isAmbNode() ? n1.getChildren() : new AbstractParseNode[] {n1};
+//        AbstractParseNode[] n2Array = n2.isAmbNode() ? n2.getChildren() : new AbstractParseNode[] {n2};
+//        
+//        for (int i = 0; i < n1Array.length; i++)
+//          for (int j = 0; j < n2Array.length; j++) {
+//            if (!n1Array[i].isParseRejectNode() && !n2Array[j].isParseRejectNode())
+//              stack.push(new AbstractParseNode[] {n1Array[i], n2Array[j]});
+//          }
+//        continue;
+//      }
+//
+//	    else if (l1 != null && l1.getAttributes().isLongestMatch() && 
+//	             (l2 == null || !l2.getAttributes().isLongestMatch())) {
+//	      if (res == t2) {
+//	        res = null;
+//	        break;
+//	      }
+//	      res = t1;
+//	      break;
+//	    }
+//
+//      else if (l2 != null && l2.getAttributes().isLongestMatch() &&
+//               (l1 == null || !l1.getAttributes().isLongestMatch())) {
+//        if (res == t1) {
+//          res = null;
+//          break;
+//        }
+//        res = t2;
+//        break;
+//      }
+//	    
+//      else if (n1.getLabel() != n2.getLabel())
+//        continue;
+//
+//      else if (l1 != null && l2 != null &&
+//          l1.equals(l2) && l1.getAttributes().isLongestMatch()) {
+//        int[] end1 = n1.getEnd();
+//        int[] end2 = n2.getEnd();
+//        if (end1[0] > end2[0] || end1[0] == end2[0] && end1[1] > end2[1]) {
+//          if (res == t2) {
+//            res = null;
+//            break;
+//          }
+//          res = t1;
+//          break;
+//        }
+//        else if (end2[0] > end1[0] || end2[0] == end1[0] && end2[1] > end1[1]) {
+//          if (res == t1) {
+//            res = null;
+//            break;
+//          }
+//          res = t2;
+//          break;
+//        }
+//      }
+//	    
+//      done.add(key);
+//
+//      for (int i = n1.getChildren().length - 1; i >= 0; i--)
+//        stack.push(new AbstractParseNode[] {n1.getChildren()[i], n2.getChildren()[i]});
+//	  }
+//	  
+//	  int val = res == t1 ? 0 : (res == t2 ? 1 : -1);
+//	  for (LongestMatchKey key : done)
+//	    longestMatchCache.put(key, val);
+//	  
+//	  return res;
+//	}
+	
+	
+  private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
 		if(Tools.tracing) {
 			TRACE("SG_InReduceStacks() - " + frame.state.stateNumber);
 		}
@@ -936,6 +1111,7 @@
 
 		final int ch = currentInputStream.read();
 		updateLineAndColumnInfo(ch);
+		
 		if(ch == -1) {
 			return SGLR.EOF;
 		}
@@ -948,6 +1124,9 @@
 		if (Tools.debugging) {
 			Tools.debug("getNextToken() - ", ch, "(", (char) ch, ")");
 		}
+		
+		lastLineNumber = lineNumber;
+		lastColumnNumber = columnNumber;
 
 		switch (ch) {
 		case '\n':
@@ -978,9 +1157,9 @@
 	}
 
 	AmbiguityManager getAmbiguityManager() {
-		return ambiguityManager;
+	  return ambiguityManager;
 	}
-
+	
 	public Disambiguator getDisambiguator() {
 		return disambiguator;
 	}
@@ -1013,7 +1192,7 @@
 	private static int traceCallCount = 0;
 
 	static void TRACE(String string) {
-		System.err.println("[" + traceCallCount + "] " + string);
+		System.out.println("[" + traceCallCount + "] " + string + "\n");
 		traceCallCount++;
 	}
 
@@ -1113,7 +1292,7 @@
 
 	private void logCurrentToken() {
 		if (isLogging()) {
-			Tools.logger("Current token (#", tokensSeen, "): ", logCharify(getCurrentToken()));
+			Tools.logger("Current token (#", tokensSeen, "): ", logCharify(currentToken));
 		}
 	}
 
@@ -1132,13 +1311,13 @@
 
 		if (Tools.logging) {
 			Tools.logger("#", tokensSeen, ": shifting ", forShifter.size(), " parser(s) -- token ",
-					logCharify(getCurrentToken()), ", line ", lineNumber, ", column ", columnNumber);
+					logCharify(currentToken), ", line ", lineNumber, ", column ", columnNumber);
 		}
 
 		if (Tools.debugging) {
 			Tools.debug("shifter() - " + dumpActiveStacks());
 
-			Tools.debug(" token   : " + getCurrentToken());
+			Tools.debug(" token   : " + currentToken);
 			Tools.debug(" parsers : " + forShifter.size());
 		}
 	}
@@ -1180,7 +1359,7 @@
 		List<ActionItem> actionItems = null;
 
 		if (Tools.debugging || Tools.tracing) {
-			actionItems = s.getActionItems(getCurrentToken());
+			actionItems = s.getActionItems(currentToken);
 		}
 
 		if(Tools.tracing) {
@@ -1194,7 +1373,7 @@
 
 		if (Tools.debugging) {
 			Tools.debug(" state   : ", s.stateNumber);
-			Tools.debug(" token   : ", getCurrentToken());
+			Tools.debug(" token   : ", currentToken);
 		}
 
 		if (Tools.debugging) {
@@ -1259,7 +1438,7 @@
 
 	private void logReductionInfo(Frame st, Production prod) {
 		Tools.debug(" state : ", st.peek().stateNumber);
-		Tools.debug(" token : ", getCurrentToken());
+		Tools.debug(" token : ", currentToken);
 		Tools.debug(" label : ", prod.label);
 		Tools.debug(" arity : ", prod.arity);
 		Tools.debug(" stack : ", st.dumpStack());
@@ -1283,7 +1462,7 @@
 		}
 
 		if (Tools.logging) {
-			Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(getCurrentToken()),
+			Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(currentToken),
 					", production: ", prod.label);
 		}
 
@@ -1291,7 +1470,7 @@
 			Tools.debug("reducer() - ", dumpActiveStacks());
 
 			Tools.debug(" state      : ", s.stateNumber);
-			Tools.debug(" token      : ", logCharify(getCurrentToken()) + " (" + getCurrentToken() + ")");
+			Tools.debug(" token      : ", logCharify(currentToken) + " (" + currentToken + ")");
 			Tools.debug(" production : ", prod.label);
 		}
 	}
@@ -1319,15 +1498,7 @@
 		}
 	}
 
-	protected void setCurrentToken(int currentToken) {
-		this.currentToken = currentToken;
-		if(currentToken == -1)
-			this.currentToken=SGLR.EOF;
-	}
-
-	protected int getCurrentToken() {
-		assert(currentToken >= 0);
-		return currentToken;
-	}
-
+  public AbstractParseNode getParseTree() {
+    return parseTree;
+  }
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/Shift.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Shift.java
--- src/org/spoofax/jsglr/client/Shift.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Shift.java	2012-09-28 00:32:15.000000000 +0200
@@ -8,6 +8,7 @@
 package org.spoofax.jsglr.client;
 
 
+
 public class Shift extends ActionItem {
 
     private static final long serialVersionUID = -5777912109162535928L;
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/StructureSkipSuggestion.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/StructureSkipSuggestion.java
--- src/org/spoofax/jsglr/client/StructureSkipSuggestion.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/StructureSkipSuggestion.java	2012-09-28 00:32:16.000000000 +0200
@@ -1,6 +1,7 @@
 package org.spoofax.jsglr.client;
 
 
+
 public class StructureSkipSuggestion {
     
     private IndentInfo startSkip;
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java
--- src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/DamagedTokenAnalyzer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,175 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import java.util.ArrayList;
-import org.spoofax.jsglr.client.editregion.detection.LCS;
-import org.spoofax.jsglr.client.imploder.IToken;
-import org.spoofax.jsglr.client.imploder.ITokenizer;
-import org.spoofax.jsglr.client.imploder.Token;
-
-/**
- * Determines the tokens in the correct term that are (possible) damaged
- * by either the deletion of characters that form the token,
- * or the insertion of characters between the start and end character of the token.   
- * Example insertion: private => priva$te 
- * Example deletion: private => privte 
- * @author Maartje de Jonge
- *
- */
-public class DamagedTokenAnalyzer {
-
-	private final ITokenizer tokens;
-	private final LCS<Character> lcs;
-	
-	//filled in the token stream analysis
-	private final ArrayList<IToken> tokensDamagedByInsertion;
-	private final ArrayList<IToken> tokensDamagedByDeletion;
-
-	/**
-	 * Returns tokens in token stream
-	 * @return
-	 */
-	public ITokenizer getTokens() {
-		return tokens;
-	}
-
-	/**
-	 * Returns all tokens in the correct term that are (possible) damaged by
-	 * the insertion of characters between the start and end character of the token.   
-	 * Example: private => priva$te 
-	 */
-	public ArrayList<IToken> getTokensDamagedByInsertion() {
-		ArrayList<IToken> result = new ArrayList<IToken>();
-		result.addAll(tokensDamagedByInsertion);
-		return result;
-	}
-
-	/**
-	 * Returns all tokens in the correct term that are (possible) damaged by
-	 * the deletion of characters that form the token.   
-	 * Example: private => privte 
-	 */
-	public ArrayList<IToken> getTokensDamagedByDeletion() {
-		ArrayList<IToken> result = new ArrayList<IToken>();
-		result.addAll(tokensDamagedByDeletion);
-		return result;
-	}
-	
-	/**
-	 * Determines the tokens in the correct term that are (possible) damaged
-	 * by edit operations.
-	 */
-	public DamagedTokenAnalyzer(ITokenizer tokens, LCS<Character> lcs){
-		this.tokens = tokens;
-		this.lcs = lcs;
-		this.tokensDamagedByInsertion = new ArrayList<IToken>();
-		this.tokensDamagedByDeletion = new ArrayList<IToken>();
-		analyzeDamagedTokens();
-	}
-
-	/**
-	 * Says whether a token in the (correctly) parsed input has deleted characters in the (possible) erroneous input 
-	 * @param t
-	 * @return
-	 */
-	public boolean isDamagedByDeletion(IToken t) {
-		ArrayList<Integer> deletions = getOffsetsDeletions(t);
-		return !deletions.isEmpty();
-	}
-
-	/**
-	 * Returns the offsets of characters in the token that are deleted in the (possible) erroneous input 
-	 * @param t
-	 * @return
-	 */
-	public ArrayList<Integer> getOffsetsDeletions(IToken t) {
-		int startOffset = t.getStartOffset();
-		int endOffset = t.getEndOffset();
-		ArrayList<Integer> deletions = new ArrayList<Integer>();		
-		for (int j = startOffset; j <= endOffset; j++) {
-			if(lcs.getMatchIndexInElems2(j) == -1){
-				deletions.add(j);
-			}
-		}
-		return deletions;
-	}
-	
-	/**
-	 * Says whether a token in the (correctly) parsed input has inserted characters in the (possible) erroneous input 
-	 * @param t
-	 * @return
-	 */
-	public boolean isDamagedByInsertion(IToken t) {
-		int startOffset = t.getStartOffset();
-		int endOffset = t.getEndOffset();		
-		int offsetPreviousMatch = -1;
-		for (int j = startOffset; j <= endOffset; j++) {
-			int matchIndexInElems2 = lcs.getMatchIndexInElems2(j);
-			if(offsetPreviousMatch != -1 && matchIndexInElems2 > offsetPreviousMatch + 1){
-				return true;
-			}
-			offsetPreviousMatch = matchIndexInElems2;
-		}
-		return false;
-	}
-	
-
-	/**
-	 * Says whether a token is a layout token between two non-layout tokens that has been completely removed,
-	 * and therefore may affect the parse result.
-	 * @param token
-	 * @return
-	 */
-	public boolean isDamagingLayoutDeletion(IToken token) {
-		int numberOfDeletions = getOffsetsDeletions(token).size();
-		int startOffset = token.getStartOffset();
-		int endOffset = token.getEndOffset();
-		if (numberOfDeletions == endOffset - startOffset + 1){ //full deletion
-			int firstMatchedOffsetInPrefix = -1;
-			int firstMatchedOffsetInSuffix = -1;
-			for (int offsetInPrefix = startOffset -1; offsetInPrefix >= 0; offsetInPrefix--) {
-				if(lcs.getMatchIndexInElems2(offsetInPrefix) != -1){
-					firstMatchedOffsetInPrefix = offsetInPrefix;
-					break;
-				}
-			}
-			for (int offsetInSuffix = endOffset + 1; offsetInSuffix < lcs.getElems1().size(); offsetInSuffix++) {
-				if(lcs.getMatchIndexInElems2(offsetInSuffix) != -1){
-					firstMatchedOffsetInSuffix = offsetInSuffix;
-					break;
-				}
-			}
-			int firstMatchedOffsetInPrefix_2 = lcs.getMatchIndexInElems2(firstMatchedOffsetInPrefix);
-			int firstMatchedOffsetInSuffix_2 = lcs.getMatchIndexInElems2(firstMatchedOffsetInSuffix);
-			return //checks if all layout is deleted between the surrounding tokens in elems2
-				firstMatchedOffsetInSuffix_2 == firstMatchedOffsetInPrefix_2 + 1 && //no insertions that are discarded as whitespace
-				firstMatchedOffsetInPrefix_2 != -1 &&
-				firstMatchedOffsetInSuffix_2 != -1 &&
-				!isOffsetOfLayoutChar(token.getTokenizer(), firstMatchedOffsetInPrefix) &&
-				!isOffsetOfLayoutChar(token.getTokenizer(), firstMatchedOffsetInSuffix);
-		}
-		return false;
-	}
-
-	private boolean isOffsetOfLayoutChar(ITokenizer tokens, int offset) {
-		boolean precedingLayout = tokens.getTokenAtOffset(offset).getKind() == Token.TK_LAYOUT;
-		return precedingLayout;
-	}
-	
-	private void analyzeDamagedTokens() {
-		for (int i = 0; i < tokens.getTokenCount(); i++) {
-			IToken t = tokens.getTokenAt(i);
-			//hack to improve the performance
-			boolean possibleDamaged = 
-				t.getEndOffset() >= lcs.getMatchedPrefixSize() - 1 && 
-				t.getStartOffset() <= lcs.getElems1().size() - lcs.getMatchedSuffixSize() + 1; 
-			if(possibleDamaged){
-				if (isDamagedByDeletion(t)){
-					tokensDamagedByDeletion.add(t);
-				}
-				if (isDamagedByInsertion(t)){
-					tokensDamagedByInsertion.add(t);
-				}
-			}
-		}
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java
--- src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/DiscardableRegion.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,253 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import java.util.ArrayList;
-import java.util.Collections;
-
-/**
- * Fragment in the source code that represents a (possibly broken) construct
- * that (presumably) can be discarded safely, e.g., without invalidating the parse input.
- * @author maartje
- */
-public class DiscardableRegion{
-	
-//private fields
-	
-	private final int startOffset;
-	private final int endOffset;
-	private final String inputString;
-	
-
-//constructor
-	
-	/**
-	 * Fragment in the source code that represents a (possibly broken) construct
-	 * that can be discarded safely, e.g., without invalidating the parse input.
-	 */
-	public DiscardableRegion(int startOffset, int endOffset, String inputString){
-		this.startOffset = startOffset;
-		this.endOffset = endOffset;
-		this.inputString = inputString;
-		assert inputString != null;
-		assert startOffset <= endOffset;
-		assert startOffset >= 0;
-		assert endOffset <= inputString.length() - 1;
-	}
-
-//getters
-	
-	/**
-	 * Returns the start offset of the discardable code fragment
-	 * @return start offset
-	 */
-	public int getStartOffset() {
-		return startOffset;
-	}
-
-	/**
-	 * Returns the end offset of the discardable code fragment
-	 * @return end offset
-	 */
-	public int getEndOffset() {
-		return endOffset;
-	}
-
-	/**
-	 * Returns the term associated to the discardable code fragment.
-	 * Can be null in case the discarded region is a comment, or in case the abstract representation is not known.
-	 * @return term
-	 */
-	public String getInputString() {
-		return inputString;
-	}
-	
-//public functions
-	
-	/**
-	 * Returns a recovered input String by replacing erroneous regions by whitespaces
-	 * @param regions
-	 * @param input
-	 * @return
-	 */
-	public static String replaceAllRegionsByWhitespace(ArrayList<DiscardableRegion> regions, String input) {
-		String result = input;
-		for (DiscardableRegion region : regions) {
-			assert region.getInputString() == input;
-			result = replaceRegionByWhitespace(region, result);
-		}
-		return result;
-	}
-	
-	/**
-	 * Construct regions by grouping subsequent offsets
-	 * @param offsets
-	 * @param inputString
-	 * @return
-	 */
-	public static ArrayList<DiscardableRegion> constructRegionsFromOffsets(ArrayList<Integer> offsets, String inputString){
-		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();
-		int startOffset = -1;
-		for (int i = 0; i < offsets.size(); i++) {
-			int offset = offsets.get(i);
-			if(i==0){
-				startOffset = offsets.get(i);
-			}
-			else if (offset != offsets.get(i-1) + 1){
-				DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(i-1), inputString);
-				result.add(region);
-				startOffset = offsets.get(i);
-			}
-		}
-		if(startOffset != -1){
-			DiscardableRegion region = new DiscardableRegion(startOffset, offsets.get(offsets.size()-1), inputString);
-			result.add(region);
-		}
-		return result;		
-	}
-	
-	/**
-	 * Returns all offsets covered by the regions
-	 * @param editRegions
-	 * @return
-	 */
-	public static ArrayList<Integer> getOffsets(ArrayList<DiscardableRegion> editRegions) {
-		ArrayList<Integer> result = new ArrayList<Integer>();
-		for (DiscardableRegion region : editRegions) {
-			int startOffset = region.getStartOffset();
-			int endOffset = region.getEndOffset();
-			for (int offset = startOffset; offset <= endOffset; offset++) {
-				// "regions can overlap, for example: term + separation and comment in separation";
-				if(!result.contains(offset))
-					result.add(offset);
-			}
-		}
-		Collections.sort(result);
-		return result;
-	}
-
-	public static ArrayList<DiscardableRegion> mergeSubsequentRegions(ArrayList<DiscardableRegion> regions){
-		ArrayList<DiscardableRegion> merged = new ArrayList<DiscardableRegion>();
-		if(!regions.isEmpty()){
-			merged.add(regions.get(0));
-		}
-		int index = 1;
-		while (index < regions.size()) {
-			DiscardableRegion r1 = merged.get(0);
-			DiscardableRegion r2 = regions.get(index);
-			assert r2.getEndOffset() > r1.getStartOffset() : "input regions should be ordered"; 
-			if(r1.getEndOffset() + 1 < r2.getStartOffset()){
-				merged.add(r2);
-			}
-			else {
-				int startOffset = Math.min(r1.getStartOffset(), r2.getStartOffset());
-				int endOffset = Math.max(r1.getEndOffset(), r2.getEndOffset());
-				assert r1.getInputString() == r2.getInputString();
-				DiscardableRegion mergedRegion = new DiscardableRegion(startOffset, endOffset, r1.getInputString());
-				merged.set(merged.size()-1, mergedRegion);
-			}
-			index ++;
-		}
-		assert merged.size() <= regions.size();
-		return merged;
-	}
-
-	/**
-	 * Merges ordered region lists so that the resulting lists is ordered and merges overlapping regions
-	 * @param regions1
-	 * @param regions2
-	 * @return
-	 */
-	public static ArrayList<DiscardableRegion> mergeRegions(ArrayList<DiscardableRegion> regions1, ArrayList<DiscardableRegion> regions2){
-		ArrayList<DiscardableRegion> merged = new ArrayList<DiscardableRegion>();
-		int index_r1 = 0;
-		int index_r2 = 0;
-		while (index_r1 < regions1.size() && index_r2 < regions2.size()) {
-			DiscardableRegion r1 = regions1.get(index_r1);			
-			DiscardableRegion r2 = regions2.get(index_r2);
-			if(r1.getEndOffset() < r2.getStartOffset()){
-				merged.add(r1);
-				index_r1 ++;
-			}
-			else if(r2.getEndOffset() < r1.getStartOffset()){
-				merged.add(r2);
-				index_r2 ++;
-			}
-			else {
-				int startOffset = Math.min(r1.getStartOffset(), r2.getStartOffset());
-				int endOffset = Math.max(r1.getEndOffset(), r2.getEndOffset());
-				assert r1.getInputString() == r2.getInputString();
-				DiscardableRegion mergedRegion = new DiscardableRegion(startOffset, endOffset, r1.getInputString());
-				merged.add(mergedRegion);
-				index_r1++;
-				index_r2++;
-			}
-		}
-		while (index_r1 < regions1.size()) {
-			DiscardableRegion r1 = regions1.get(index_r1);
-			merged.add(r1);
-			index_r1 ++;
-		}
-		while (index_r2 < regions2.size()) {
-			DiscardableRegion r2 = regions2.get(index_r2);
-			merged.add(r2);
-			index_r2++;
-		}
-		return merged;
-	}
-	
-	/**
-	 * Constructs the list of text fragments represented by the regions
-	 * @param regions
-	 * @return
-	 */
-	public static ArrayList<String> constructFragments(ArrayList<DiscardableRegion> regions) {
-		ArrayList<String> result = new ArrayList<String>();
-		for (DiscardableRegion region : regions) {
-			String fragment = region.constructFragment();
-			result.add(fragment);
-		}
-		return result;
-	}
-
-	/**
-	 * Constructs the discarded fragment
-	 * @return
-	 */
-	public String constructFragment() {
-		return inputString.substring(getStartOffset(), getEndOffset() + 1);
-	}
-	
-	/**
-	 * Includes preceding and succeeding layout (to be used with the permissive grammars technique) 
-	 * @return
-	 */
-	public DiscardableRegion extendRegionWithWhitespace(){
-		int start = this.startOffset;
-		while(start > 0 && Character.isWhitespace(this.inputString.charAt(start-1))){
-			start -= 1;
-		}
-		int end = this.endOffset;
-		while(end < inputString.length()-2 && Character.isWhitespace(this.inputString.charAt(end+1))){
-			end += 1;
-		}
-		return new DiscardableRegion(start, end, inputString);
-	}
-	
-	@Override
-	public String toString(){
-		return constructFragment();
-	}
-
-//private functions
-	
-	private static String replaceRegionByWhitespace(DiscardableRegion region, String modifiedInput) {
-		assert modifiedInput.length() == region.getInputString().length();
-		char[] chars = modifiedInput.toCharArray();
-		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
-			char charAtOffset = chars[offset];
-			if(!Character.isWhitespace(charAtOffset)){
-				chars[offset] = ' ';
-			}
-		}
-		return String.valueOf(chars);
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java
--- src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/EditRegionDetector.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,264 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import java.util.ArrayList;
-
-import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.client.imploder.ITokenizer;
-import org.spoofax.jsglr.client.imploder.ImploderAttachment;
-
-/**
- * Detects possible erroneous code constructs and comments
- * by comparing a possibly erroneous input string with a (similar) correctly parsed input string.
- * The correctly parsed input string is typically a prior, non-erroneous snapshot of the program being edited.
- * The discardable, erroneous code constructs can be used to construct a non-correcting recovery and to 
- * locate parse errors prior to applying a correcting recovery technique.
- * @author maartje
- */
-public class EditRegionDetector {
-
-	private final LCS<Character> lcs;
-	private final String erroneousInput;
-	private final IStrategoTerm correctAST;
-	
-	//discard recovery found after analyzing the correct AST/input and its deleted characters
-	private RecoverInterpretation discardRecovery;
-	private ArrayList<DiscardableRegion> discardableCommentRegions;
-
-
-//methods that access the correct parse input string
-
-	/**
-	 * Returns the input string of the correctly parsed AST
-	 * @return Correct input string used for comparison
-	 */
-	public String getCorrectInput(){
-		return ImploderAttachment.getTokenizer(correctAST).getInput();
-	}
-
-	/**
-	 * Returns the offsets of the characters that are deleted from the correct input (found by an LCS diff algorithm)
-	 * @return offsets of deleted characters
-	 */
-	public ArrayList<Integer> getDeletionOffsets(){
-		return lcs.getUnMatchedIndices1();		
-	}
-
-	/**
-	 * Returns the substrings that are deleted from the correct input
-	 * @return deleted substrings
-	 */
-	public ArrayList<String> getDeletedSubstrings(){
-		return constructSubstringsFromOffsets(getDeletionOffsets(), getCorrectInput());
-	}
-
-	/**
-	 * Returns the discarded regions of code that were edited, from the correct input 
-	 * @return discarded edit regions from the correct input
-	 */
-	public ArrayList<DiscardableRegion> getEditedRegionsCorrect(){
-		if(discardRecovery == null){
-			RecoverInterpretation emptyRecovery = RecoverInterpretation.createDiscardInterpretation(correctAST, null);
-			return emptyRecovery.getDamagedRegions();
-		}
-		return 
-				DiscardableRegion.mergeSubsequentRegions(
-						DiscardableRegion.mergeRegions(discardRecovery.getDamagedRegions(), discardableCommentRegions)
-				);
-	}
-	
-	/**
-	 * Returns the offsets of the chars that together form the discardable text fragments, from the correct input 
-	 * @return offsets of characters in discarded regions
-	 */
-	public ArrayList<Integer> getDiscardOffsetsCorrectInput() {
-		return DiscardableRegion.getOffsets(getEditedRegionsCorrect());
-	}
-	
-	/**
-	 * Returns the (discardable) terms that were edited, from the correct input 
-	 * @return discarded terms
-	 */
-	public ArrayList<IStrategoTerm> getEditedTerms(){
-		return discardRecovery.getDamagedTerms();
-	}	
-
-
-//methods that access the erroneous parse input string
-
-	/**
-	 * Returns the (possible) erroneous input string 
-	 * @return Erroneous input
-	 */
-	public String getErroneousInput(){
-		return erroneousInput;
-	}
-
-	/**
-	 * Returns the offsets of the characters that are inserted in the erroneous input (found by an LCS diff algorithm)
-	 * @return offsets of inserted characters
-	 */
-	public ArrayList<Integer> getInsertionOffsets(){
-		return lcs.getUnMatchedIndices2();
-	}
-
-	/**
-	 * Returns the substrings that are inserted in the erroneous input
-	 * @return inserted substrings
-	 */
-	public ArrayList<String> getInsertedSubstrings(){
-		return constructSubstringsFromOffsets(getInsertionOffsets(), getErroneousInput());
-	}
-
-	/**
-	 * Returns the discardable regions of code that were edited in the erroneous input
-	 * These regions may contain syntax errors. 
-	 * @return edited regions from erroneous input
-	 */
-	public ArrayList<DiscardableRegion> getEditedRegionsErroneous(){
-		ArrayList<DiscardableRegion> editsFromDeletions = mapRegions(getEditedRegionsCorrect(), true);
-		ArrayList<DiscardableRegion> editsFromInsertions = DiscardableRegion.constructRegionsFromOffsets(getInsertionOffsets(), this.getErroneousInput());
-		return 
-				DiscardableRegion.mergeSubsequentRegions(
-						DiscardableRegion.mergeRegions(editsFromDeletions, editsFromInsertions)
-				);
-	}
-
-	/**
-	 * Returns the offsets of the chars that together form the edited text fragments, 
-	 * from the erroneous input 
-	 * @return offsets of edit regions from erroneous input
-	 */
-	public ArrayList<Integer> getDiscardOffsetsErroneousInput() {
-		return DiscardableRegion.getOffsets(getEditedRegionsErroneous());
-	}
-
-// method for accessing the recovered input
-	
-	/**
-	 * Returns a (presumably) correct parse input based on the LCS of a correct and incorrect program.
-	 * The constructed parse input forms a (non-correcting) recovery of the erroneous input. 
-	 * The constructed parse input is obtained by replacing the characters in the erroneous regions by whitespaces.
-	 * @return recovered program
-	 */
-	public String getRecoveredInput(){
-		String recoveredProgram = DiscardableRegion.replaceAllRegionsByWhitespace(getEditedRegionsErroneous(), getErroneousInput());
-		//assert recoveredProgram.equals(replaceAllRegionByWhitespace(getEditedRegionsCorrect(), correctInput)); //modulo comments and layout
-		assert recoveredProgram.length() == getErroneousInput().length(): "whitespaces are inserted for characters in the edit regions";
-		return recoveredProgram;
-	}
-	
-	/**
-	 * Detects possible erroneous code constructs and comments
-	 * by comparing an input string with a very similar, correctly parsed, input string.
-	 * The correctly parsed input string is typically a prior (non-erroneous) snapshot of the program being edited.
-	 */	
-	public EditRegionDetector(IStrategoTerm correctAST, String erroneousInput){
-		this.correctAST = correctAST;
-		this.erroneousInput = erroneousInput;
-		lcs = new LCS<Character>(new LCSCommand<Character>() {
-			public boolean isMatch(Character c1, Character c2) {
-				return c1.charValue() == c2.charValue();
-			}});
-		detectEditRegions();
-	}
-	
-	private void detectEditRegions() {
-		ITokenizer tokens = ImploderAttachment.getTokenizer(correctAST);
-
-		long time = System.currentTimeMillis();
-		
-		// calculates offsets deleted characters (correct input), and offsets inserted characters (erroneous input)
-		constructCharacterMatching();
-		ArrayList<Integer> offsetsDeletedChars = lcs.getUnMatchedIndices1();
-		System.out.println("LCS: " + (System.currentTimeMillis()-time));
-		time = System.currentTimeMillis();
-		//TODO: LCS on lines (instead of characters) in case LCS optimized does not work to reduce the size enough
-		
-		DamagedTokenAnalyzer tokenEdits = new DamagedTokenAnalyzer(tokens, lcs);
-		System.out.println("token edits: " + (System.currentTimeMillis()-time));
-		time = System.currentTimeMillis();
-		//TODO: Improve performance!!
-
-		//removes from deletion offsets, all offsets of layout characters that are irrelevant for the parse result.
-		//detects all edited comment regions, since these may affect the parse result if they are broken.
-		LayoutEditsAnalyzer loAnalyzer = new LayoutEditsAnalyzer(tokenEdits);
-		this.discardableCommentRegions = loAnalyzer.getDamagedCommentRegions();
-		loAnalyzer.filterNonLayoutOffsets(offsetsDeletedChars);
-		System.out.println("layout edits: " + (System.currentTimeMillis()-time));
-		time = System.currentTimeMillis();
-
-		//extends deletion offsets so that all possible damaged tokens are covered
-		TerminalEditsAnalyzer terminalAnalyzer = new TerminalEditsAnalyzer(tokenEdits);
-		terminalAnalyzer.addDamagedTokensStartOffsets(offsetsDeletedChars);
-		System.out.println("terminal edits: " + (System.currentTimeMillis()-time));
-		time = System.currentTimeMillis();
-
-		//detects discardable regions that correspond to edited terms.
-		//NonTerminalEditsAnalyzer brokenConstructDetector = new NonTerminalEditsAnalyzer(correctAST, offsetsDeletedChars);
-		//this.discardableRegions = brokenConstructDetector.getDamagedTermRegions();
-		
-		//detects discardable regions that correspond to edited terms.
-		TermEditsAnalyzer brokenConstructDetector = new TermEditsAnalyzer(offsetsDeletedChars, correctAST);
-		this.discardRecovery = brokenConstructDetector.getDiscardRecovery();		
-		System.out.println("Term edits: " + (System.currentTimeMillis()-time));
-		time = System.currentTimeMillis();
-	}
-	
-
-
-// helper functions
-	private void constructCharacterMatching() {
-		ArrayList<Character> correctChars = asCharacterList(getCorrectInput());
-		ArrayList<Character> erroneousChars = asCharacterList(getErroneousInput());
-		//long startTime = System.currentTimeMillis();
-		lcs.createLCSResultsOptimized(correctChars, erroneousChars);
-		//System.out.println("duration lcs: " + (System.currentTimeMillis() - startTime));
-	}
-	
-	
-	private static ArrayList<Character> asCharacterList(String correctInput) {
-		ArrayList<Character> correctChars = new ArrayList<Character>();
-		for (int i = 0; i < correctInput.length(); i++) {
-			correctChars.add(correctInput.charAt(i));
-		}
-		return correctChars;
-	}
-
-	private DiscardableRegion mapRegion(DiscardableRegion region, boolean isInCorrectInputString){
-		String input = this.getCorrectInput();
-		if(isInCorrectInputString){
-			input = this.getErroneousInput();
-		}
-
-		int startOffset = -1;
-		int endOffset = -1;
-		for (int offset = region.getStartOffset(); offset <= region.getEndOffset(); offset++) {
-			int correspondingOffset = lcs.getMatchIndex(offset, isInCorrectInputString);
-			if(correspondingOffset != -1){
-				if(startOffset == -1)
-					startOffset = correspondingOffset;
-				endOffset = correspondingOffset;
-			}
-		}
-		if(startOffset >= 0){
-			return new DiscardableRegion(startOffset, endOffset, input);
-		}
-		return null;
-	}
-
-	private ArrayList<DiscardableRegion> mapRegions(ArrayList<DiscardableRegion> regions, boolean isInCorrectInputString){
-		ArrayList<DiscardableRegion> result = new ArrayList<DiscardableRegion>();		
-		for (DiscardableRegion region : regions) {
-			DiscardableRegion mappedRegion = mapRegion(region, isInCorrectInputString);
-			if(mappedRegion != null)
-				result.add(mappedRegion);
-		}
-		return result;
-	}
-	
-
-	private ArrayList<String> constructSubstringsFromOffsets(ArrayList<Integer> offsets, String inputString){
-		ArrayList<DiscardableRegion> regions = DiscardableRegion.constructRegionsFromOffsets(offsets, inputString);
-		return DiscardableRegion.constructFragments(regions);
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java
--- src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/HelperFunctions.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getSort;
-
-import java.util.List;
-
-import org.spoofax.interpreter.terms.IStrategoAppl;
-import org.spoofax.interpreter.terms.IStrategoTerm;
-
-/**
- * Helper functions
- * @author maartje
- */
-public class HelperFunctions {
-	
-	/**
-	 * Returns true if this collection contains the specified element. 
-	 * More formally, returns true if and only if this collection contains at least one element e 
-	 * such that (o==null ? e==null : elem == e).
-	 * @param lst List
-	 * @param elem Element
-	 * @return true iff for some element E in List, E == elem 
-	 */
-	public static <T> boolean contains(List<T> lst, T elem) {
-		for (T lstElem : lst) {
-			if(lstElem == elem){
-				return true;
-			}
-		}
-		return false;
-	}
-
-	/**
-	 * Gets the sort or, for lists and list elements, the Elem* sort associated to the (parent)list 
-	 * @param term
-	 * @param parent
-	 * @return
-	 */
-	public static String getGeneralSort(IStrategoTerm term, IStrategoTerm parent) {
-		String termSort = getSort(term);
-		if(parent != null){
-			if(parent.isList())
-				termSort = getSort(parent);
-			assert (term.isList() || parent.isList())? termSort.endsWith("*") : !termSort.endsWith("*");
-		}
-		return termSort;
-	}
-	
-	/**
-	 * Returns true iff the sort represents a list sort, e.g., Elem*
-	 * @param sort
-	 * @return
-	 */
-	public static boolean isListSort(String sort) {
-		return sort.endsWith("*");
-	}
-
-	/**
-	 * Says wether the given node is an optional Some(_) sort.
-	 * @param trm
-	 * @return
-	 */
-	public static boolean isSomeNode(IStrategoTerm trm) {
-		if(trm.getTermType() == IStrategoTerm.APPL){
-			return trm.getSubtermCount() == 1 && ((IStrategoAppl)trm).getConstructor().getName().equals("Some");
-		}
-		return false;
-	}
-
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/LCS.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/LCS.java
--- src/org/spoofax/jsglr/client/editregion/detection/LCS.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/LCS.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,454 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Implements a Longest Common Subsequence algorithm
- * @author maartje
- *
- * @param <T>
- */
-public class LCS<T> {
-	
-	private final LCSCommand<T> lcsCommand;
-	private ArrayList<T> elems1;
-	private ArrayList<T> elems2;
-	private ArrayList<Integer> matchedIndices1;
-	private ArrayList<Integer> matchedIndices2;
-	
-	private ArrayList<Integer> unMatchedIndices1;
-	private ArrayList<Integer> unMatchedIndices2;
-	private ArrayList<T> resultLCS1;
-	private ArrayList<T> resultLCS2;
-	private ArrayList<T> resultUnmatched1;
-	private ArrayList<T> resultUnmatched2;
-	private int matchedPrefixSize;
-	private int matchedSuffixSize;
-
-	/**
-	 * Returns the elements of the first input list
-	 * @return 
-	 */
-	public ArrayList<T> getElems1() {
-		return elems1;
-	}
-
-	/**
-	 * Returns the elements of the second input list
-	 * @return
-	 */
-	public ArrayList<T> getElems2() {
-		return elems2;
-	}
-	
-	/**
-	 * Returns the index of the corresponding element in input2 (isInCorrectInputString == true), or input1 (isInCorrectInputString == false).
-	 * Returns -1 in case the element is not matched.
-	 * @param index of element
-	 * @param isInCorrectInputString
-	 * @return
-	 */
-	public int getMatchIndex(int index, boolean isInCorrectInputString) {
-		if(isInCorrectInputString){
-			return getMatchIndexInElems2(index);
-		}
-		return getMatchIndexInElems1(index);
-	}
-
-	/**
-	 * Returns the index of the corresponding element in elems2 for the element at elems1[indexElems1].
-	 * Returns -1 in case the element is not matched.
-	 * @param indexElems1 index of element in input1
-	 * @return
-	 */
-	public int getMatchIndexInElems2(int indexElems1){
-		int lcsIndex = matchedIndices1.indexOf(indexElems1);
-		if(lcsIndex >= 0){
-			return matchedIndices2.get(lcsIndex);
-		}
-		return -1;
-	}
-
-	/**
-	 * Returns the index of the corresponding element in elems1 for the element at elems2[indexElems2].
-	 * Returns -1 in case the element is not matched.
-	 * @param indexElems2 index of element in input2
-	 * @return
-	 */
-	public int getMatchIndexInElems1(int indexElems2){
-		int lcsIndex = matchedIndices2.indexOf(indexElems2);
-		if(lcsIndex > 0){
-			return matchedIndices1.get(lcsIndex);
-		}
-		return -1;
-	}
-
-	/**
-	 * Returns the indexes of the matched elements in input1
-	 * @return
-	 */
-	public ArrayList<Integer> getMatchedIndices1() {
-		return matchedIndices1;
-	}
-
-	/**
-	 * Returns the indexes of the matched elements in input2
-	 * @return
-	 */
-	public ArrayList<Integer> getMatchedIndices2() {
-		return matchedIndices2;
-	}
-
-	/**
-	 * Returns the indexes of the unmatched elements in input1
-	 * @return
-	 */
-	public ArrayList<Integer> getUnMatchedIndices1() {
-		if(unMatchedIndices1 == null){
-			unMatchedIndices1 = getUnmatchedIndices(elems1, matchedIndices1);
-		}
-		return unMatchedIndices1;
-	}
-
-	/**
-	 * Returns the indexes of the unmatched elements in input2
-	 * @return
-	 */
-	public ArrayList<Integer> getUnMatchedIndices2() {
-		if(unMatchedIndices2 == null){
-			unMatchedIndices2 = getUnmatchedIndices(elems2, matchedIndices2);
-		}
-		return unMatchedIndices2;
-	}
-
-	/**
-	 * LCS result for input 1
-	 * (empty before algorithm is applied)
-	 * @return LCS elements for input 1
-	 */
-	public ArrayList<T> getResultLCS1() {
-		if(resultLCS1 == null){
-			resultLCS1 = getIncludedElems(elems1, matchedIndices1);
-		}
-		return resultLCS1;
-	}
-
-	/**
-	 * LCS result for input 2
-	 * (empty before algorithm is applied)
-	 * @return LCS elements for input 2
-	 */
-	public ArrayList<T> getResultLCS2() {
-		if(resultLCS2 == null){
-			resultLCS2 = getIncludedElems(elems2, matchedIndices2);
-		}
-		return resultLCS2;
-	}
-
-	/**
-	 * Elements of input 1 that are not part of the LCS
-	 * (empty before algorithm is applied)
-	 * @return non-LCS elements for input 1
-	 */
-	public ArrayList<T> getResultUnmatched1() {
-		if(resultUnmatched1 == null){
-			resultUnmatched1 = getIncludedElems(elems1, getUnMatchedIndices1());
-		}
-		return resultUnmatched1;
-	}
-
-	/**
-	 * Elements of input 2 that are not part of the LCS
-	 * (empty before algorithm is applied)
-	 * @return non-LCS elements for input 2
-	 */
-	public ArrayList<T> getResultUnmatched2() {
-		if(resultUnmatched2 == null){
-			resultUnmatched2 = getIncludedElems(elems2, getUnMatchedIndices2());
-		}
-		return resultUnmatched2;
-	}
-	
-	/**
-	 * Size of the LCS
-	 * @return Size of the LCS
-	 */
-	public int getLCSSize(){
-		return matchedIndices1.size();
-	}
-
-	/**
-	 * Returns the number of matched elements at the prefix
-	 * @return
-	 */
-	public int getMatchedPrefixSize(){
-		if(matchedPrefixSize == -1){
-			matchedPrefixSize = 0;
-			while(
-				matchedPrefixSize < getLCSSize() &&
-				matchedIndices1.get(matchedPrefixSize) == matchedPrefixSize &&
-				matchedIndices2.get(matchedPrefixSize) == matchedPrefixSize
-			)
-			{
-				matchedPrefixSize ++;
-			}
-		}
-		return matchedPrefixSize;
-	}
-
-	/**
-	 * Returns the number of matched elements at the suffix
-	 * @return
-	 */
-	public int getMatchedSuffixSize(){
-		if(matchedSuffixSize == -1){
-			matchedSuffixSize = 0;
-			int elems1Size = elems1.size();
-			int elems2Size = elems2.size();
-			while(
-				matchedSuffixSize < getLCSSize() &&
-				matchedIndices1.get(getLCSSize() - 1 - matchedSuffixSize) == elems1Size - 1 - matchedSuffixSize &&
-				matchedIndices2.get(getLCSSize() - 1 - matchedSuffixSize) == elems2Size - 1 - matchedSuffixSize
-			)
-			{
-				matchedSuffixSize ++;
-			}
-		}
-		return matchedSuffixSize;
-	}
-
-	/**
-	 * Finds the Longest Common Subsequence of two lists with elements
-	 * @param lcsCommand Implements the matching criterion
-	 */
-	public LCS(LCSCommand<T> lcsCommand){
-		elems1 = new ArrayList<T>();
-		elems2 = new ArrayList<T>();
-		matchedIndices1 = new ArrayList<Integer>();
-		matchedIndices2 = new ArrayList<Integer>();
-		unMatchedIndices1 = null;
-		unMatchedIndices2 = null;
-		resultLCS1 = null;
-		resultLCS2 = null;
-		resultUnmatched1 = null;
-		resultUnmatched2 = null;
-		this.lcsCommand = lcsCommand;
-		matchedPrefixSize = -1;
-		matchedSuffixSize = -1;
-	}
-			
-	/**
-	 * Fills the LCS results: LCS (longest common subsequence), unmatched elems1, unmatched elems2.
-	 * As an optimization, the algorithm starts with matching elements at the prefix and suffix.
-	 * @param elems1
-	 * @param elems2
-	 */
-	public LCS<T> createLCSResultsOptimized(List<T> elems1, List<T> elems2) {
-		clearResults();
-		this.elems1.addAll(elems1);
-		this.elems2.addAll(elems2);
-		return createLCSResultsOptimized();
-	}
-	
-	/**
-	 * Fills the LCS results: LCS (longest common subsequence), unmatched elems1, unmatched elems2.
-	 * @param elems1
-	 * @param elems2
-	 */
-	public LCS<T> createLCSResults(List<T> elems1, List<T> elems2) {
-		clearResults();
-		this.elems1.addAll(elems1);
-		this.elems2.addAll(elems2);
-		lcs(elems1, elems2, 0);
-		checkAssertions(elems1, elems2);
-		return this;
-	}
-
-	
-// helper functions
-
-	private void clearResults(){
-		elems1.clear();
-		elems2.clear();
-		matchedIndices1.clear();
-		matchedIndices2.clear();
-		unMatchedIndices1 = null;
-		unMatchedIndices2 = null;
-		resultLCS1 = null;
-		resultLCS2 = null;
-		resultUnmatched1 = null;
-		resultUnmatched2 = null;
-		matchedPrefixSize = -1;
-		matchedSuffixSize = -1;
-	}
-
-	private ArrayList<Integer> getUnmatchedIndices(List<T> elems, ArrayList<Integer> indices) {
-		assert elems.size() >= indices.size();
-		ArrayList<Integer> unmatchedIndices = new ArrayList<Integer>();
-		int indexIndices = 0;
-		int nextIncludedIndex = -1;
-		if(indexIndices < indices.size())
-			nextIncludedIndex = indices.get(indexIndices).intValue();
-		for (int elems_index = 0; elems_index < elems.size(); elems_index++) {
-			if(elems_index == nextIncludedIndex){				
-				//set next included index
-				indexIndices += 1;
-				nextIncludedIndex = -1;
-				if(indexIndices < indices.size())
-					nextIncludedIndex = indices.get(indexIndices).intValue();
-			}
-			else{
-				//no match at elems_index!
-				unmatchedIndices.add(elems_index);
-			}
-		}
-		assert unmatchedIndices.size() + indices.size() == elems.size();
-		return unmatchedIndices;
-	}
-
-	private ArrayList<T> getIncludedElems(List<T> elems, ArrayList<Integer> indices) {
-		assert elems.size() >= indices.size();
-		ArrayList<T> includedElems = new ArrayList<T>();
-		int indexIndices = 0;
-		int nextIncludedIndex = -1;
-		if(indexIndices < indices.size())
-			nextIncludedIndex = indices.get(indexIndices).intValue();
-		for (int elems_index = 0; elems_index < elems.size(); elems_index++) {
-			if(elems_index == nextIncludedIndex){
-				//matched at elems_index!
-				includedElems.add(elems.get(elems_index));
-				
-				//set next included index
-				indexIndices += 1;
-				nextIncludedIndex = -1;
-				if(indexIndices < indices.size())
-					nextIncludedIndex = indices.get(indexIndices).intValue();
-			}
-		}
-		assert includedElems.size() == indices.size();
-		return includedElems;
-	}
-	
-	private LCS<T> createLCSResultsOptimized() {
-		int commonPrefixLength = commonPrefixLength();
-		int commonSuffixLength = commonSuffixLength(commonPrefixLength);
-		addPrefixIndices(commonPrefixLength);
-		addMidIndices(commonPrefixLength, commonSuffixLength);
-		addSuffixIndices(commonSuffixLength);		
-		checkAssertions(elems1, elems2);
-		return this;
-	}
-
-	private void addMidIndices(int commonPrefixLength, int commonSuffixLength) {
-		List<T> elems1_mid = elems1.subList(commonPrefixLength, elems1.size() - commonSuffixLength);
-		List<T> elems2_mid = elems2.subList(commonPrefixLength, elems2.size() - commonSuffixLength);
-		lcs(
-			elems1_mid, 
-			elems2_mid,
-			commonPrefixLength
-		);
-	}
-
-	private void addSuffixIndices(int commonSuffixLength) {
-		for (int suffixIndex = commonSuffixLength - 1; suffixIndex >= 0 ; suffixIndex--) {
-			int el1_index = elems1.size() - 1 - suffixIndex;
-			int el2_index = elems2.size() - 1 - suffixIndex;
-			assert lcsCommand.isMatch(elems1.get(el1_index), elems2.get(el2_index)): "elements should match since they are in the common suffix"; 
-			matchedIndices1.add(el1_index); 
-			matchedIndices2.add(el2_index);			
-		}
-	}
-
-	private void addPrefixIndices(int commonPrefixLength) {
-		for (int prefixIndex = 0; prefixIndex < commonPrefixLength; prefixIndex++) {
-			assert lcsCommand.isMatch(elems1.get(prefixIndex), elems2.get(prefixIndex)): "elements should match since they are in the common prefix"; 
-			matchedIndices1.add(prefixIndex);
-			matchedIndices2.add(prefixIndex);			
-		}
-	}
-
-	private int commonPrefixLength() {
-		int minLength = Math.min(elems1.size(), elems2.size()); 
-		int commonPrefixLength = 0;
-		while (commonPrefixLength < minLength) {
-			T el1 = elems1.get(commonPrefixLength);
-			T el2 = elems2.get(commonPrefixLength);
-			if(lcsCommand.isMatch(el1, el2)){
-				commonPrefixLength++;
-			}
-			else
-				break;
-		}
-		return commonPrefixLength;
-	}
-
-	private int commonSuffixLength(int commonPrefixLength) {
-		int minLength = Math.min(elems1.size(), elems2.size()); 
-		int commonSuffixLength = 0;
-		while (commonSuffixLength < minLength - commonPrefixLength) {
-			int el1_index = elems1.size() - commonSuffixLength -1;
-			int el2_index = elems2.size() - commonSuffixLength - 1;
-			T el1 = elems1.get(el1_index);
-			T el2 = elems2.get(el2_index);
-			if(lcsCommand.isMatch(el1, el2)){
-				commonSuffixLength++;
-			}
-			else
-				break;
-		}
-		return commonSuffixLength;
-	}
-
-	private void lcs(List<T> elems1, List<T> elems2, int startIndex) {
-		int lengthElems1 = elems1.size();
-        int lengthElems2 = elems2.size();
-
-        // opt[i][j] = length of LCS of x[i..M] and y[j..N]
-        int[][] opt = new int[lengthElems1+1][lengthElems2+1];
-
-        // compute length of LCS and all subproblems via dynamic programming
-        for (int i = lengthElems1-1; i >= 0; i--) {
-            for (int j = lengthElems2-1; j >= 0; j--) {
-                if (lcsCommand.isMatch(elems1.get(i), elems2.get(j)))
-                    opt[i][j] = opt[i+1][j+1] + 1;
-                else 
-                    opt[i][j] = Math.max(opt[i+1][j], opt[i][j+1]);
-            }
-        }
-
-        // recover LCS itself
-        int i = 0, j = 0;
-		while(i < lengthElems1 && j < lengthElems2) {
-	        T el1 = elems1.get(i);
-			T el2 = elems2.get(j);
-            if (lcsCommand.isMatch(el1, el2)) {
-				matchedIndices1.add(i + startIndex);
-				matchedIndices2.add(j + startIndex);
-                i++;
-                j++;
-            }
-            else if (opt[i+1][j] >= opt[i][j+1]){
-            	i++;
-            }
-            else { 
-            	j++;
-            }
-        }
-	}
-
-	private void checkAssertions(List<T> elems1, List<T> elems2) {
-		assert matchedIndices1.size() == matchedIndices2.size();
-		assert matchedIndices1.size() <= elems1.size();
-		assert matchedIndices2.size() <=  elems2.size();
-		for (int i = 0; i < matchedIndices1.size(); i++) {
-			T el1 = elems1.get(matchedIndices1.get(i).intValue());
-			T el2 = elems2.get(matchedIndices2.get(i).intValue());
-			assert lcsCommand.isMatch(el1, el2);
-		}
-		for (int i = 1; i < matchedIndices1.size(); i++) {
-			assert matchedIndices1.get(i).intValue() > matchedIndices1.get(i-1).intValue();
-			assert matchedIndices2.get(i).intValue() > matchedIndices2.get(i-1).intValue();
-		}
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/LCSCommand.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/LCSCommand.java
--- src/org/spoofax/jsglr/client/editregion/detection/LCSCommand.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/LCSCommand.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-/**
- * Implements the matching criteron applied by the LCS algorithm
- * @author maartje
- *
- * @param <T>
- */
-public interface LCSCommand<T> {
-	/**
-	 * Returns true in case t1 and t2 can be matched.
-	 * This function implements the criteria for matching in a Longest Common Subsequence procedure. 
-	 * @param t1 element in input list 1
-	 * @param t2 element in input list 2
-	 * @return True in case t1 and t2 can be matched
-	 */
-	abstract boolean isMatch(T t1, T t2);
-
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java
--- src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/LayoutEditsAnalyzer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import java.util.ArrayList;
-
-import org.spoofax.jsglr.client.imploder.IToken;
-import org.spoofax.jsglr.client.imploder.Token;
-
-/**
- * Determines the comment regions that are edited and therefore (possible) damaged.
- * Filters the offsets of the deleted characters, removing comment and whitespace offsets 
- * that are either irrelevant (not affecting the parse result) or allready processed (block comment damage)
- * Example damaged comment: '/* comment * /'
- * Example harmful layout deletion: 'int  i' => 'inti' 
- * @author Maartje de Jonge
- *
- */
-public class LayoutEditsAnalyzer {
-		
-	private final DamagedTokenAnalyzer tokenEdits;
-
-	//filled in the analysis
-	private final ArrayList<DiscardableRegion> damagedCommentRegions;
-	private final ArrayList<Integer> offsetsDeletedLayoutChars;
-	
-	/**
-	 * Returns the comment regions that are edited and therefore (possible) damaged.
-	 */
-	public ArrayList<DiscardableRegion> getDamagedCommentRegions() {
-		return damagedCommentRegions;
-	}
-
-	/**
-	 * Filters the list of deletion-offsets,
-	 * removing all layout-deletion-offsets that are in fact harmless, e.g. do not affect the parse result.
-	 */
-	public void filterNonLayoutOffsets(ArrayList<Integer> deletedOffsets) {
-		deletedOffsets.removeAll(offsetsDeletedLayoutChars);
-	}
-	
-	/**
-	 * Determines the comment regions that are edited and therefore (possible) damaged.
-	 * Filters the offsets of the deleted characters, removing comment and whitespace offsets 
-	 * that are either irrelevant (not affecting the parse result) or allready processed (block comment damage)
-	 */
-	public LayoutEditsAnalyzer(DamagedTokenAnalyzer tokenEdits){
-		this.offsetsDeletedLayoutChars = new ArrayList<Integer>();
-		this.damagedCommentRegions = new ArrayList<DiscardableRegion>();
-		this.tokenEdits = tokenEdits;
-		analyze();
-	}
-	
-	private void analyze() {
-		String input = tokenEdits.getTokens().getInput();
-		for (IToken tokenWithDeletions : tokenEdits.getTokensDamagedByDeletion()) {
-			if(tokenWithDeletions.getKind() == Token.TK_LAYOUT){
-				if(!tokenEdits.isDamagingLayoutDeletion(tokenWithDeletions)){
-					this.offsetsDeletedLayoutChars.addAll(tokenEdits.getOffsetsDeletions(tokenWithDeletions));						
-				}
-				if(!Token.isWhiteSpace(tokenWithDeletions)){
-					DiscardableRegion commentRegion = new DiscardableRegion(tokenWithDeletions.getStartOffset(), tokenWithDeletions.getEndOffset(), input);
-					assert !HelperFunctions.contains(damagedCommentRegions, commentRegion);
-					damagedCommentRegions.add(commentRegion);
-				}
-			}
-		}
-		for (IToken tokenWithInsertions : tokenEdits.getTokensDamagedByInsertion()) {
-			if(tokenWithInsertions.getKind() == Token.TK_LAYOUT && !Token.isWhiteSpace(tokenWithInsertions)){
-				DiscardableRegion commentRegion = new DiscardableRegion(tokenWithInsertions.getStartOffset(), tokenWithInsertions.getEndOffset(), input);
-				if(!HelperFunctions.contains(damagedCommentRegions, commentRegion))
-					damagedCommentRegions.add(commentRegion);
-			}
-		}
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java
--- src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/RecoverInterpretation.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,356 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getTokenizer;
-
-import java.util.ArrayList;
-
-import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.jsglr.client.imploder.ITokenizer;
-import org.spoofax.jsglr.client.imploder.ImploderAttachment;
-import org.spoofax.jsglr.client.imploder.Token;
-
-/**
- * Represents a recovery based on discarding tokens associated to the term and/or its subterms.
- * @author maartje
- *
- */
-public class RecoverInterpretation {
-
-//private fields
-
-	private final IStrategoTerm term;
-	private final IStrategoTerm parentTerm;
-	private final boolean isRecovered;
-	private final ArrayList<RecoverInterpretation> subtermRecoveries;
-	private final int recoveryCosts;
-
-//public field accessors 
-
-	/**
-	 * Returns the recovered term
-	 * @return
-	 */
-	public IStrategoTerm getTerm() {
-		return term;
-	}
-	
-	/**
-	 * Returns the recoveries associated to the subterms
-	 * @return
-	 */
-	public ArrayList<RecoverInterpretation> getSubtermRecoveries() {
-		return subtermRecoveries;
-	}
-
-	/**
-	 * Returns the cost of the recovery calculated as the number of non-layout tokens that are discarded from the correct input
-	 * fragment associated to the recovered term 
-	 * @return
-	 */
-	public int getRecoveryCosts() {
-		return recoveryCosts;
-	}
-
-//public methods	
-	
-	/**
-	 * Gets the sort of the (parent) list for lists and list elems, and the sort of the term for other terms 
-	 * @return
-	 */
-	public String getGeneralSort(){
-		return HelperFunctions.getGeneralSort(term, parentTerm);
-	}
-
-	/**
-	 * Gets the sort of the term
-	 * @return
-	 */
-	public String getSort(){
-		return ImploderAttachment.getSort(term);
-	}
-	
-	/**
-	 * Says wether the recovered term has the same sort and general sort as the term given as parameter
-	 * @param term
-	 * @param parent, needed to determine the general sort of the term 
-	 * @return
-	 */
-	public boolean hasSameSort(IStrategoTerm term, IStrategoTerm parent) {
-		String generalSort = HelperFunctions.getGeneralSort(term, parent);
-		String sort = ImploderAttachment.getSort(term);
-		String generalTermSort = this.getGeneralSort();
-		String termSort = this.getSort();		
-		return generalSort == generalTermSort && sort == termSort;
-	}
-
-	/**
-	 * Says whether the recovery has a sort that is compatible with the sort of the input term,
-	 * e.g., the recovered term can be used as a recover interpretation for the input term 
-	 * @param term
-	 * @param parent
-	 * @return
-	 */
-	public boolean hasCompatibleSort(IStrategoTerm term, IStrategoTerm parent) {
-		String generalSort = HelperFunctions.getGeneralSort(term, parent);
-		String sort = ImploderAttachment.getSort(term);
-		String generalTermSort = this.getGeneralSort();
-		String termSort = this.getSort();
-		boolean hasCompatibleSort = 
-				generalSort.equals(termSort) ||
-				generalSort.equals(generalTermSort.replace("*", "")) ||
-				generalSort.equals(generalTermSort) ||
-				sort.equals(termSort) ||
-				sort.equals(generalTermSort.replace("*", "")) ||
-				sort.equals(generalTermSort) ||
-				generalSort.replace("*", "").equals(termSort) ||
-				generalSort.replace("*", "").equals(generalTermSort.replace("*", "")) ||
-				generalSort.replace("*", "").equals(generalTermSort);
-				
-		return hasCompatibleSort;
-	}
-
-	/**
-	 * Says wether the recovery is a trivial recover interpretation,
-	 *  e.g. the original interpretation of an undamaged term. 
-	 * @return
-	 */
-	public boolean isUndamagedTerm() {
-		return getSubtermRecoveries() == null;
-	}
-	
-	/**
-	 * Returns a recursively constructed list of discarded regions that together form a recovery for the term 
-	 * @return
-	 */
-	public ArrayList<DiscardableRegion> getDamagedRegions(){
-		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
-			return new ArrayList<DiscardableRegion>(); 
-		}
-		else if(isRecovered){ //only damage in tokens associated to subterms 
-			return getDamagedRegionsForUnaffectedTerm(); 
-		}
-		else { //damage in tokens associated to term
-			return getDamagedRegionsForAffectedTerm();
-		}
-	}
-
-	/**
-	 * Returns a recursively constructed list of terms for which the associate tokens are discarded as a recovery 
-	 * @return
-	 */
-	public ArrayList<IStrategoTerm> getDamagedTerms(){
-		ArrayList<IStrategoTerm> damagedTerms = new ArrayList<IStrategoTerm>();
-		if(this.getSubtermRecoveries() == null){ //trivial recovery (no damage)
-			return new ArrayList<IStrategoTerm>();
-		}
-		if(!isRecovered && hasNonLayoutTokenDiscards()){
-			damagedTerms.add(getTerm());
-		}
-		for (int i = 0; i < this.getSubtermRecoveries().size(); i++) {
-			damagedTerms.addAll(getSubtermRecoveries().get(i).getDamagedTerms());
-		}
-		return damagedTerms;
-	}
-
-	private boolean hasNonLayoutTokenDiscards() {
-		int recoverCostsSubterms = 0;
-		for (RecoverInterpretation subtermRecovery : getSubtermRecoveries()) {
-			recoverCostsSubterms += subtermRecovery.getRecoveryCosts();
-		}
-		assert recoveryCosts >= recoverCostsSubterms;
-		return recoveryCosts > recoverCostsSubterms;
-	}
-	
-	@Override
-	public String toString(){
-		ArrayList<DiscardableRegion> damagedRegions = getDamagedRegions();
-		String inputString = getInputString();
-		String recoveredProgram = DiscardableRegion.replaceAllRegionsByWhitespace(damagedRegions, inputString);
-		int startOffset = ImploderAttachment.getLeftToken(term).getStartOffset();
-		int endOffset = ImploderAttachment.getRightToken(term).getEndOffset();
-		String recoveredTermFragment = recoveredProgram.substring(startOffset, endOffset + 1);
-		return recoveredTermFragment;
-	}
-
-
-	
-// constructors
-	
-	/**
-	 * Returns a trivial recover interpretation by taking the original interpretation.
-	 * Intended for undamaged terms. 
-	 * @param term
-	 * @param parentTerm
-	 * @return
-	 */
-	public static RecoverInterpretation createOriginalTermInterpretation(IStrategoTerm term, IStrategoTerm parentTerm){
-		return new RecoverInterpretation(term, parentTerm, true, null);
-		//Remark: recursively constructing original term recoveries for subterms seems not needed. 
-	}
-
-	/**
-	 * Returns a recover interpretation based on discarding the characters associated to the term and all its subterms.
-	 * Intended as fall back recovery for list elements and 'Some(_)' terms.  
-	 * @param term
-	 * @param parentTerm
-	 * @return
-	 */
-	public static RecoverInterpretation createDiscardInterpretation(IStrategoTerm term, IStrategoTerm parentTerm){
-		assert term.isList() || HelperFunctions.isSomeNode(term) || parentTerm == null; //parentTerm.isList()
-		return new RecoverInterpretation(term, parentTerm, false, new ArrayList<RecoverInterpretation>());
-	}
-
-	/**
-	 * Returns a recover interpretation based on repairing sublists with correct separation in between.
-	 * @param term
-	 * @param parentTerm
-	 * @param recoveredSubterms
-	 * @return
-	 */
-	public static RecoverInterpretation createRepairSublistsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSublists){
-		assert !recoveredSublists.contains(null);
-		//assert sublists cover list (?)
-		return new RecoverInterpretation(term, parentTerm, true, recoveredSublists);
-	}
-
-	/**
-	 * Returns a recover interpretation based on repairing the subterms
-	 * Intended for terms that are not affected themselves, but do have changes in their subterms,
-	 * whereby the child terms can be recovered.
-	 * @param term
-	 * @param parentTerm
-	 * @param recoveredSubterms
-	 * @return
-	 */
-	public static RecoverInterpretation createRepairSubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSubterms){
-		assert recoveredSubterms.size() == term.getSubtermCount() && !recoveredSubterms.contains(null);
-		return new RecoverInterpretation(term, parentTerm, true, recoveredSubterms);
-	}
-
-	/**
-	 * Returns a recover interpretation by replacing the term with a sub-term of the same sort.
-	 * Intended for terms that are affected themselves, or terms whereby the child terms can not be repaired.
-	 * @param term
-	 * @param parentTerm
-	 * @param recoveredSubterm
-	 * @return
-	 */
-	public static RecoverInterpretation createReplaceBySubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, RecoverInterpretation recoveredSubterm){
-		assert recoveredSubterm.hasCompatibleSort(term, parentTerm);
-		ArrayList<RecoverInterpretation> subRecoveries = new ArrayList<RecoverInterpretation>();
-		subRecoveries.add(recoveredSubterm);
-		return createReplaceBySubtermsInterpretation(term, parentTerm, subRecoveries);
-	}
-
-	/**
-	 * Returns a recover interpretation by replacing the terms with a list of sub terms of the same sort.
-	 * Intended for list elements that are affected themselves, or list elements whereby the child terms can not be repaired.
-	 * @param term
-	 * @param parentTerm
-	 * @param recoveredSubterms
-	 * @return
-	 */
-	public static RecoverInterpretation createReplaceBySubtermsInterpretation(IStrategoTerm term, IStrategoTerm parentTerm, ArrayList<RecoverInterpretation> recoveredSubterms){
-		assert (parentTerm.isList() && recoveredSubterms.size() >= 1) || recoveredSubterms.size() == 1;
-		return new RecoverInterpretation(term, parentTerm, false, recoveredSubterms);
-	}
-
-	private RecoverInterpretation(
-			IStrategoTerm term, 
-			IStrategoTerm parentTerm,
-			boolean isRecovered,
-			ArrayList<RecoverInterpretation> recoveredSubterms
-	) {
-		this.term = term;
-		this.parentTerm = parentTerm;
-		this.isRecovered = isRecovered;
-		this.subtermRecoveries = recoveredSubterms;
-		this.recoveryCosts = calculateRecoveryCosts();
-		checkAssertions();
-	}
-
-	private void checkAssertions() {
-		assert subtermRecoveries == null? (isRecovered && this.recoveryCosts == 0) : recoveryCosts >= 0;
-		int subtermCosts = 0;
-		if(this.subtermRecoveries != null){
-			for (RecoverInterpretation subtermRecovery : this.subtermRecoveries) {
-				assert subtermRecovery != null;	
-				subtermCosts += subtermRecovery.getRecoveryCosts();
-			}
-		}
-		assert isRecovered? recoveryCosts == subtermCosts : recoveryCosts >= subtermCosts;
-	}
-	
-//private functions
-	
-	private int calculateRecoveryCosts(){
-		int costs = 0;
-		if(subtermRecoveries == null){
-			return 0;			
-		}
-		if(!isRecovered){
-			int nrOfNonLayoutInSubterms = 0;
-			for (RecoverInterpretation subtermRecovery : this.subtermRecoveries) {
-				nrOfNonLayoutInSubterms += numberOfNonLayoutTokens(subtermRecovery.getTerm());
-			}
-			costs = numberOfNonLayoutTokens(this.getTerm()) - nrOfNonLayoutInSubterms;
-		}
-		for (RecoverInterpretation subtermRecovery : subtermRecoveries) {
-			costs += subtermRecovery.getRecoveryCosts();
-		}
-		return costs;
-	}
-	
-	private int numberOfNonLayoutTokens(IStrategoTerm term) {
-		ITokenizer tokens = getTokenizer(term);
-		int leftIndex =  getLeftToken(term).getIndex();
-		int rightIndex =  getRightToken(term).getIndex();
-		int nrOfNonLayoutTokens = 0;
-		for (int i = leftIndex; i <= rightIndex; i++) {
-			if(tokens.getTokenAt(i).getKind() != Token.TK_LAYOUT){
-				nrOfNonLayoutTokens ++;
-			}
-		}
-		return nrOfNonLayoutTokens;
-	}
-	
-	private ArrayList<DiscardableRegion> getDamagedRegionsForAffectedTerm() {
-		String input = getInputString();
-		ArrayList<DiscardableRegion> damagedRegions = new ArrayList<DiscardableRegion>();
-		int startOffset = getLeftToken(term).getStartOffset();
-		for (int i = 0; i < getSubtermRecoveries().size(); i++) {
-			RecoverInterpretation subtermRecovery = getSubtermRecoveries().get(i);
-			int endOffset = getLeftToken(subtermRecovery.getTerm()).getStartOffset()-1;
-			if(startOffset <= endOffset){ //discard tokens associated to term
-				DiscardableRegion region = new DiscardableRegion(startOffset, endOffset, input);
-				damagedRegions.add(region);
-			}
-			damagedRegions.addAll(subtermRecovery.getDamagedRegions()); //collect damaged regions in subterm
-			startOffset = getRightToken(subtermRecovery.getTerm()).getEndOffset() + 1;
-		}
-		int endOffset = getRightToken(term).getEndOffset();
-		if(startOffset <= endOffset){ //discard suffix tokens associated to term
-			DiscardableRegion damagedRegion = new DiscardableRegion(startOffset, endOffset, input);
-			damagedRegions.add(damagedRegion);
-		}
-		return damagedRegions;
-	}
-	
-	private ArrayList<DiscardableRegion> getDamagedRegionsForUnaffectedTerm() {
-		ArrayList<DiscardableRegion> damagedRegions = new ArrayList<DiscardableRegion>();
-		for (RecoverInterpretation subtermRecovery : getSubtermRecoveries()) {
-			damagedRegions.addAll(subtermRecovery.getDamagedRegions());
-		}
-		return damagedRegions;
-	}
-
-	private String getInputString() {
-		return ImploderAttachment.getTokenizer(getTerm()).getInput();
-	}
-
-	public boolean isDiscardRecovery() {
-		return getSubtermRecoveries() != null && getSubtermRecoveries().isEmpty();
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java
--- src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/TermEditsAnalyzer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,321 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getLeftToken;
-import static org.spoofax.jsglr.client.imploder.ImploderAttachment.getRightToken;
-
-import java.util.ArrayList;
-import java.util.IdentityHashMap;
-
-import org.spoofax.interpreter.terms.IStrategoList;
-import org.spoofax.interpreter.terms.IStrategoTerm;
-import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.jsglr.client.imploder.TermTreeFactory;
-import org.spoofax.terms.TermFactory;
-
-/**
- * Analyzes the terms in the correct AST that are affected during editing and therefore (possible) damaged.
- * Constructs a recovery based on discarding tokens associated to erroneous (discardable) terms. 
- * @author Maartje de Jonge
- *
- */
-public class TermEditsAnalyzer {
-	private final IStrategoTerm correctAST;
-	private final ArrayList<Integer> offsetsDeletedChars;
-	private final IdentityHashMap<IStrategoTerm, RecoverInterpretation> recoveryLookup;
-
-	/**
-	 * Constructs a recovery based on discarding tokens associated to erroneous (discardable) terms. 
-	 */
-	public TermEditsAnalyzer(ArrayList<Integer> offsetsDeletedChars, IStrategoTerm correctAST){
-		this.offsetsDeletedChars = offsetsDeletedChars;
-		this.recoveryLookup = new IdentityHashMap<IStrategoTerm, RecoverInterpretation>();
-		this.correctAST = correctAST;
-	}
-	
-	/**
-	 * Returns discardable regions that are edited 
-	 */
-	public RecoverInterpretation getDiscardRecovery(){
-		//System.out.println(correctAST);
-		recoveryLookup.clear();
-		collectRecoveries(correctAST, null);
-		RecoverInterpretation discardRecovery = lookupRecovery(correctAST, null); //TODO: if null, alltd look for regions in subterms
-		assert discardRecovery == null || discardRecovery.getTerm() == correctAST;
-		return discardRecovery;
-	}
-
-	private void collectRecoveries(IStrategoTerm term, IStrategoTerm parent){
-		if(!hasDeletions(term)){
-			RecoverInterpretation originalTermRecovery = RecoverInterpretation.createOriginalTermInterpretation(term, parent);
-			assert recoveryLookup.get(term) == null;
-			recoveryLookup.put(term, originalTermRecovery); //we do not discard in unaffected terms.
-			return;
-		}
-		for (int i = 0; i < term.getSubtermCount(); i++) {
-			collectRecoveries(term.getSubterm(i), term);
-		}
-		//int s = ImploderAttachment.getLeftToken(term).getStartOffset();
-		//int e =ImploderAttachment.getRightToken(term).getEndOffset();
-		//System.out.println(ImploderAttachment.getTokenizer(term).getInput().substring(s, e+1));
-		RecoverInterpretation recovery = constructMinimalCostRecovery(term, parent);
-		if(recovery != null)
-			recoveryLookup.put(term, recovery);
-	}
-	
-	private RecoverInterpretation constructMinimalCostRecovery(IStrategoTerm term, IStrategoTerm parent) {
-		//candidates can be null
-		RecoverInterpretation discardRecovery = constructDiscardRecovery(term, parent);
-		RecoverInterpretation childTermsRecovery = null;
-		if(!term.isList())
-			childTermsRecovery = constructRepairSubtermsRecovery(term, parent);
-		else {
-			childTermsRecovery = sublistRecovery(0, term, parent); 
-			if(childTermsRecovery != null)
-				return childTermsRecovery;
-			return discardRecovery;
-		}
-		RecoverInterpretation subTermsRecovery = constructReplaceBySubtermsRecovery(term, parent);
-		ArrayList<RecoverInterpretation> candidates = new ArrayList<RecoverInterpretation>();
-		candidates.add(childTermsRecovery);
-		candidates.add(subTermsRecovery);
-		candidates.add(discardRecovery);
-		return getMinimumCostRecovery(candidates);
-	}
-	
-	private RecoverInterpretation sublistRecovery(int startIndex, IStrategoTerm listTerm, IStrategoTerm parent) {
-		assert listTerm.isList();
-		assert listTerm.getSubtermCount() != 0;
-		
-		for (int i = startIndex; i < listTerm.getSubtermCount(); i++) {
-			if(i == listTerm.getSubtermCount()-1 || hasCorrectSeparationAfterIndex(listTerm, i)){
-				int endIndex = i;
-				IStrategoTerm prefixSublist = createSublist(listTerm, startIndex, endIndex);
-				ArrayList<RecoverInterpretation> candidates = 
-						getRecoverCandidatesFromChildTerms(listTerm, startIndex, endIndex, prefixSublist, listTerm);
-				RecoverInterpretation prefixRecovery = getMinimumCostRecovery(candidates);
-				if(prefixRecovery != null){
-					assert prefixRecovery.getTerm() == prefixSublist;
-					assert prefixRecovery.getSubtermRecoveries().size() >= 1;
-					assert !prefixRecovery.isDiscardRecovery();
-					RecoverInterpretation suffixRecovery = sublistRecovery(endIndex + 1, listTerm, parent);
-					if(suffixRecovery != null){
-						assert !suffixRecovery.isDiscardRecovery();
-						ArrayList<RecoverInterpretation> recoveredSubLists = new ArrayList<RecoverInterpretation>();
-						recoveredSubLists.add(prefixRecovery);
-						recoveredSubLists.add(suffixRecovery);
-						return RecoverInterpretation.createRepairSublistsInterpretation(listTerm, parent, recoveredSubLists);
-					}
-					else{ //prefixRecovery != null && suffixRecovery == null
-						ArrayList<RecoverInterpretation> prefixCandidates = prefixRecovery.getSubtermRecoveries();
-						if(startIndex == 0) //whole list recovered with single term
-							return RecoverInterpretation.createReplaceBySubtermsInterpretation(listTerm, parent, prefixCandidates);
-						IStrategoTerm sublist = createSublist(listTerm, startIndex, listTerm.getSubtermCount() - 1);
-						return RecoverInterpretation.createReplaceBySubtermsInterpretation(sublist, listTerm, prefixCandidates);
-					}
-				}
-			}
-		}
-		return null;
-	}
-
-	private IStrategoTerm createSublist(IStrategoTerm listTerm, int startIndex,
-			int endIndex) {
-		IStrategoTerm prefixSublist;
-		final ITermFactory termFactory = new TermFactory().getFactoryWithStorageType(IStrategoTerm.MUTABLE);
-		final TermTreeFactory termTreeFactory = new TermTreeFactory(termFactory);
-		IStrategoTerm firstChild = listTerm.getSubterm(startIndex);
-		IStrategoTerm lastChild = listTerm.getSubterm(endIndex);
-		prefixSublist = termTreeFactory.createSublist((IStrategoList)listTerm, firstChild, lastChild);
-		return prefixSublist;
-	}
-
-	private boolean hasCorrectSeparationAfterIndex(IStrategoTerm listTerm, int i) {
-		if(i < listTerm.getSubtermCount() - 1){
-			int startOffset = getRightToken(listTerm.getSubterm(i)).getEndOffset() + 1;
-			int endOffset = getLeftToken(listTerm.getSubterm(i+1)).getStartOffset() - 1;
-			return getCoveredOffsets(startOffset, endOffset, offsetsDeletedChars).isEmpty();
-		}
-		else
-			return true;
-	}
-
-	private RecoverInterpretation constructRepairSubtermsRecovery(IStrategoTerm term, IStrategoTerm parent) {
-		if(hasAssociatedDeletions(term))
-			return null; //term itself is broken thus it can not be recovered by repairing subterms
-		ArrayList<RecoverInterpretation> subtermRecoveries = new ArrayList<RecoverInterpretation>();
-		for (int i = 0; i < term.getSubtermCount(); i++) {
-			IStrategoTerm subterm = term.getSubterm(i);
-			RecoverInterpretation subtermRecovery = lookupRecovery(subterm, term);
-			if(subtermRecovery == null){
-				return null; //subterm can not be recovered, thus term can not be recovered from its subterms
-			}
-			assert subterm == subtermRecovery.getTerm();
-			subtermRecoveries.add(subtermRecovery);
-		}
-		return RecoverInterpretation.createRepairSubtermsInterpretation(term, parent, subtermRecoveries);
-	}
-	
-	private RecoverInterpretation constructDiscardRecovery(IStrategoTerm term, IStrategoTerm parent) {
-		if(HelperFunctions.isSomeNode(term) || term.isList()){ //|| (parent != null && parent.isList())
-			return RecoverInterpretation.createDiscardInterpretation(term, parent);
-		}
-		return null;
-	}
-
-	private RecoverInterpretation constructReplaceBySubtermsRecovery(IStrategoTerm term, IStrategoTerm parent) {
-		//System.out.println("recover: " + term);
-		RecoverInterpretation recovery = getRecoveryFromSubterms(term, parent, term, parent);
-		//System.out.println("recovery: " + recovery);
-		return recovery;
-	}
-
-	private RecoverInterpretation getRecoveryFromSubterms(IStrategoTerm visitedTerm, IStrategoTerm visitedParent, IStrategoTerm term, IStrategoTerm parent) {
-		//set recover interpretation provided by the visited term
-		RecoverInterpretation fromVisitedRecovery = null;
-		RecoverInterpretation candidateFromVisited = lookupRecovery(visitedTerm, null);
-		if(candidateFromVisited != null && candidateFromVisited.hasCompatibleSort(term, parent)){
-			assert candidateFromVisited.getTerm() == visitedTerm;
-			fromVisitedRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, candidateFromVisited);
-			assert fromVisitedRecovery != null && fromVisitedRecovery.getTerm() == term && fromVisitedRecovery.hasCompatibleSort(term, parent);
-		}
-
-		//return from visited recovery if that is known to be better than interpretations provided by its subterms
-		if(fromVisitedRecovery != null && (fromVisitedRecovery.hasSameSort(term, parent) || candidateFromVisited.isUndamagedTerm())){
-			//optimal interpretation for the fragment already found, no need to further traverse subterms 
-			return fromVisitedRecovery;
-		}
-
-		//find candidates by traversing subterms of visited term
-		RecoverInterpretation fromSubtermsRecovery = null;
-		if(parent == null || !parent.isList()){
-			fromSubtermsRecovery = getMinimumCostRecoveryFromChildterms(visitedTerm, term, parent);
-		}
-		else { //parent is list
-			//TODO: separators?
-			fromSubtermsRecovery = getMergedRecoveriesFromChildTerms(visitedTerm, term, parent);
-		}
-
-		//compares recovery from subterms and recovery from visited term and chooses the best of both.
-		RecoverInterpretation minimumCostRecovery = getMinimumCostRecovery(fromSubtermsRecovery, fromVisitedRecovery);
-		assert minimumCostRecovery == null || (minimumCostRecovery.getTerm() == term && minimumCostRecovery.hasCompatibleSort(term, parent)) ;
-		return minimumCostRecovery;
-	}
-
-	private RecoverInterpretation getMergedRecoveriesFromChildTerms(
-			IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
-		ArrayList<RecoverInterpretation> candidatesFromSubterms = getRecoverCandidatesFromChildTerms(visitedTerm, term, parent);
-		ArrayList<RecoverInterpretation> mergedSubtermRecoveries = new ArrayList<RecoverInterpretation>();
-		for (int i = 0; i < candidatesFromSubterms.size(); i++) {
-			mergedSubtermRecoveries.addAll(candidatesFromSubterms.get(i).getSubtermRecoveries());
-		}
-		RecoverInterpretation fromSubtermsRecovery = null;
-		if(!mergedSubtermRecoveries.isEmpty()){
-			fromSubtermsRecovery = RecoverInterpretation.createReplaceBySubtermsInterpretation(term, parent, mergedSubtermRecoveries);
-		}
-		return fromSubtermsRecovery;
-	}
-
-	private RecoverInterpretation getMinimumCostRecoveryFromChildterms(IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
-		ArrayList<RecoverInterpretation> candidatesFromSubterms = getRecoverCandidatesFromChildTerms(visitedTerm, term, parent);
-		RecoverInterpretation minimumCostRecovery = getMinimumCostRecovery(candidatesFromSubterms); //can be null
-		return minimumCostRecovery;
-	}
-
-	private ArrayList<RecoverInterpretation> getRecoverCandidatesFromChildTerms(
-			IStrategoTerm visitedTerm, IStrategoTerm term, IStrategoTerm parent) {
-		if(visitedTerm.getSubtermCount() == 0)
-			return new ArrayList<RecoverInterpretation>();
-		int startIndex = 0;
-		int endIndex = visitedTerm.getSubtermCount() - 1;
-		ArrayList<RecoverInterpretation> candidatesFromSubterms = getRecoverCandidatesFromChildTerms(visitedTerm, startIndex, endIndex, term, parent);
-		return candidatesFromSubterms;
-	}
-
-	private ArrayList<RecoverInterpretation> getRecoverCandidatesFromChildTerms(
-			IStrategoTerm visitedTerm, int startIndex, int endIndex,
-			IStrategoTerm term, IStrategoTerm parent) {
-		assert endIndex <= visitedTerm.getSubtermCount()-1;
-		assert startIndex >= 0;
-		assert startIndex <= endIndex;
-		//traverse subterms of subterm
-		ArrayList<RecoverInterpretation> candidatesFromSubterms = new ArrayList<RecoverInterpretation> ();
-		for (int i = startIndex; i <= endIndex; i++) {
-			IStrategoTerm subterm = visitedTerm.getSubterm(i);
-			//System.out.println("visited: " + subterm);
-			RecoverInterpretation subtermRecovery = getRecoveryFromSubterms(subterm, visitedTerm, term, parent);
-			//System.out.println("recovery: " + subtermRecovery);
-			if(subtermRecovery != null && !subtermRecovery.isDiscardRecovery()){
-				assert subtermRecovery.hasCompatibleSort(term, parent);
-				assert subtermRecovery.getTerm() == term;
-				candidatesFromSubterms.add(subtermRecovery);
-			}
-		}
-		return candidatesFromSubterms;
-	}
-
-	private RecoverInterpretation lookupRecovery(IStrategoTerm visitedTerm, IStrategoTerm parentTerm) {
-		if(recoveryLookup.containsKey(visitedTerm))
-			return recoveryLookup.get(visitedTerm);
-		if(!hasDeletions(visitedTerm))
-			return RecoverInterpretation.createOriginalTermInterpretation(visitedTerm, parentTerm);
-		return null;
-	}
-
-	private RecoverInterpretation getMinimumCostRecovery(ArrayList<RecoverInterpretation> recoveries) {
-		RecoverInterpretation minimumCostInterpretation = null;
-		for (RecoverInterpretation recovery : recoveries) {
-			minimumCostInterpretation = getMinimumCostRecovery(minimumCostInterpretation, recovery);
-		}
-		return minimumCostInterpretation;
-	}
-
-	private RecoverInterpretation getMinimumCostRecovery(RecoverInterpretation recovery1, RecoverInterpretation recovery2) {
-		if(recovery2 == null)
-			return recovery1;
-		if(recovery1 == null)
-			return recovery2;
-		if(recovery2.getRecoveryCosts() < recovery1.getRecoveryCosts()){
-			return recovery2;
-		}
-		return recovery1;
-	}
-
-
-	private boolean hasDeletions(IStrategoTerm term) {
-		return !getCoveredOffsets(term, this.offsetsDeletedChars).isEmpty();
-	}
-
-	private boolean hasAssociatedDeletions(IStrategoTerm term) {
-		return !getAssociatedCoveredOffsets(term, this.offsetsDeletedChars).isEmpty();
-	}
-
-
-	private static ArrayList<Integer> getAssociatedCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
-		ArrayList<Integer> associatedCoveredOffsets = getCoveredOffsets(term, offsets);
-		for (int i = 0; i < term.getSubtermCount(); i++) {
-			IStrategoTerm subterm = term.getSubterm(i);
-			ArrayList<Integer> subtermOffsets = getCoveredOffsets(subterm, offsets);
-			associatedCoveredOffsets.removeAll(subtermOffsets);
-		}
-		return associatedCoveredOffsets;
-	}
-
-	private static ArrayList<Integer> getCoveredOffsets(IStrategoTerm term, ArrayList<Integer> offsets) {
-		int startOffset = getLeftToken(term).getStartOffset();
-		int endOffset = getRightToken(term).getEndOffset();
-		ArrayList<Integer> coveredOffsets = getCoveredOffsets(startOffset, endOffset, offsets);
-		return coveredOffsets;
-	}
-
-	private static ArrayList<Integer> getCoveredOffsets(int startOffset, int endOffset, ArrayList<Integer> offsets) {
-		ArrayList<Integer> coveredOffsets = new ArrayList<Integer>();
-		for (int i = 0; i < offsets.size(); i++) {
-			int offset = offsets.get(i); 
-			if(startOffset <= offset && offset <= endOffset){
-				//covered
-				coveredOffsets.add(offset);
-			}
-		}
-		return coveredOffsets;
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java
--- src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/editregion/detection/TerminalEditsAnalyzer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-package org.spoofax.jsglr.client.editregion.detection;
-
-import java.util.ArrayList;
-import java.util.Collections;
-
-import org.spoofax.jsglr.client.imploder.IToken;
-import org.spoofax.jsglr.client.imploder.Token;
-
-/**
- * Adds to the deletion offsets the (start)offset of non-layout tokens that are damaged by an insertion only 
- * (and therefore not already covered by the deletion offsets).
- * The reason is that a "parse-as-whitespace" recovery may not repair the problem.
- * Example damaged token: 'priva@te'
- * @author Maartje de Jonge
- */
-public class TerminalEditsAnalyzer {
-		
-	private final DamagedTokenAnalyzer tokenEdits;
-
-	//filled in the analysis
-	private final ArrayList<Integer> startOffsetsTokensDamagedByInsertions;
-	
-	/**
-	 * Extends the list of deletion-offsets,
-	 * adding all start offsets of damaged tokens that were not yet covered (e.g. only affected by insertion)
-	 */
-	public void addDamagedTokensStartOffsets(ArrayList<Integer> deletedOffsets) {
-		deletedOffsets.addAll(startOffsetsTokensDamagedByInsertions);
-		Collections.sort(deletedOffsets);
-	}
-	
-	/**
-	 * Adds to the deletion offsets the (start)offset of non-layout tokens that are damaged by an insertion only 
-	 * (and therefore not already covered by the deletion offsets).
-	 * The reason is that a "parse-as-whitespace" recovery may not repair the problem.
-	 * Example damaged token: 'priva@te'
-	 */
-	public TerminalEditsAnalyzer(DamagedTokenAnalyzer tokenEdits){
-		this.startOffsetsTokensDamagedByInsertions = new ArrayList<Integer>();
-		this.tokenEdits = tokenEdits;
-		analyze();
-	}
-	
-	private void analyze() {
-		for (IToken tokenWithInsertions : tokenEdits.getTokensDamagedByInsertion()) {
-			if(tokenWithInsertions.getKind() != Token.TK_LAYOUT && !tokenEdits.isDamagedByDeletion(tokenWithInsertions)){ //non layout, insertions only, damaged token
-				this.startOffsetsTokensDamagedByInsertions.add(tokenWithInsertions.getStartOffset());
-			}
-		}
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java
--- src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java	2012-09-28 00:32:17.000000000 +0200
@@ -40,10 +40,6 @@
 	public boolean isSyntaxCorrect() {
 		return isSyntaxCorrect;
 	}
-	
-	public void setSyntaxCorrect(boolean isSyntaxCorrect)  {
-		this.isSyntaxCorrect = isSyntaxCorrect;
-	}
 
 	private LineStartOffsetList getLineStartOffsets() {
 		if (lineStartOffsets == null)
@@ -68,7 +64,7 @@
 	}
 
 	public void markPossibleSyntaxError(LabelInfo label, IToken prevToken, int endOffset, ProductionAttributeReader prodReader) {
-		if (label.isRecover() || label.isReject() || label.getDeprecationMessage() != null || label.isCompletion()) {
+		if (label.isRecover() || label.isReject() || label.getDeprecationMessage() != null) {
 			if (prodReader.isIgnoredUnspecifiedRecoverySort(label.getSort())) {
 				// Special case: don't report here, but further up the tree
 				return;
@@ -78,38 +74,27 @@
 				isSyntaxCorrect = label.getDeprecationMessage() != null;
 			
 			// TODO: make TK_ERROR_LAYOUT token from preceding first whitespaces?
-			//TODO: refactor
+			
 			IToken first, last;
 			
 			if (prevToken == currentToken()) {
 				first = last = makeToken(endOffset, TK_ERROR, true);
 			} else {
-				first = getTokenAfter(prevToken);
-				if (first != currentToken() && first.getKind() == TK_LAYOUT)
-					first = findRightMostLayoutToken(first);
+				first = findRightMostLayoutToken(getTokenAfter(prevToken));
 				if (first != currentToken() && first.getKind() == TK_LAYOUT)
 					first = getTokenAfter(first);
 				last = currentToken();
 			}
-			if (first.getStartOffset() - 1 == last.getEndOffset()) {
+			if (first.getStartOffset() + 1 == last.getEndOffset()) {
 				// bah, we need some characters to mark, to the left then...
-				first = last = findLeftMostLayoutToken(first);//mark insertion errors at the end of previous token (before layout)
-				if (first.getKind() == TK_LAYOUT)
-					first = last = getTokenBefore(last);
+				first = findLeftMostLayoutToken(first);
 			}
 			
-			String tokenText = makeTokenText(first, last);
+			String tokenText = toString(first, last);
+			if (tokenText.length() > 40)
+				tokenText = tokenText.substring(0, 40) + "...";
 			
-			if (label.isCompletion()) {
-				if(last.getKind() == IToken.TK_LAYOUT){
-					last = findLeftMostLayoutToken(last);
-					if (last.getKind() == TK_LAYOUT)
-						last = getTokenBefore(last);
-				}
-				String completionText = makeTokenText(first, last);
-				setErrorMessage(first, last, ERROR_INCOMPLETE_PREFIX
-						+ ": '" + completionText + "'");
-			} else if (label.isReject() || prodReader.isWaterConstructor(label.getConstructor())) {
+			if (label.isReject() || prodReader.isWaterConstructor(label.getConstructor())) {
 				setErrorMessage(first, last, ERROR_WATER_PREFIX
 						+ ": '" + tokenText + "'");
 			} else if (prodReader.isInsertEndConstructor(label.getConstructor())) {
@@ -130,13 +115,6 @@
 		}
 	}
 
-	private String makeTokenText(IToken first, IToken last) {
-		String tokenText = toString(first, last);
-		if (tokenText.length() > 40)
-			tokenText = tokenText.substring(0, 40) + "...";
-		return tokenText;
-	}
-
 	/**
 	 * Sets a syntax error for the specified token range.
 	 * (Setting any other kind of error would break cacheability.)
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/AutoConcatList.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java
--- src/org/spoofax/jsglr/client/imploder/AutoConcatList.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java	2012-09-28 00:32:17.000000000 +0200
@@ -59,6 +59,15 @@
 	}
 
 	@SuppressWarnings("unchecked")
+	public boolean merges(E e) {
+	  if (e instanceof AutoConcatList) {
+	    String esort = ((AutoConcatList<E>) e).sort;
+	    return esort == null || esort.equals(sort);
+	  }
+	  return false;
+	}
+	
+	@SuppressWarnings("unchecked")
 	public boolean add(E e) {
 		if (e == null) {
 			throw new IllegalArgumentException();
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/IToken.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/IToken.java
--- src/org/spoofax/jsglr/client/imploder/IToken.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/IToken.java	2012-09-28 00:32:17.000000000 +0200
@@ -47,7 +47,7 @@
 	/** Token kind for an erroneous token. */
 	public static final int TK_ERROR_EOF_UNEXPECTED = 12;
 	
-	/** Token kind for a meta-escape operator. */
+	/** Token kind for a meta-esape operator. */
 	public static final int TK_ESCAPE_OPERATOR = 13;
 	
 	/** A reserved token kind for internal use only. */
@@ -64,9 +64,6 @@
 
 	int getStartOffset();
 
-	/**
-	 * Gets the end offset (inclusive).
-	 */
 	int getEndOffset();
 
 	int getLine();
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/ITokenizer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
--- src/org/spoofax/jsglr/client/imploder/ITokenizer.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	2012-09-28 00:32:17.000000000 +0200
@@ -22,17 +22,13 @@
 	
 	public static final String ERROR_INSERT_END_PREFIX =
 		"Syntax error, unterminated construct";
-
-	public static final String ERROR_INCOMPLETE_PREFIX =
-		"Syntax error, incomplete construct";
-
+	
 	public static final String ERROR_GENERIC_PREFIX =
 		"Syntax error";
 
 	public static final String ERROR_WARNING_PREFIX =
 		"Warning";
 
-
 	String getInput();
 
 	int getStartOffset();
@@ -69,8 +65,6 @@
 	 * invoked for each character in a skipped/erroneous region of code.
 	 * Required for keyword highlighting with {@link KeywordRecognizer}.
 	 * 
-	 * Additionally, ensures that {@link #isSyntaxCorrect()} returns false.
-	 * 
 	 * @param offset
 	 *           The offset of the 
 	 */
@@ -89,8 +83,6 @@
 	void markPossibleSyntaxError(LabelInfo label, IToken firstToken, int endOffset, ProductionAttributeReader prodReader);
 	
 	boolean isSyntaxCorrect();
-	
-	void setSyntaxCorrect(boolean syntaxCorrect);
 
 	String toString(IToken left, IToken right);
 
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/ITreeFactory.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
--- src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java	2012-09-28 00:32:17.000000000 +0200
@@ -3,8 +3,6 @@
 import java.util.List;
 
 import org.spoofax.interpreter.terms.ISimpleTerm;
-import org.spoofax.interpreter.terms.IStrategoList;
-import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.ITreeBuilder;
 
 /**
@@ -45,8 +43,6 @@
 	 */
 	TNode createList(String elementSort, IToken leftToken, IToken rightToken, List<TNode> children);
 
-	TNode createSublist(IStrategoList list, IStrategoTerm firstChild, IStrategoTerm lastChild);
-
 	TNode createTop(TNode tree, String filename, int ambiguityCount);
 
 	TNode createAmb(List<TNode> alternatives, IToken leftToken, IToken rightToken);
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java
--- src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java	2012-09-28 00:32:17.000000000 +0200
@@ -23,35 +23,25 @@
 	private static final long serialVersionUID = -578795745164445689L;
 
 	public static final TermAttachmentType<ImploderAttachment> TYPE =
-		new TermAttachmentType<ImploderAttachment>(ImploderAttachment.class, "ImploderAttachment", 6) {
+		new TermAttachmentType<ImploderAttachment>(ImploderAttachment.class, "ImploderAttachment", 5) {
 
 			@Override
 			protected IStrategoTerm[] toSubterms(ITermFactory f, ImploderAttachment attachment) {
 				IToken left = attachment.getLeftToken();
 				IToken right = attachment.getRightToken();
-				
-				String sortType = attachment.getSort() == null ? "" : attachment.getSort() ;
-				String fileName = left.getTokenizer().getFilename()  == null ? "" :left.getTokenizer().getFilename();
-				
-				
 				return new IStrategoTerm[] {
-					f.makeString(fileName),
+					f.makeString(left.getTokenizer().getFilename()),
 					f.makeInt(left.getLine()),
 					f.makeInt(left.getColumn()),
 					f.makeInt(left.getStartOffset()),
-					f.makeInt(right.getEndOffset()),
-					f.makeString( sortType )
+					f.makeInt(right.getEndOffset())
 				};
 			}
 
 			@Override
 			protected ImploderAttachment fromSubterms(IStrategoTerm[] subterms) {
-				String fileName =  asJavaString(subterms[0]).equals("") ? null :asJavaString(subterms[0]);
-				String sortType =  asJavaString(subterms[0]).equals("") ? null :asJavaString(subterms[5]);
-				
-				return createCompactPositionAttachment(fileName, asJavaInt(subterms[1]),
-						asJavaInt(subterms[2]), asJavaInt(subterms[3]), asJavaInt(subterms[4]) , sortType);
-				
+				return createCompactPositionAttachment(asJavaString(subterms[0]), asJavaInt(subterms[1]),
+						asJavaInt(subterms[2]), asJavaInt(subterms[3]), asJavaInt(subterms[4]));
 			}
 		
 		};
@@ -98,10 +88,12 @@
 	
 	/**
 	 * The element sort for list terms.
-	 * Same as {@link #getSort()} for non-list terms.
+	 * 
+	 * @throws UnsupportedOperationException
+	 *             If the node is not a list.
 	 */
 	public String getElementSort() {
-		return getSort();
+		throw new UnsupportedOperationException();
 	}
 
 	public static IToken getLeftToken(ISimpleTerm term) {
@@ -200,22 +192,13 @@
 		return createCompactPositionAttachment(filename, left.getLine(), left.getColumn(), left.getStartOffset(), right.getEndOffset());
 	}
 	
-	
-	
 	public static ImploderAttachment createCompactPositionAttachment(
 			String filename, int line, int column, int startOffset, int endOffset) {
-		return createCompactPositionAttachment(filename, line, column, startOffset, endOffset, null);
-	}
-	
-	
-	public static ImploderAttachment createCompactPositionAttachment(
-			String filename, int line, int column, int startOffset, int endOffset, String sortType) {
 		Token token = new Token(null, 0, line, column, startOffset, endOffset, TK_UNKNOWN);
-		NullTokenizer newTokenizer = new NullTokenizer(sortType, filename, token);
+		NullTokenizer newTokenizer = new NullTokenizer(null, filename, token);
 		token.setTokenizer(newTokenizer);
 		return new ImploderAttachment(null, token, token);
 	}
-	
 
 	/**
 	 * @param isAnonymousSequence  True if the term is an unnamed sequence like a list or tuple.
@@ -229,9 +212,9 @@
 	@Override
 	public String toString() {
 		if (getLeftToken() != null) {
-			return "(" + getSort() + ",\"" + getLeftToken().getTokenizer().toString(getLeftToken(), getRightToken()) + "\")";
+			return "(" + sort + ",\"" + getLeftToken().getTokenizer().toString(getLeftToken(), getRightToken()) + "\")";
 		} else {
-			return "(" + getSort() + ",null)";
+			return "(" + sort + ",null)";
 		}
 	}
 	
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/LabelInfo.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
--- src/org/spoofax/jsglr/client/imploder/LabelInfo.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	2012-09-28 00:32:17.000000000 +0200
@@ -28,6 +28,8 @@
 	private final boolean isVar;
 
 	private final boolean isList;
+	
+	private final boolean isFlatten;
 
 	private final boolean isIndentPaddingLexical;
 	
@@ -42,9 +44,7 @@
 	private final boolean isOptional;
 	
 	private final boolean isRecover;
-
-	private final boolean isCompletion;
-
+	
 	private final boolean isReject;
 	
 	private final String metaVarConstructor;
@@ -57,7 +57,8 @@
 		constructor = reader.getConsAttribute(attrs);
 		astAttribute = reader.getAstAttribute(attrs);
 		isNonContextFree = reader.isNonContextFree(rhs);
-		isList = reader.isList(rhs);
+		isList = reader.isList(rhs, attrs);
+		isFlatten = reader.isFlatten(rhs, attrs);
 		isVar = reader.isVariableNode(rhs);
 		isIndentPaddingLexical = reader.isIndentPaddingLexical(attrs);
 		isLexLayout = reader.isLexLayout(rhs);
@@ -66,11 +67,10 @@
 		isLiteral = reader.isLiteral(rhs);
 		isOptional = reader.isOptional(rhs);
 		isRecover = reader.isRecoverProduction(attrs, constructor);
-		isCompletion = reader.isCompletionProduction(attrs, production.getSubtermCount());
 		isReject = reader.isRejectProduction(attrs);
 		deprecationMessage = reader.getDeprecationMessage(attrs);
 		isSortProduction = reader.sortFun == rhs.getConstructor() || reader.parameterizedSortFun == rhs.getConstructor();
-		metaVarConstructor = reader.getMetaVarConstructor(rhs);
+		metaVarConstructor = reader.getMetaVarConstructor(rhs, attrs);
 	}
     
 	protected IStrategoList getLHS() {
@@ -108,7 +108,11 @@
 	public boolean isList() {
 		return isList;
 	}
-	
+
+  public boolean isFlatten() {
+    return isFlatten;
+  }
+
 	public boolean isVar() {
 		return isVar;
 	}
@@ -132,11 +136,7 @@
 	public boolean isRecover() {
 		return isRecover;
 	}
-
-	public boolean isCompletion() {
-		return isCompletion && !isLiteral; //exclude artificial completion start: -> "@#$"{completion}
-	}
-
+	
 	public boolean isReject() {
 		return isReject;
 	}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/ListImploderAttachment.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ListImploderAttachment.java
--- src/org/spoofax/jsglr/client/imploder/ListImploderAttachment.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ListImploderAttachment.java	2012-09-28 00:32:17.000000000 +0200
@@ -1,5 +1,6 @@
 package org.spoofax.jsglr.client.imploder;
 
+
 /** 
  * An imploder attachment for a list node,
  * which has an additional {@link #getElementSort()} operation.
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/MemoryRecordingTreeBuilder.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/MemoryRecordingTreeBuilder.java
--- src/org/spoofax/jsglr/client/imploder/MemoryRecordingTreeBuilder.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/MemoryRecordingTreeBuilder.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-package org.spoofax.jsglr.client.imploder;
-
-import org.spoofax.interpreter.terms.IStrategoAppl;
-import org.spoofax.jsglr.client.AbstractParseNode;
-import org.spoofax.jsglr.client.ITreeBuilder;
-import org.spoofax.jsglr.client.ParseTable;
-
-public class MemoryRecordingTreeBuilder implements ITreeBuilder {
-
-	private final ITreeBuilder actualBuilder;
-	private long maxTotalMemory = Long.MIN_VALUE;
-	private long maxUsedMemory = Long.MIN_VALUE;
-	private long minTotalMemory = Long.MAX_VALUE;
-	private long minUsedMemory = Long.MAX_VALUE;
-	private int measureCount = 0;
-	
-	public MemoryRecordingTreeBuilder(ITreeBuilder actualBuilder) {
-		measure();
-		this.actualBuilder = actualBuilder;
-	}
-	
-	private void measure() {
-		long total = Runtime.getRuntime().totalMemory();
-		long free = Runtime.getRuntime().freeMemory();
-		long used = total - free;
-		maxTotalMemory = Math.max(maxTotalMemory, total);
-		maxUsedMemory = Math.max(maxUsedMemory, used);
-		minTotalMemory = Math.min(minTotalMemory, total);
-		minUsedMemory = Math.min(minUsedMemory, used);
-		measureCount++;
-	}
-	
-	public void initializeTable(ParseTable table, int productionCount,
-			int labelStart, int labelCount) {
-		measure();
-		actualBuilder.initializeTable(table, productionCount, labelStart, labelCount);
-	}
-
-	public void initializeLabel(int labelNumber,
-			IStrategoAppl parseTreeProduction) {
-		measure();
-		actualBuilder.initializeLabel(labelNumber, parseTreeProduction);
-	}
-
-	public void initializeInput(String input, String filename) {
-		measure();
-		actualBuilder.initializeInput(input, filename);
-	}
-
-	public Object buildTree(AbstractParseNode node) {
-		measure();
-		return actualBuilder.buildTree(node);
-	}
-
-	public Object buildTreeTop(Object subtree, int ambiguityCount) {
-		measure();
-		return actualBuilder.buildTreeTop(subtree, ambiguityCount);
-	}
-
-	public void reset() {
-		measure();
-		actualBuilder.reset();
-	}
-
-	public ITokenizer getTokenizer() {
-		measure();
-		return actualBuilder.getTokenizer();
-	}
-
-	public long getMaxTotal() {
-		return maxTotalMemory;
-	}
-
-	public long getMaxUsed() {
-		return maxUsedMemory;
-	}
-
-	public long getMinTotal() {
-		return minTotalMemory;
-	}
-
-	public long getMinUsed() {
-		return minUsedMemory;
-	}
-
-	public int getMeasureCount() {
-		return measureCount;
-	}
-}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/NullTokenizer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/NullTokenizer.java
--- src/org/spoofax/jsglr/client/imploder/NullTokenizer.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/NullTokenizer.java	2012-09-28 00:32:17.000000000 +0200
@@ -65,10 +65,11 @@
 	protected void setErrorMessage(IToken leftToken, IToken rightToken, String message) {
 		if (leftToken != onlyToken || rightToken != onlyToken)
 			throw new IllegalArgumentException("Argument tokens do not belong to this NullTokenizer");
+		// Do nothing
 	}
 
 	public void tryMakeSkippedRegionToken(int endOffset) {
-		setSyntaxCorrect(false);
+		// Do nothing
 	}
 
 	@Override
@@ -79,10 +80,7 @@
 	@Override
 	public void markPossibleSyntaxError(LabelInfo label, IToken firstToken,
 			int endOffset, ProductionAttributeReader prodReader) {
-		
-		if (label.isRecover() || label.isReject() || label.isCompletion()) {
-			setSyntaxCorrect(false);
-		}
+		// Do nothing
 	}
 
 	public Iterator<IToken> iterator() {
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
--- src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	2012-09-28 00:32:17.000000000 +0200
@@ -148,11 +148,7 @@
 	public boolean isRecoverProduction(IStrategoAppl attrs, String constructor) {
 		return getAttribute(attrs, "recover") != null || isWaterConstructor(constructor);
 	}
-
-	public boolean isCompletionProduction(IStrategoAppl attrs, int subtermCount) {
-		return getAttribute(attrs, "completion") != null && subtermCount > 0;
-	}
-
+	
 	public boolean isRejectProduction(IStrategoAppl attrs) {
 		return getAttribute(attrs, "reject") != null;
 	}
@@ -199,10 +195,10 @@
     }
 	
 	// FIXME: support meta-var constructors
-	public String getMetaVarConstructor(IStrategoAppl rhs) {
+	public String getMetaVarConstructor(IStrategoAppl rhs, IStrategoAppl attrs) {
 		if (varSymFun == rhs.getConstructor()) {
 			rhs = termAt(rhs, 0);
-			return isList(rhs)
+			return isList(rhs, attrs)
 					? "meta-listvar"
 					: "meta-var";
 		}
@@ -340,7 +336,7 @@
 		return litFun == fun || cilitFun == fun;
 	}
 	
-	public boolean isList(IStrategoAppl rhs) {
+	public boolean isList(IStrategoAppl rhs, IStrategoAppl attrs) {
 		IStrategoAppl details = rhs;
 		
 		if (details.getConstructor() == varsymFun)
@@ -355,7 +351,14 @@
 		IStrategoConstructor fun = details.getConstructor();
 		
 		 // FIXME: Spoofax/159: AsfixImploder creates tuples instead of lists for seqs
-		return isIterFun(fun) || seqFun == fun;
+		if (isIterFun(fun) || seqFun == fun)
+		  return true;
+		
+	  return isFlatten(rhs, attrs);
+	}
+	
+	public boolean isFlatten(IStrategoAppl rhs, IStrategoAppl attrs) {
+	  return getAttribute(attrs, "flatten") != null;
 	}
 
 	public boolean isIterFun(IStrategoConstructor fun) {
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java
--- src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java	2012-09-28 00:32:17.000000000 +0200
@@ -13,7 +13,6 @@
 import static org.spoofax.terms.StrategoListIterator.iterable;
 import static org.spoofax.terms.Term.isTermAppl;
 import static org.spoofax.terms.Term.isTermString;
-import static org.spoofax.terms.attachments.ParentAttachment.putParent;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -29,10 +28,7 @@
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.IStrategoTuple;
 import org.spoofax.interpreter.terms.ITermFactory;
-import org.spoofax.terms.StrategoListIterator;
-import org.spoofax.terms.StrategoSubList;
 import org.spoofax.terms.TermFactory;
-import org.spoofax.terms.attachments.ParentAttachment;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -56,7 +52,7 @@
 	 */
 	public TermTreeFactory(ITermFactory factory) {
 		originalFactory = factory;
-		setEnableTokens(false); // (is set by TreeBuilder.initializeParseTable)
+		setEnableTokens(false);
 	}
 	
 	public void setEnableTokens(boolean enableTokens) {
@@ -136,51 +132,6 @@
 		return result;
 	}
 	
-	public IStrategoTerm createSublist(IStrategoList list, IStrategoTerm firstChild, IStrategoTerm lastChild) {
-		ArrayList<IStrategoTerm> children = new ArrayList<IStrategoTerm>();
-		boolean isStartChildFound = false;
-		int indexStart = -1;
-		int indexEnd = -1;
-
-		int i = 0;
-		for (IStrategoTerm child : StrategoListIterator.iterable(list)) {
-			if (child == firstChild) {
-				indexStart = i;
-				isStartChildFound = true;
-			}
-			if (isStartChildFound) {
-				children.add(child);
-				if (child == lastChild) {
-					indexEnd = i;
-					break;
-				}
-			}
-			i++;
-		}
-		assert(0 <= indexStart && indexStart <= indexEnd);
-		IStrategoList wrapped = factory.makeList(children);
-		StrategoSubList result = new StrategoSubList(list, wrapped, indexStart, indexEnd);
-		
-		/* XXX: support updateParents again??
-		if (cloneFirst) result = result.cloneIgnoreTokens();
-		list.overrideReferences(getLeftToken(list), getRightToken(list), children, result);
-		setParent(result, list);
-		*/
-		putParent(result, ParentAttachment.get(list));
-		
-		if(ImploderAttachment.get(firstChild) != null && ImploderAttachment.get(lastChild) != null)
-			putImploderAttachment(
-				result, 
-				true,
-				getElementSort(list), 
-				getLeftToken(firstChild), 
-				getRightToken(lastChild)
-			);
-		return result;
-	}
-
-	
-	
 	public IStrategoTerm recreateNode(IStrategoTerm oldNode, IToken leftToken, IToken rightToken, List<IStrategoTerm> children) {
 		switch (oldNode.getTermType()) {
 			case INT:
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/Token.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/Token.java
--- src/org/spoofax/jsglr/client/imploder/Token.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/Token.java	2012-09-28 00:32:17.000000000 +0200
@@ -13,9 +13,9 @@
 	
 	private static final long serialVersionUID = -6972938219235720902L;
 
-	private transient static Map<String, Integer> asyncAllTokenKinds;
+	private static Map<String, Integer> asyncAllTokenKinds;
 
-	private transient ITokenizer tokenizer;
+	private ITokenizer tokenizer;
 	
 	private final int line;
 	
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/Tokenizer.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/Tokenizer.java
--- src/org/spoofax/jsglr/client/imploder/Tokenizer.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/Tokenizer.java	2012-09-28 00:32:17.000000000 +0200
@@ -79,9 +79,7 @@
 	
 	public Token getTokenAt(int i) {
 		Token result = tokens.get(i);
-		// Disabled: might fail for testing language token sequences
-		//           (e.g., self-application.spt)
-		// assert i == 0 || result.getIndex() == i;
+		assert i == 0 || result.getIndex() == i;
 		return result;
 	}
 	
@@ -212,8 +210,6 @@
 				makeToken(offset, TK_ERROR, false, ERROR_SKIPPED_REGION);
 			}
 		}
-		
-		setSyntaxCorrect(false);
 	}
 
 	private boolean isAtPotentialKeywordEnd(int offset, boolean isInputKeywordChar) {
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/imploder/TreeBuilder.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
--- src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	2012-09-28 00:52:39.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java	2012-09-28 00:32:17.000000000 +0200
@@ -1,11 +1,13 @@
 package org.spoofax.jsglr.client.imploder;
 
+
 import static java.lang.Math.max;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_EOF;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_ERROR_EOF_UNEXPECTED;
 import static org.spoofax.jsglr.client.imploder.IToken.TK_UNKNOWN;
 
 import java.util.ArrayList;
+import java.util.LinkedList;
 import java.util.List;
 
 import org.spoofax.PushbackStringIterator;
@@ -204,62 +206,108 @@
 	 * object.
 	 */
 	@Override
-	public Object buildTreeNode(ParseNode node) {
-		LabelInfo label = labels[node.getLabel() - labelStart];
-		IToken prevToken = tokenizer.currentToken();
-		int lastOffset = offset;
-		AbstractParseNode[] subnodes = node.getChildren();
-		boolean isList = label.isList();
-		boolean lexicalStart = false;
-		
-		if (!inLexicalContext && label.isNonContextFree())
-			inLexicalContext = lexicalStart = true;
-		
-		List<Object> children = null;
-		if (!inLexicalContext) {
-			if (isList) {
-				children = new AutoConcatList<Object>(label.getSort());
-			} else {
-				children = new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
-			}
-		}
-
-		// Recurse
-		for (AbstractParseNode subnode : subnodes) {
-			Object child;
-			if (inLexicalContext && subnode.isParseProductionChain()) {
-				child = chainToTreeTopdown(subnode);
-			} else {
-				// TODO: Optimize stack - inline toTreeTopdown case selection?
-				child = subnode.toTreeTopdown(this);
-			}
-			// TODO: handle ambiguities in lexicals better (ignored now)
-			if (inLexicalContext)
-				child = null;
-			if (child != null)
-				children.add(isList ? child : tryBuildAutoConcatListNode(child));
-		}
-		
-		if (!inLexicalContext && isList && children.isEmpty()) {
-			IToken token = tokenizer.makeToken(tokenizer.getStartOffset() - 1, IToken.TK_LAYOUT, true);
-			((AutoConcatList) children).setEmptyListToken(token);
-		}
-		
-		Object result;
-		if (lexicalStart) {
-			result = tryCreateStringTerminal(label, lastOffset);
-			inLexicalContext = false;
-		} else if (inLexicalContext) {
-			tokenizer.tryMakeLayoutToken(offset - 1, lastOffset - 1, label);
-			result = null; // don't create nodes inside lexical context; just create one big token at the top
-		} else if (isList) {
-			result = children;
-		} else {
-			result = createNodeOrInjection(label, prevToken, children);
-		}
-		tokenizer.markPossibleSyntaxError(label, prevToken, offset - 1, prodReader);
-		return result;
-	}
+	 public Object buildTreeNode(ParseNode node) {
+    LabelInfo label = labels[node.getLabel() - labelStart];
+    IToken prevToken = tokenizer.currentToken();
+    int lastOffset = offset;
+    AbstractParseNode[] subnodes = node.getChildren();
+    boolean isList = label.isList();
+    boolean isLayout = label.isLayout();
+    boolean lexicalStart = false;
+    
+    if (!inLexicalContext && label.isNonContextFree())
+      inLexicalContext = lexicalStart = true;
+    
+    List<Object> children;
+    
+    if (isLayout) {
+      // structure of layout does not matter; can simply iterate over all production nodes
+      children = null;
+      
+      LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
+      nodes.push(node);
+
+      while (!nodes.isEmpty()) {
+        AbstractParseNode current = nodes.pop();
+        
+        if (current.isParseProductionNode())
+          buildTreeProduction((ParseProductionNode) current);
+        
+        for (int i = current.getChildren().length - 1; i >= 0; i--)
+          nodes.push(current.getChildren()[i]);
+      }
+    }
+    else if (isList) {
+      children = inLexicalContext ? null : new AutoConcatList<Object>(label.getSort());
+
+      LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
+      nodes.push(node);
+
+      while (!nodes.isEmpty()) {
+        AbstractParseNode current = nodes.pop();
+        
+        LabelInfo currentLabel = current.isAmbNode() || current.isParseProductionNode() ? null : labels[current.getLabel() - labelStart];
+        
+        if (currentLabel != null && currentLabel.isList() && (label.getSort() == null ? currentLabel.getSort() == null : label.getSort().equals(currentLabel.getSort())))
+          for (int i = current.getChildren().length - 1; i >= 0; i--)
+            nodes.push(current.getChildren()[i]);
+        else {
+          Object child;
+          if (inLexicalContext && current.isParseProductionChain())
+            child = chainToTreeTopdown(current);
+          else
+            child = current.toTreeTopdown(this);
+
+          // TODO: handle ambiguities in lexicals better (ignored now)
+          if (inLexicalContext)
+            child = null;
+          if (child != null)
+            children.add(child);
+        }
+      }
+
+      if (!inLexicalContext && isList && children.isEmpty()) {
+        IToken token = tokenizer.makeToken(tokenizer.getStartOffset() - 1, IToken.TK_LAYOUT, true);
+        ((AutoConcatList) children).setEmptyListToken(token);
+      }
+    } 
+    else {
+      children = inLexicalContext ? null : new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
+
+      // Recurse
+      for (AbstractParseNode subnode : subnodes) {
+        Object child;
+        if (inLexicalContext && subnode.isParseProductionChain()) {
+          child = chainToTreeTopdown(subnode);
+        } else {
+          child = subnode.toTreeTopdown(this);
+        }
+        // TODO: handle ambiguities in lexicals better (ignored now)
+        if (inLexicalContext)
+          child = null;
+        if (child != null)
+          children.add(tryBuildAutoConcatListNode(child));
+      }
+    }
+
+    
+    Object result;
+    if (lexicalStart) {
+      result = tryCreateStringTerminal(label, lastOffset);
+      inLexicalContext = false;
+    } else if (isLayout) {
+      result = null;
+    } else if (inLexicalContext) {
+      tokenizer.tryMakeLayoutToken(offset - 1, lastOffset - 1, label);
+      result = null; // don't create nodes inside lexical context; just create one big token at the top
+    } else if (isList) {
+      result = children;
+    } else {
+      result = createNodeOrInjection(label, prevToken, children);
+    }
+    tokenizer.markPossibleSyntaxError(label, prevToken, offset - 1, prodReader);
+    return result;
+  }
 
 	/**
 	 * Efficiently consume lexical chars in parse production chains.
@@ -287,7 +335,17 @@
 	public Object buildTreeAmb(ParseNode a) {
 		if (inLexicalContext) {
 			// Ignore ambiguities in lexicals; can't show them in AST
-			return a.getChildren()[0].toTreeTopdown(this);
+			AbstractParseNode n = a.getChildren()[0];
+			switch (n.getNodeType()) {
+	    case AbstractParseNode.CYCLE :
+	      return buildTreeCycle((CycleParseNode) n);
+	    case AbstractParseNode.PARSE_PRODUCTION_NODE :
+	      return buildTreeProduction((ParseProductionNode) n);
+	    case AbstractParseNode.AMBIGUITY :
+	      return buildTreeAmb((ParseNode) n);
+	    default :
+	      return buildTreeNode((ParseNode) n);
+	    }
 		}
 		
 		final int oldOffset = offset;
@@ -305,7 +363,22 @@
 			tokenizer.setStartOffset(oldBeginOffset);
 			inLexicalContext = oldLexicalContext;
 			
-			Object child = tryBuildAutoConcatListNode(subnode.toTreeTopdown(this));
+			Object subtree;
+			switch (subnode.getNodeType()) {
+      case AbstractParseNode.CYCLE :
+        subtree = buildTreeCycle((CycleParseNode) subnode);
+        break;
+      case AbstractParseNode.PARSE_PRODUCTION_NODE :
+        subtree = buildTreeProduction((ParseProductionNode) subnode);
+        break;
+      case AbstractParseNode.AMBIGUITY :
+        subtree = buildTreeAmb((ParseNode) subnode);
+        break;
+      default :
+        subtree = buildTreeNode((ParseNode) subnode);
+      }
+			Object child = tryBuildAutoConcatListNode(subtree);
+			
 			if (child != null) children.add(child);
 		}
 		IToken leftToken = null; 
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
--- src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java	2012-09-28 00:32:17.000000000 +0200
@@ -86,10 +86,11 @@
 	 * @throws IncrementalSGLRException
 	 *             If the input could not be incrementally parsed.
 	 *             It may still be possible to parse it non-incrementally.
+	 * @throws InterruptedException 
 	 */
 	@SuppressWarnings("unchecked")
 	public TNode parseIncremental(String newInput, String filename, String startSymbol)
-			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
+			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException, InterruptedException {
 		
 		lastReconstructedNodes = Collections.emptyList();
 
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/incremental/IncrementalSortSet.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/incremental/IncrementalSortSet.java
--- src/org/spoofax/jsglr/client/incremental/IncrementalSortSet.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/incremental/IncrementalSortSet.java	2012-09-28 00:32:17.000000000 +0200
@@ -10,7 +10,6 @@
 import static org.spoofax.terms.attachments.ParentAttachment.getParent;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -44,40 +43,28 @@
 	private final Set<String> incrementalSorts;
 	
 	private final Set<String> incrementalContainerSorts;
-	
-	public Set<String> getIncrementalSorts() {
-		return Collections.unmodifiableSet(incrementalSorts);
-	}
-	
+
 	/**
 	 * @param expand
 	 *            Whether to expand the set of sorts with injections to those
 	 *            sorts (e.g., add MethodDec if ClassBodyDec was specified.)
 	 */
-	private IncrementalSortSet(ParseTable table, boolean expand, boolean expandReverse, Set<String> sorts) {
+	private IncrementalSortSet(ParseTable table, boolean expand, Set<String> sorts) {
 		sortFun = table.getFactory().makeConstructor("sort", 1);
 		cfFun = table.getFactory().makeConstructor("cf", 1);
 		lexFun = table.getFactory().makeConstructor("lex", 1);
 		incrementalSorts = expand ? getInjectionsTo(table, sorts, false) : sorts;
-		incrementalContainerSorts = expandReverse ? getInjectionsTo(table, incrementalSorts, true) : incrementalSorts;
+		incrementalContainerSorts = getInjectionsTo(table, incrementalSorts, true);
 	}
 	
 	public static IncrementalSortSet create(ParseTable table, boolean expand, String... sorts) {
-		return new IncrementalSortSet(table, expand, true, asSet(sorts));
+		return new IncrementalSortSet(table, expand, asSet(sorts));
 	}
 	
 	public static IncrementalSortSet create(ParseTable table, boolean expand, Set<String> sorts) {
-		return new IncrementalSortSet(table, expand, true, sorts);
-	}
-
-	public static IncrementalSortSet create(ParseTable table, boolean expand, boolean expandReverse, String... sorts) {
-		return new IncrementalSortSet(table, expand, expandReverse, asSet(sorts));
-	}
-
-	public static IncrementalSortSet create(ParseTable table, boolean expand, boolean expandReverse, Set<String> sorts) {
-		return new IncrementalSortSet(table, expand, expandReverse, sorts);
+		return new IncrementalSortSet(table, expand, sorts);
 	}
-
+	
 	public static IncrementalSortSet read(ParseTable table) {
 		IStrategoConstructor incrementalFun = table.getFactory().makeConstructor("incremental", 0);
 		ProductionAttributeReader reader = new ProductionAttributeReader(table.getFactory());
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/indentation/LayoutConstraint.def ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/LayoutConstraint.def
--- src/org/spoofax/jsglr/client/indentation/LayoutConstraint.def	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/LayoutConstraint.def	2012-06-07 12:14:42.000000000 +0200
@@ -0,0 +1,62 @@
+definition
+module LayoutConstraint
+
+exports
+  
+context-free start-symbols
+  Constraint
+
+lexical syntax
+  [\ \t\n\r] -> LAYOUT
+
+lexical syntax
+  [0-9]+ -> Nat
+  [a-zA-Z][a-zA-Z0-9]* -> Var
+  "all" -> Var {reject}
+lexical restrictions
+  Nat -/- [0-9]
+  Var -/- [a-zA-Z0-9]
+  "all" -/- [a-zA-Z0-9]
+
+context-free syntax
+  Nat -> Constraint {cons("tree")}
+  "num" "(" Nat ")" -> Constraint {cons("num")}
+  Var -> Constraint
+  "all" "(" Var "," Constraint "," Constraint ")" -> Constraint {cons("all")}
+  
+context-free priorities
+  {
+    Constraint "." "first" -> Constraint {cons("first")}
+    Constraint "." "left" -> Constraint {cons("left")}
+    Constraint "." "right" -> Constraint {cons("right")}
+    Constraint "." "last" -> Constraint {cons("last")}
+    Constraint "." "line" -> Constraint {cons("line")}
+    Constraint "." "col" -> Constraint {cons("col")}
+    "!" Constraint -> Constraint {cons("not")}
+  }
+ >
+  { right:
+    Constraint "*" Constraint -> Constraint {cons("mul")}
+    Constraint "/" Constraint -> Constraint {cons("div")} 
+  }
+ >
+  { right:
+    Constraint "+" Constraint -> Constraint {cons("add")}
+    Constraint "-" Constraint -> Constraint {cons("sub")}
+  }
+ >
+  { right:
+    Constraint "==" Constraint -> Constraint {cons("eq")}
+    Constraint "<" Constraint -> Constraint {cons("lt")}
+    Constraint "<=" Constraint -> Constraint {cons("le")}
+    Constraint ">" Constraint -> Constraint {cons("gt")}
+    Constraint ">=" Constraint -> Constraint {cons("ge")}
+  }
+ >
+  { right:
+    Constraint "&&" Constraint -> Constraint {cons("and")}
+  }
+ >
+  { right:
+    Constraint "||" Constraint -> Constraint {cons("or")}
+  }
\ No newline at end of file
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/indentation/LayoutConstraint.sdf ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/LayoutConstraint.sdf
--- src/org/spoofax/jsglr/client/indentation/LayoutConstraint.sdf	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/LayoutConstraint.sdf	2012-06-07 12:14:38.000000000 +0200
@@ -0,0 +1,61 @@
+module LayoutConstraint
+
+exports
+  
+context-free start-symbols
+  Constraint
+
+lexical syntax
+  [\ \t\n\r] -> LAYOUT
+
+lexical syntax
+  [0-9]+ -> Nat
+  [a-zA-Z][a-zA-Z0-9]* -> Var
+  "all" -> Var {reject}
+lexical restrictions
+  Nat -/- [0-9]
+  Var -/- [a-zA-Z0-9]
+  "all" -/- [a-zA-Z0-9]
+
+context-free syntax
+  Nat -> Constraint {cons("tree")}
+  "num" "(" Nat ")" -> Constraint {cons("num")}
+  Var -> Constraint
+  "all" "(" Var "," Constraint "," Constraint ")" -> Constraint {cons("all")}
+  
+context-free priorities
+  {
+    Constraint "." "first" -> Constraint {cons("first")}
+    Constraint "." "left" -> Constraint {cons("left")}
+    Constraint "." "right" -> Constraint {cons("right")}
+    Constraint "." "last" -> Constraint {cons("last")}
+    Constraint "." "line" -> Constraint {cons("line")}
+    Constraint "." "col" -> Constraint {cons("col")}
+    "!" Constraint -> Constraint {cons("not")}
+  }
+ >
+  { right:
+    Constraint "*" Constraint -> Constraint {cons("mul")}
+    Constraint "/" Constraint -> Constraint {cons("div")} 
+  }
+ >
+  { right:
+    Constraint "+" Constraint -> Constraint {cons("add")}
+    Constraint "-" Constraint -> Constraint {cons("sub")}
+  }
+ >
+  { right:
+    Constraint "==" Constraint -> Constraint {cons("eq")}
+    Constraint "<" Constraint -> Constraint {cons("lt")}
+    Constraint "<=" Constraint -> Constraint {cons("le")}
+    Constraint ">" Constraint -> Constraint {cons("gt")}
+    Constraint ">=" Constraint -> Constraint {cons("ge")}
+  }
+ >
+  { right:
+    Constraint "&&" Constraint -> Constraint {cons("and")}
+  }
+ >
+  { right:
+    Constraint "||" Constraint -> Constraint {cons("or")}
+  }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/indentation/LayoutConstraint.tbl ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/LayoutConstraint.tbl
--- src/org/spoofax/jsglr/client/indentation/LayoutConstraint.tbl	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/LayoutConstraint.tbl	2012-06-07 12:14:42.000000000 +0200
@@ -0,0 +1,107 @@
+  KU<int>  M[_,_] "012G-/F.3 []  layout  lex term lit )4+#( 56&7!8"%$:9range   reject  left  opt assoc 	sort CD;'cf 	
+prod L
+char-class "	iter-star attrs iter no-attrs  , cons <*=>?,@6&7!8AB9:E== <START> ( not or and ) left - < + right . > * / line <Start> <= || gt >= sub action goto M shift 8 gtr-prio   arg-gtr-prio ;   	state-rec J label L && ! col last first all num 
+Constraint ge le lt eq add div mul Var Nat tree reduce A   accept  states 
+priorities parse-table   HIJ 0   @    9 @ H H      i    0 @P  $	@="H`E@R  	 X0F4`H   p    H      *($  HH-    BD 0  8  QM'  	`)b   pTpH !  Z   "HC   d   F@Z@P"  "h5@   xHt    \@($ t   j|Q={Ha%fA@  #,@I)   b @Ah<Fz@2J!4B= yH0$&X~@  '&TI0<B,b6   x.@8dLH3p$B8^@     \	x4/IAOW  $B=kz $c<7   
+Dy 
+AAJK\  
+ Y2IA"yrhAYA!"r   )@T4mIM-P  "RB=kz$R";   F0i3!h`+   @tcFxF`$L1+   y`V*Ad   26!X5Id  , KA=;C0	{	  f<pzHfA5 2   9@.Hfx%@  
++#UA	JH  BC=i3!XsP   @|C`At`$B)A-    SE
+Ji   0@BT'F  ADC$T   XR h  )DO 
+@  *T5BP	H  "	f    .Db   
+x`   JHQc   *UXWa   ?j8bB@  #F3
+:p	   /Z@  >t`&x  ^E    M^   hM>6   
+d   fD  3E]!A0G`  i	BW   EHGN  "    Z92	HFFIM  B2@   6m<T   ("4@  .P !  JJ  8t2   Q   ;NB6bl  p   P"p  JBe3   T#(&(\  @RS"   .]d=B)Zr  (   nB>Q0  fJM   TD  <zvD%@j@  
++Et#A:J  	#U%h  C   ~!Z1  "#&   -=,   p1Dl0O  a   cF	*   P  )HPa8@  
+  8L#&  C2B   #N-   (@  *4o0`e  9neg  b	   PLl`  \xa0  H#X%  @   {IU~V`@  `%*a-`   uAd   v6	   BFv.@@  Fl   +# 'W(   )	M   29*B@r    L<@   ##%AO0    i	 C9:Bry	bq,Za9@9	   @ 
+	@ FcH2  8$   1hQdQf  0[L|   4c?   E	4_  F81Bu	`   xPE   8c &    A%	X$  8)BA   !dPE0c&`Ae	X"89B~tP? T&`	XX"8%BX	   >lP7T&0   U	h\"  z85BJ|P;$   !5	X"8-B|    .bP   3&1h   !u	LF/   :8=BCrPE=4&hh	8B8#Bv   6jD   54&QphM	LZ83By@   zD   " @ d"b/#@	1L7"08LR
+ 9 p0(	y0$>`  T`'K EX@	a;reF D   X" r(TP+3 Uhb3qA Q	A &
+   ckX j3HITm lpT    [  &69X:FJTHp 7c    N( v8
+U:A"89@ N(!' 8.@  8@q #0sptA@0X8 YHq Pq$q*
+EA .8*FK\r#IPP=)8`q !0; L-C.;Tvx} hULjq@(TD$DOp;xcBB!/B"H9@ a$(& x8@ 70rteA@6(p>	wEAE@L 5)~8 !Rp; `
+JBD~'dDH4;L  F ?U:*A8 	!R1p@`P0A^	 pN)
+`, ` ('4H0Tj
+N BpT`    D' !9d:CJKT, Vp Bt   	 '(8	!:UZa 
+ e   |'9@	 8NE2(
+!
+)"  11,%DbG|F@L   Q(|K"  8T*"W   ,NUrl   3A&qlQh["184:"[NM%A#4@/\B4dQjN-!r    GZY[Ix3  !L$\	1jN!`DZ YZ   v!LbdX"$jDI`H IeT1@(TB>48eBMQIPl_   2ska,X='!IrIai[  sD$R  K!. y@@l1	E
+dzd;'	`6N#rVD,P  W!.#a0!GRA0   y9`NseJB   %x?,/cT2#q8S@2D   P!8)aD@  bPQBbeQUjEJ9N=sSX
+  	&    e8lH   NJr*SRQ!U   dK251   	)`Ns JrB\G	"	2)!P`
+U F@JDd$Zz&59i   N`   =S6T0!U8
+`NGe2   S*%  P]B|B@u	DQNCQ(JiN} qX884   Q58li`CNCq qz&I   %(%x<BrhIN0JT
+ae-yQS
+	h5AI39`N{:rP   tp}58li`;NCq6pE  8\;.t#n5B^:R%?Ue.BT   tHme   VzV}T:zsv  +=G$g#9  hp,3  @hg7(
+Dr!~tpg?(*ErAX	8p <s	58@_NrS08X+s30Tg9lIJ	pa'$.0*J=&s)3&XN  L0bg9lQ<
+OSNT.)8b0'UFa. uPXYf1%fqtE  vaB% stM  .a=+U~a#/21"s "PZ\,R
+2&Ie	bD&@1bcYAZY[
+! vCXLR23Ue&@  SXB
+H*LpJ(P
+ Xr8!>d&8 YR/G@  p`5QT &   1 l g,GH}T qT  - l sg9:GT^%p$ 7  ;a,(UC{g"F   TvAT~Rvq$a&;(rBU@/g {9*Avr]) PPj >N&0p UPH9 Tt s _gGH:T!*t`&   ".CP*"r (EH9 Pqs#e*
+UEV8M1T{ 2'8 	9R,Nps`JQS9 T:s 
+ .GHT"x9a8sQ8a9"/,)qJTdUBU2K0jTpY.Qc
+\ :>EHr 5Pqs9*
+ UAV  9
+*FX   nr#s E#PP|,A#n3q Pq;*"j sT{  nw8J:G9T#E*@<d2F(Z "Q 9@y C2D(U	Ly"O 'BOd4B;H*j ^sT!  E /8*:FT+E Lk[l	 t*8  QR pw`JP\ gjt) O| #GHU 71M0 /9<@#_	
+EJ:r	YQ
+UEG$0?px8Qn?yB CM&
+H/| D6_D&@/cZ<LaS$AR   D.h!p  %a  IC   .$p41\,K(cp1\4Hc(.vP2 \Nc@p.NP,`\ ()@@.
+qt@\Lhq! \     h   T*2.r@$\"q (  E3   s2   D\#$   aFiA.1Pf ea&yA.)PfdT.3.\aqgT 3@L.bap\dB Z CE   .   f4y  	BXMk   PSFp.   g4d*fC8 	 .h qp=e%@  bXo  6qAY   6.MQV   5d5@  b@K6(k1r\{S>(kp*1r\Xb9`pEz.<st\95ahE@.QrT\e)hh  	Eq   Qs   \	l"   y%hp  Eq   s\  LbdTCd@2CG"&"' h!^"y$3 EP>@ .Hq@.K r\0e  dn	Gd   .;P   K\44(%Iq<rq\<$%*Iq`<KTX. %p$K p1H%@!.2	sK\!    hG4  1   p&qH  |\)   hg$  9   3tF\2a4`e   rv(  \@\   >iB=.FP7K+
+tyB.AP;KT+V,W.\iq#KT+ z)W@.bp5K\d	R 
+aCF   e.8Hn   )K4[@  RDM  SG   E.$L9   !K4G@  *fA1Bd@&[ p)I  7.(s@.\(<   *!(Z  J  9q )re1YAxG.,NP^!rqEAx{.,qv\8-luAx.Yp\D
+ 	,H	e@.r YpP<4W@  2$P  cGzT   3.D>   44O@  2$P  LsF  `aT3,p@+a\P
+hWB)	A4   JRQ~M   +\T0W5#(J/rr\t W= */q`?T__. /p'_ w1H@/.2ys\,   +$h   >  3
+T+ Y\&W42` 7  pr	   \   ZW iFnFQ+`IJRyF~AQ+TT`JJW D\%q+WT`O <W0@8bp+1\d tWECAt   QHA   
++V40G@  M  "%S@   IL!   +W4(K@  *f@]HlR `%I U *(Us@\B   WeiFrYFQ,UhC*JyFREAQ$TThA*qW2U\q0WThD* AW*U@bp/+y\d .WrCA   uHa}   U
+5\WW  NBP   #TxH   @{W(<%pm\kW(*<$p-\Xj5p&<5q\j55U@zr\MW	h  Ui"(`  Uq  L|T$ 5 IMs   \H-FD+VQkdMFmFD;QQk\"0p5]Qk\" @Rq7\	u0   z#EE  `T(-pX  K\C   P  &>`  -pz%  \i3Kcf   H8  5f:`  p'  s\i)K&  ND|Z&T
+%jcVU
+Df4*-H6`j9`  U0?*Hv 66B!5`  mrk2T"J  KLvY1e=Wq!*k uR1-`  p \`uq~'Qub,@>ADS	:N3 49&TG8]p *2z   e(.u	4B9\a"6   -n@u pI'\ z   @u {0rFtM<.E!z seH   P=q13rh.Eq	; c*@l   7r/\ SAt7*( R%'`  }p# \`zQcK    \ W"gHT] n q&TK   \  ~:FTOp (2~   `7(4Bryi"   (7A@ nti"C'D2cC'x585X5$MNdhf *1To"#p >2:a   \7( 4rHY#   7@ nl=h Fp  Q@ n0#rt,0~y F7eH   nPq-3FiaeG7 *Bf   lncr!3K* Vi YR3,  p7 `	,XcYQ3DM nY    & ~7)gH,
+Rn qT   $ & 17:EfT`Sp <6e  & Y7( MY4&"%SXS$@E2dCT4s*(Wii MYR;*   p: `
+Vb=#2~3&82x[#XZY[>A,&dfL f`*h@@9eC7 k*@\   vnr sJS*8[i YR'&  sp3 `V`P"[G n   < w7#gH\An q6T     ?7:FFT(p 8[}   P( -42E[bm"   E@
+- nvyf&R   %@- 	n0rvt+1U LeH  - nPKq*[~iYC {*@<   ynr[ J]*<Yi R   +p1[ `VZV`PKU U 9Y2 6.uPkb#)0\@!GB$biQGu4)zXTTA5*H*(t_PkJ:_5D 4Rdb)QXu6:!2& UDXT~D*A</twSkJG%GnmcIQ
+E6E+XTbM	*	B8Qb3)0\@!uGC=bQGuDzXTJG!*M _Q JQz_E= 4z=bQ m n     ^ HBY(<@0ZX|-&l!m3u0 5\$@"lGA5 VC#
+   e-@m na67 ^  m@m n0[rt-yM_v H  m {nPqsQkFhs '*C|   n;r1 !^l*Jv'PnSv` ]jF@EjC5nb!bQ[X0azTN3V&*Dv#U jEE05na S#   G =@ wni%{'Wx{%hdGiLpkwI;87cOm ?f:?"-A ]  @ 0 rt-hhm (wH   Pq;sIkED#!8ma s=W)Gh3CDj8Ta6Q
+*9gG5Fkl4q# H Q`c"Q(tpHdm8TI%1.;djB"L-%q,sW
+!k\qP3KwDEbPAVB <*O'1q Q  ^%
+N*ZaCJ  RMPaQs. +@  ICPR\%:u@@g=:hXT%6grVq?*rFXnw s*@p r;;  9PP*
+< GB	#w@ M(lMTu1p5N@P6]`ID1w%nLV	.	w)"
+`yw=]`2pR@!Pv]`{Ws8260upmw3k]`WpAP`{ 7p>Q
+P&R*`KD9sw>Lg Gzinwy/$nAVn[w)b&n7wkwp#
+vf~}qXOw{iy@n0=gp8 {60mn]Y{AVHG|a6gX(C%L
+
+pH As$R1AP)(bP?2Aho#+t	q&SAz:e|{v*'Ii{Op8
+{px3:xO{s86{	pxxO{/r){K^"# IWJ^$||{*	q8 G7Y7x(?Iapv3-KCBw(()mJ@R[e}ml>"h~6Qo(h>
+`SUe
+#],>!(QQ(.>PRe
+
+rS} L>#i&Q/(/>=
+ YL20@m<ROJk_P=4$(#P(`%<J;(Q1
+3&=3PO( ~=JG?P2~%(+JP(PwyFRO	  2wp QazQ Kd= ~ H2Tr-` _	eM]R@(xfs^%oyA@DiPS'/(Dz $);fB"T$%I@7
+&	N YyTP7((#Aj$Px  <wpR=(J ><HA}yFQn}yFQ0<pyp/Q
+<p$ y@R,`<@y#E?4~M Ay A <:!:	:NXP(h0H2wGE6 yC`,`< ]!PP$Hx R+' 8<`.Q1HC p*X < ^H,T	r AT< 
+! xFbl_ ,
+&! i(HxC \x<U"0%(y@C 8.(<< 	hx@C j0P!tA@(x a }"HC P6z*
+9Gq3 yC&0<(]!PP3x R-% ,<`aBNQ	I t*h<a [H4T
+rOb paT@< 
+ 8xFb[A<0O6TI?	Ad<G@>xLHH"!()<y#`l$J"A9C'1xx#1a(R	(Q9)dx#i}HX
+G<60D6) JSG<zQy#k6G<CTD&rHbu#GA<VQJ3Ty`e(ah!>tx} X;G<
+p4y	` ha=A5.xcC}X <60^6*1 	h&<z1q(AyiML?eD<G16/1 <iGQu xpDX2 <]"QPP2x  (@7 <xhO>(xG>x@<DdW yD &QB"<yD 
+!QTBqW\TBq 3@'b8<d q }yhB :(4bMlyC &,4
+*fDdQPO  xXA ' <] PP.<Bx 
+R6'<`	b
+vQdQ *<' <	 O'HXT" DqTQ<  dO"yDVI ' ,O(bxl' <|U#BO y@ x~.(+eE)< Ix@ 0$	tA@[(/I :OH 4P'KT*
+DVO  xDA@d#' <] PP&?rx %R<'<`
+6QxPS 	*?' < O$HpT ITE< ) aO
+yF^N4@<	)0	O>PIYI8Ade<O>xLS$K*I!k(!<uOyS`*$SRNY@a=OxS(Rp(j x}4X1<6i0O!i'J<z {Oy6k-<2CT&+B7@<V	O3y`t~ph
+	Fx3}XgC<p`y3`pr(&x	3} LX<g<60"'	,g3<z4(Bxd,8ML)eWs<l''	,Kg<2j/YD@HI1, B 1 4Ax0`hA`` L	` p4h0hlAa
+A`p*"PD1 C p0d"5A`hD
+B#H@1B`0lB%(A`x2#P@
+ @@b9Ad*'PO>A)O oj<5~	Atx
+G?Apwf\%(Al2}@8n}`8^}Pn}p^}I8^ }i&`Y`y&Q`EA`dbU%A8(4zAKn2^A|8*=PY Apz# Sala([Abr=QA%$z$E Ci"	H PArR ^A$ ]e<	HtWA(q\
+[iqq	un/ nip=tKZ>]WAt8
+	+[A:1KzLV]`bA,``cXtsf2PlgA,(:nFk25NtASv
+#d'AHT:D	gtAcn8RqhGA=$:Aob6ptC~#`` AA:`6p/}a`ol   <7l+  vB;`1Lm@` 
+MA-#jm#6`MD"#l!O#`uQ [e@Q [E@5Q [E	@l%T@9V^DP%l5@9VDPl-@9D P9l1,[
+M-"K`(%1l=T@6DPl#@6DP!l3@D Pl+@D>l1/6
+M"s`(96l%+6
+Lf3`:l)-6MMS`H)2l#)6	Mb&`	<l).6Mc`H1*4l5*6LF#`H28l9,6M"C`!&0l3(6
+bD @l$@) `8X'8@6} /''	zr`^X.''#	ur`
\ No newline at end of file
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/indentation/LayoutFilter.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/LayoutFilter.java
--- src/org/spoofax/jsglr/client/indentation/LayoutFilter.java	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/LayoutFilter.java	2012-09-28 00:32:17.000000000 +0200
@@ -0,0 +1,343 @@
+package org.spoofax.jsglr.client.indentation;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Stack;
+
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoConstructor;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.jsglr.client.AbstractParseNode;
+import org.spoofax.jsglr.client.ParseNode;
+import org.spoofax.jsglr.client.ParseTable;
+import org.spoofax.jsglr.client.imploder.ProductionAttributeReader;
+import org.spoofax.terms.Term;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ *
+ */
+public class LayoutFilter {
+
+  private final Object NO_VALUE = null;
+  
+
+  private final boolean atParseTime;
+  private ParseTable parseTable;
+  private ProductionAttributeReader attrReader;
+  private int disambiguationCount;
+  private int filterCallCount = 0;
+  
+  /**
+   * 
+   * @param parseTable
+   * @param atParseTime if true, the filter is conservative: it only discards
+   *   trees whose parser state can be discarded in general. This is needed
+   *   when discarding trees at parse time, when a later join may represent
+   *   alternative trees by the same parser state.
+   */
+  public LayoutFilter(ParseTable parseTable, boolean atParseTime) {
+    this.parseTable = parseTable;
+    this.attrReader = new ProductionAttributeReader(parseTable.getFactory());
+    this.atParseTime = atParseTime;
+  }
+  
+  int error = 0;
+  
+  public int getFilterCallCount() {
+    return filterCallCount;
+  }
+  
+  public int getDisambiguationCount() {
+    return disambiguationCount;
+  }
+  
+  public boolean hasValidLayout(ParseNode t) {
+    return hasValidLayout(t.getLabel(), t.getChildren());
+  }
+  
+  public boolean hasValidLayout(int label, AbstractParseNode[] kids) {
+    IStrategoTerm layoutConstraint = parseTable.getLabel(label).getAttributes().getLayoutConstraint();
+    
+    if (layoutConstraint == null)
+      return true;
+    
+    disambiguationCount = 0;
+    filterCallCount++;
+    Boolean b = evalConstraint(layoutConstraint, kids, new HashMap<String, Object>(), Boolean.class);
+    if (b == NO_VALUE)
+      return true;
+    return b;
+  }
+  
+  @SuppressWarnings("unchecked")
+  private <T> T evalConstraint(IStrategoTerm constraint, AbstractParseNode[] kids, Map<String, Object> env, Class<T> cl) {
+    Object o = evalConstraint(constraint, kids, env);
+    ensureType(o, cl, constraint);
+    return (T) o;
+  }
+  
+  private Object evalConstraint(IStrategoTerm constraint, AbstractParseNode[] kids, Map<String, Object> env) {
+    switch (constraint.getTermType()) {
+    case IStrategoTerm.INT: {
+      int i = Term.asJavaInt(constraint);
+      return getSubtree(i, kids);
+    }
+      
+    case IStrategoTerm.STRING:
+      String v = Term.asJavaString(constraint);
+      Object o = env.get(v);
+      if (o == null)
+        throw new IllegalStateException("undefined variable " + v);
+      return o;
+      
+    case IStrategoTerm.APPL:
+      IStrategoConstructor cons = Term.tryGetConstructor(constraint);
+      String consName = cons.getName();
+      
+      if (consName.equals("num")) {
+        String num = Term.asJavaString(constraint.getSubterm(0));
+        int i = Integer.parseInt(num);
+        return i;
+      }
+      if (consName.equals("tree")) {
+        String num = Term.asJavaString(constraint.getSubterm(0));
+        int i = Integer.parseInt(num);
+        return getSubtree(i, kids);
+      }
+      if (consName.equals("eq") ||
+          consName.equals("gt") ||
+          consName.equals("ge") ||
+          consName.equals("lt") ||
+          consName.equals("le")) {
+        ensureChildCount(constraint, 2, consName);
+        Integer i1 = evalConstraint(constraint.getSubterm(0), kids, env, Integer.class);
+        Integer i2 = evalConstraint(constraint.getSubterm(1), kids, env, Integer.class);
+        return binArithComp(consName, i1, i2);
+      }
+      if (consName.equals("add") ||
+          consName.equals("sub") ||
+          consName.equals("mul") ||
+          consName.equals("div")) {
+        ensureChildCount(constraint, 2, consName);
+        Integer i1 = evalConstraint(constraint.getSubterm(0), kids, env, Integer.class);
+        Integer i2 = evalConstraint(constraint.getSubterm(1), kids, env, Integer.class);
+        return binArithOp(consName, i1, i2);
+      }
+      if (consName.equals("first") ||
+          consName.equals("left") ||
+          consName.equals("right") ||
+          consName.equals("last")) {
+        ensureChildCount(constraint, 1, consName);
+        AbstractParseNode n = evalConstraint(constraint.getSubterm(0), kids, env, AbstractParseNode.class);
+        return nodeSelector(consName, n);
+      }
+      if (consName.equals("or")) {
+        ensureChildCount(constraint, 2, consName);
+        Boolean b1 = evalConstraint(constraint.getSubterm(0), kids, env, Boolean.class);
+        if (b1 != NO_VALUE && b1)
+          return true;
+        Boolean b2 = evalConstraint(constraint.getSubterm(1), kids, env, Boolean.class);
+        return b2;
+      }
+      if (consName.equals("and")) {
+        ensureChildCount(constraint, 2, consName);
+        Boolean b1 = evalConstraint(constraint.getSubterm(0), kids, env, Boolean.class);
+        if (b1 != NO_VALUE && !b1)
+          return false;
+        Boolean b2 = evalConstraint(constraint.getSubterm(1), kids, env, Boolean.class);
+        return b2;
+      }
+      if (consName.equals("not")) {
+        ensureChildCount(constraint, 1, consName);
+        Boolean b1 = evalConstraint(constraint.getSubterm(0), kids, env, Boolean.class);
+        if (b1 == NO_VALUE)
+          return NO_VALUE;
+        return !b1;
+      }
+      if (consName.equals("all")) {
+        ensureChildCount(constraint, 3, consName);
+        
+        ensureType(constraint.getSubterm(0), IStrategoString.class, constraint.getSubterm(0));
+        v = Term.asJavaString(constraint.getSubterm(0));
+        
+        AbstractParseNode n = evalConstraint(constraint.getSubterm(1), kids, env, AbstractParseNode.class);
+        
+        return checkAll(n, v, constraint, kids, env);
+      }
+      if (consName.equals("col")) {
+        ensureChildCount(constraint, 1, consName);
+        AbstractParseNode n = evalConstraint(constraint.getSubterm(0), kids, env, AbstractParseNode.class);
+        if (n == NO_VALUE)
+          return NO_VALUE;
+        return n.getColumn();
+      }
+      if (consName.equals("line")) {
+        ensureChildCount(constraint, 1, consName);
+        AbstractParseNode n = evalConstraint(constraint.getSubterm(0), kids, env, AbstractParseNode.class);
+        if (n == NO_VALUE)
+          return NO_VALUE;
+        return n.getLine();
+      }
+      
+      throw new IllegalStateException("unhandeled constructor " + consName);
+      
+    default:
+      throw new IllegalStateException("unhandeled constraint " + constraint);
+    }
+  }
+  
+  private Boolean checkAll(AbstractParseNode n, String v, IStrategoTerm constraint, AbstractParseNode[] kids, Map<String, Object> env) {
+    if (atParseTime)
+      return noValue();
+    
+    Stack<AbstractParseNode> all = new Stack<AbstractParseNode>();
+    all.push(n);
+    
+    String sort = null;
+    
+    while (!all.isEmpty()) {
+      AbstractParseNode next = all.pop();
+    
+      if (sort == null && !next.isAmbNode() && !next.isParseProductionNode())
+        sort = sortOfNode(next);
+      
+      if (next.isAmbNode()) {
+        boolean left = checkAll(next.getChildren()[0], v, constraint, kids, env);
+        boolean right = checkAll(next.getChildren()[1], v, constraint, kids, env);
+        
+        if (!left && !right)
+          return false;
+        if (left && !right) {
+          ((ParseNode) next).disambiguate(next.getChildren()[0]);
+          disambiguationCount++;
+        }
+        if (!left && right) {
+          ((ParseNode) next).disambiguate(next.getChildren()[1]);
+          disambiguationCount++;
+        }
+      }
+      else if (next.isParseProductionNode() || sort != null && !sort.equals(sortOfNode(next)) || !isListNode(next)){
+        Object old = env.get(v);
+        env.put(v, next);
+        try {
+          Boolean b = evalConstraint(constraint.getSubterm(2), kids, env, Boolean.class);
+          if (b != NO_VALUE && !b)
+            return false;
+        } finally {
+          if (old == null)
+            env.remove(v);
+          else
+            env.put(v, old);
+        }
+      }
+      else
+        for (int j = next.getChildren().length - 1; j >= 0; j--) {
+          AbstractParseNode kid = next.getChildren()[j];
+          if (kid.isAmbNode() || sort.equals(sortOfNode(kid)))
+            all.push(kid);
+        }
+
+
+    }
+    
+    return true;
+  }
+  
+  private String sortOfNode(AbstractParseNode node) {
+    
+    return attrReader.getSort((IStrategoAppl) parseTable.getLabel(node.getLabel()).getProduction().getSubterm(1));
+  }
+  
+  private boolean isListNode(AbstractParseNode node) {
+    IStrategoTerm prod = parseTable.getLabel(node.getLabel()).getProduction();
+    return attrReader.isList((IStrategoAppl) prod.getSubterm(1), (IStrategoAppl) prod.getSubterm(2)) &&
+           !attrReader.isFlatten((IStrategoAppl) prod.getSubterm(1), (IStrategoAppl) prod.getSubterm(2));
+  }
+  
+  private AbstractParseNode getSubtree(int i, AbstractParseNode[] kids) {
+    i = i - 1;
+    int elems = (kids.length + 1) / 2;
+    if (i < 0 || i >= elems)
+      throw new IllegalStateException("index out of bounds: " + "index is " + i + " but only " + elems + " children available");
+    return kids[2 * i];
+  }
+  
+  private Integer binArithOp(String op, Integer i1, Integer i2) {
+    if (i1 == NO_VALUE || i2 == NO_VALUE)
+      return noValue();
+    
+    if (op.equals("add"))
+      return i1 + i2;
+    if (op.equals("sub"))
+      return i1 - i2;
+    if (op.equals("mult"))
+      return i1 * i2;
+    if (op.equals("div"))
+      return i1 / i2;
+    
+    throw new IllegalStateException("unknown operator " + op);
+  }
+  
+  private Boolean binArithComp(String comp, Integer i1, Integer i2) {
+    if (i1 == NO_VALUE || i2 == NO_VALUE)
+      return noValue();
+    
+    if (comp.equals("eq"))
+      return i1.equals(i2);
+    if (comp.equals("gt"))
+      return i1 > i2;
+    if (comp.equals("ge"))
+      return i1 >= i2;
+    if (comp.equals("lt"))
+      return i1 < i2;
+    if (comp.equals("le"))
+      return i1 <= i2;
+      
+    throw new IllegalStateException("unknown comparator " + comp);
+  }
+
+  private AbstractParseNode nodeSelector(String sel, AbstractParseNode t) {
+    if (isNothing(t))
+      return noValue();
+    
+    if (sel.equals("first"))
+      return t;
+    if (sel.equals("last"))
+      return t.getLast();
+    
+    if (atParseTime)
+      return noValue();
+    else
+      if (sel.equals("left"))
+        return t.getLeft();
+      else if (sel.equals("right"))
+        return t.getRight();
+    
+    
+    throw new IllegalStateException("unknown selector " + sel);
+  }
+  
+  private void ensureType(Object o, Class<?> cl, IStrategoTerm term) {
+    if (o != null && !cl.isInstance(o))
+      throw new IllegalStateException("ill-typed term " + term + ". Expected type " + cl.getName() + ", was " + o.getClass().getName());
+  }
+  
+  private void ensureChildCount(IStrategoTerm t, int count, String what) {
+    if (t.getAllSubterms().length != count)
+      throw new IllegalStateException("not enough arguments to " + what);
+  }
+  
+  @SuppressWarnings("unchecked")
+  private <T> T noValue() {
+    return (T) NO_VALUE;
+  }
+  
+  private boolean isNothing(AbstractParseNode n) {
+    if (n.isAmbNode())
+      return isNothing(n.getChildren()[0]) && isNothing(n.getChildren()[1]);
+    
+    return n.isLayout() || n.isEmpty() || n.isIgnoreLayout();
+  }
+}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/client/indentation/build.xml ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/build.xml
--- src/org/spoofax/jsglr/client/indentation/build.xml	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/indentation/build.xml	2012-09-28 00:38:52.000000000 +0200
@@ -0,0 +1,98 @@
+<project>
+
+	<condition property="binary.sdf2table" value="D:\\layout-parsing\\jsglr-layout\\test-offside\\tools\\sdf2table.exe" else="/Users/seba/.nix-profile/bin/sdf2table">
+		<os family="windows" />
+	</condition>
+
+	<property name="strategoxt" value="test-offside/tools/strategoxt.jar" />
+	
+	<target name="compile">
+		<compile-grammar path="src/org/spoofax/jsglr/client/indentation" module="LayoutConstraint" />
+	</target>
+	
+	<macrodef name="compile-grammar">
+		<attribute name="module" />
+		<attribute name="path" default="." />
+		<sequential>
+			<pack-sdf source="@{path}/@{module}.sdf" output="@{path}/@{module}.def" />
+			<sdf2table source="@{path}/@{module}.def" output="@{path}/@{module}.tbl" module="@{module}" />
+		</sequential>
+	</macrodef>
+
+	
+	<macrodef name="pack-sdf">
+		<attribute name="source" />
+		<attribute name="output" />
+		<attribute name="failonerror" default="true" />
+		<sequential>
+			<java classpath="${strategoxt}" classname="start" failonerror="@{failonerror}">
+				<arg value="org.strategoxt.tools.main-pack-sdf" />
+				<arg value="-i" />
+				<arg path="@{source}" />
+				<arg value="-o" />
+				<arg path="@{output}" />
+			</java>
+		</sequential>
+	</macrodef>
+
+	<macrodef name="sdf2table">
+		<attribute name="source" />
+		<attribute name="output" />
+		<attribute name="module" />
+		<attribute name="failonerror" default="true" />
+		<sequential>
+			<exec executable="${binary.sdf2table}" failonerror="@{failonerror}">
+				<arg value="-i" />
+				<arg value="@{source}" />
+				<arg value="-o" />
+				<arg value="@{output}" />
+				<arg value="-m" />
+				<arg value="@{module}" />
+			</exec>
+		</sequential>
+	</macrodef>
+
+	<macrodef name="compile-signature">
+		<attribute name="module" />
+		<sequential>
+			<pack-sdf source="@{module}.sdf" output="@{module}.def" />
+			<sdf2rtg source="@{module}.def" output="@{module}.rtg" module="@{module}" />
+			<rtg2sig source="@{module}.rtg" output="@{module}.str" module="@{module}" />
+		</sequential>
+	</macrodef>
+
+	<macrodef name="sdf2rtg">
+		<attribute name="source" />
+		<attribute name="output" />
+		<attribute name="module" />
+		<attribute name="failonerror" default="true" />
+		<sequential>
+			<exec executable="${bindir}sdf2rtg" failonerror="@{failonerror}">
+				<arg value="-i" />
+				<arg value="@{source}"/>
+				<arg value="-o" />
+				<arg value="@{output}"/>
+				<arg value="-m" />
+				<arg value="@{module}"/>
+				<arg value="--ignore-missing-cons" />
+			</exec>
+		</sequential>
+	</macrodef>
+	
+	<macrodef name="rtg2sig">
+			<attribute name="source" />
+			<attribute name="output" />
+			<attribute name="module" />
+			<attribute name="failonerror" default="true" />
+			<sequential>
+				<exec executable="${bindir}rtg2sig" failonerror="@{failonerror}">
+					<arg value="-i" />
+					<arg value="@{source}"/>
+					<arg value="-o" />
+					<arg value="@{output}"/>
+					<arg value="--module" />
+					<arg value="@{module}"/>
+				</exec>
+			</sequential>
+		</macrodef>
+</project>
\ No newline at end of file
diff -Naur --exclude=.svn src/org/spoofax/jsglr/io/SGLR.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/io/SGLR.java
--- src/org/spoofax/jsglr/io/SGLR.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/io/SGLR.java	2012-09-28 00:32:17.000000000 +0200
@@ -79,48 +79,52 @@
 	}
 
 	/**
+	 * @throws InterruptedException 
 	 * @deprecated Call {@link #parse(Reader, String)} instead.
 	 */
 	public final Object parse(InputStream fis)
 			throws BadTokenException, TokenExpectedException, ParseException,
-			SGLRException, SGLRException, IOException {
+			SGLRException, SGLRException, IOException, InterruptedException {
 		return parse(fis, null, null);
 	}
 
 	/**
+	 * @throws InterruptedException 
 	 * @deprecated Call {@link #parse(Reader, String)} instead.
 	 */
 	public final Object parse(InputStream fis, String filename)
 			throws BadTokenException, TokenExpectedException, ParseException,
-			SGLRException, SGLRException, IOException {
+			SGLRException, SGLRException, IOException, InterruptedException {
 		return parse(fis, null, null);
 	}
 
 	/**
+	 * @throws InterruptedException 
 	 * @deprecated Call {@link #parse(Reader, String, String)} instead.
 	 */
 	public final Object parse(InputStream fis, String filename, String startSymbol)
 			throws BadTokenException, TokenExpectedException, ParseException,
-			SGLRException, IOException {
+			SGLRException, IOException, InterruptedException {
 		return parse(new InputStreamReader(fis), filename, startSymbol);
 	}
 
 	public final Object parse(Reader in) throws BadTokenException,
 			TokenExpectedException, ParseException, SGLRException,
-			SGLRException, IOException {
+			SGLRException, IOException, InterruptedException {
 		return parse(in, null, null);
 	}
 
 	public final Object parse(Reader in, String filename)
 			throws BadTokenException, TokenExpectedException, ParseException,
-			SGLRException, SGLRException, IOException {
+			SGLRException, SGLRException, IOException, InterruptedException {
 		return parse(in, null, null);
 	}
 
 	public Object parse(Reader in, String filename, String startSymbol)
 			throws BadTokenException, TokenExpectedException, ParseException,
-			SGLRException, IOException {
+			SGLRException, IOException, InterruptedException {
 		String input = FileTools.loadFileAsString(in);
 		return parse(input, filename, startSymbol);
 	}
+
 }
diff -Naur --exclude=.svn src/org/spoofax/jsglr/shared/BadIndentationException.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/shared/BadIndentationException.java
--- src/org/spoofax/jsglr/shared/BadIndentationException.java	1970-01-01 01:00:00.000000000 +0100
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/shared/BadIndentationException.java	2012-09-28 00:32:18.000000000 +0200
@@ -0,0 +1,26 @@
+package org.spoofax.jsglr.shared;
+
+import org.spoofax.jsglr.client.SGLR;
+
+/**
+ * @author Sebastian Erdweg <seba at informatik uni-marburg de>
+ */
+public class BadIndentationException extends BadTokenException {
+
+  private static final long serialVersionUID = 8916741860327644938L;
+
+  private final int indentation;
+  private final int expectedIndentation;
+
+  public BadIndentationException(SGLR parser, int token, int offset, int lineNumber, int columnNumber, int indentation, int expectedIndentation) {
+    super(parser, token, offset, lineNumber, columnNumber);
+    this.indentation = indentation;
+    this.expectedIndentation = expectedIndentation;
+  }
+
+  @Override
+  public String getShortMessage() {
+    return "Unexpected indentation of character '" + escape(getToken()) + "': was " + indentation + ", expected " + expectedIndentation;
+  }
+
+}
diff -Naur --exclude=.svn src/org/spoofax/jsglr/shared/BadTokenException.java ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/shared/BadTokenException.java
--- src/org/spoofax/jsglr/shared/BadTokenException.java	2012-09-28 00:52:40.000000000 +0200
+++ ../../../../projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/shared/BadTokenException.java	2012-09-28 00:32:18.000000000 +0200
@@ -36,7 +36,7 @@
 
     @Override
     public String getMessage() {
-        return getShortMessage() + " at line " + lineNumber + ", column " + columnNumber;
+        return getShortMessage() + " at line " + (lineNumber + 1)  + ", column " + (columnNumber - 1);
     }
 
     @Override
@@ -47,7 +47,7 @@
             return "Syntax error near unexpected character '" + escape(token) + "'";
     }
 
-    private String escape(int ch) {
+    protected String escape(int ch) {
     	switch(ch) {
     	case 0: return "\\0";
     	case '\n': return "\\n";
